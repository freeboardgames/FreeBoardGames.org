(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./node_modules/@material-ui/icons/Feedback.js":
/*!*****************************************************!*\
  !*** ./node_modules/@material-ui/icons/Feedback.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement("path", {
  d: "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 12h-2v-2h2v2zm0-4h-2V6h2v4z"
}), 'Feedback');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/Home.js":
/*!*************************************************!*\
  !*** ./node_modules/@material-ui/icons/Home.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement("path", {
  d: "M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"
}), 'Home');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/MoreVert.js":
/*!*****************************************************!*\
  !*** ./node_modules/@material-ui/icons/MoreVert.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), 'MoreVert');

exports.default = _default;

/***/ }),

/***/ "./node_modules/@material-ui/icons/Replay.js":
/*!***************************************************!*\
  !*** ./node_modules/@material-ui/icons/Replay.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)(_react.default.createElement("path", {
  d: "M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"
}), 'Replay');

exports.default = _default;

/***/ }),

/***/ "./node_modules/boardgame.io/dist/esm/core.js":
/*!****************************************************!*\
  !*** ./node_modules/boardgame.io/dist/esm/core.js ***!
  \****************************************************/
/*! exports provided: ActivePlayers, INVALID_MOVE, Stage, TurnOrder, PlayerView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlayerView", function() { return PlayerView; });
/* harmony import */ var _reducer_b8b81041_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reducer-b8b81041.js */ "./node_modules/boardgame.io/dist/esm/reducer-b8b81041.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActivePlayers", function() { return _reducer_b8b81041_js__WEBPACK_IMPORTED_MODULE_0__["q"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "INVALID_MOVE", function() { return _reducer_b8b81041_js__WEBPACK_IMPORTED_MODULE_0__["I"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stage", function() { return _reducer_b8b81041_js__WEBPACK_IMPORTED_MODULE_0__["t"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TurnOrder", function() { return _reducer_b8b81041_js__WEBPACK_IMPORTED_MODULE_0__["T"]; });

/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ "./node_modules/immer/dist/immer.module.js");




/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

/**
 * PlayerView reducers.
 */
var PlayerView = {
  /**
   * STRIP_SECRETS
   *
   * Reducer which removes a key named `secret` and
   * removes all the keys in `players`, except for the one
   * corresponding to the current playerID.
   */
  STRIP_SECRETS: function STRIP_SECRETS(G, ctx, playerID) {
    var r = Object(_reducer_b8b81041_js__WEBPACK_IMPORTED_MODULE_0__["k"])({}, G);

    if (r.secret !== undefined) {
      delete r.secret;
    }

    if (r.players) {
      r.players = Object(_reducer_b8b81041_js__WEBPACK_IMPORTED_MODULE_0__["b"])({}, playerID, r.players[playerID]);
    }

    return r;
  }
};




/***/ }),

/***/ "./node_modules/boardgame.io/dist/esm/reducer-b8b81041.js":
/*!****************************************************************!*\
  !*** ./node_modules/boardgame.io/dist/esm/reducer-b8b81041.js ***!
  \****************************************************************/
/*! exports provided: A, C, E, F, G, I, M, R, S, T, U, _, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return ActionCreators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return CreateGameReducer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return Enhance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return Flush; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return Game; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return INVALID_MOVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "M", function() { return MAKE_MOVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return RESET; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return Setup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return TurnOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "U", function() { return UPDATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_", function() { return _createClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _classCallCheck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _defineProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return alea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return _inherits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return error; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return _possibleConstructorReturn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return gameEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return _getPrototypeOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return _typeof; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return EnhanceCtx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return _objectSpread2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return redo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return makeMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return GAME_EVENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return _toConsumableArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return SYNC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return ActivePlayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return reset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return sync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return Stage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return undo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return _assertThisInitialized; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return UNDO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return REDO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return _objectWithoutProperties; });
/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! immer */ "./node_modules/immer/dist/immer.module.js");


function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
const MAKE_MOVE = 'MAKE_MOVE';
const GAME_EVENT = 'GAME_EVENT';
const REDO = 'REDO';
const RESET = 'RESET';
const SYNC = 'SYNC';
const UNDO = 'UNDO';
const UPDATE = 'UPDATE';
const PLUGIN = 'PLUGIN';

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
/**
 * Generate a move to be dispatched to the game move reducer.
 *
 * @param {string} type - The move type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
const makeMove = (type, args, playerID, credentials) => ({
    type: MAKE_MOVE,
    payload: { type, args, playerID, credentials },
});
/**
 * Generate a game event to be dispatched to the flow reducer.
 *
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
const gameEvent = (type, args, playerID, credentials) => ({
    type: GAME_EVENT,
    payload: { type, args, playerID, credentials },
});
/**
 * Generate an automatic game event that is a side-effect of a move.
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */
const automaticGameEvent = (type, args, playerID, credentials) => ({
    type: GAME_EVENT,
    payload: { type, args, playerID, credentials },
    automatic: true,
});
const sync = (info) => ({
    type: SYNC,
    state: info.state,
    log: info.log,
    initialState: info.initialState,
    clientOnly: true,
});
/**
 * Used to update the Redux store's state in response to
 * an action coming from another player.
 * @param {object} state - The state to restore.
 * @param {Array} deltalog - A log delta.
 */
const update = (state, deltalog) => ({
    type: UPDATE,
    state,
    deltalog,
    clientOnly: true,
});
/**
 * Used to reset the game state.
 * @param {object} state - The initial state.
 */
const reset = (state) => ({
    type: RESET,
    state,
    clientOnly: true,
});
/**
 * Used to undo the last move.
 */
const undo = () => ({
    type: UNDO,
});
/**
 * Used to redo the last undone move.
 */
const redo = () => ({
    type: REDO,
});
/**
 * Allows plugins to define their own actions and intercept them.
 */
const plugin = (type, args, playerID, credentials) => ({
    type: PLUGIN,
    payload: { type, args, playerID, credentials },
});

var ActionCreators = /*#__PURE__*/Object.freeze({
  makeMove: makeMove,
  gameEvent: gameEvent,
  automaticGameEvent: automaticGameEvent,
  sync: sync,
  update: update,
  reset: reset,
  undo: undo,
  redo: redo,
  plugin: plugin
});

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
/**
 * Plugin that allows using Immer to make immutable changes
 * to G by just mutating it.
 */

var PluginImmer = {
  name: 'plugin-immer',
  fnWrap: function fnWrap(move) {
    return Object(immer__WEBPACK_IMPORTED_MODULE_0__["default"])(move);
  }
};

// Inlined version of Alea from https://github.com/davidbau/seedrandom.

/*
 * Copyright 2015 David Bau.
 *
 * Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software
 * and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
function Alea(seed) {
  var me = this,
      mash = Mash();

  me.next = function () {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32

    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  }; // Apply the seeding algorithm from Baagoe.


  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);

  if (me.s0 < 0) {
    me.s0 += 1;
  }

  me.s1 -= mash(seed);

  if (me.s1 < 0) {
    me.s1 += 1;
  }

  me.s2 -= mash(seed);

  if (me.s2 < 0) {
    me.s2 += 1;
  }

  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function mash(data) {
    data = data.toString();

    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}

function alea(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.quick = prng;

  if (state) {
    if (_typeof(state) == 'object') copy(state, xg);

    prng.state = function () {
      return copy(xg, {});
    };
  }

  return prng;
}

/**
 * Random
 *
 * Calls that require a pseudorandom number generator.
 * Uses a seed from ctx, and also persists the PRNG
 * state in ctx so that moves can stay pure.
 */

var Random =
/*#__PURE__*/
function () {
  /**
   * constructor
   * @param {object} ctx - The ctx object to initialize from.
   */
  function Random(state) {
    _classCallCheck(this, Random);

    // If we are on the client, the seed is not present.
    // Just use a temporary seed to execute the move without
    // crashing it. The move state itself is discarded,
    // so the actual value doesn't matter.
    this.state = state;
    this.used = false;
  }

  _createClass(Random, [{
    key: "isUsed",
    value: function isUsed() {
      return this.used;
    }
  }, {
    key: "getState",
    value: function getState() {
      return this.state;
    }
    /**
     * Generate a random number.
     */

  }, {
    key: "_random",
    value: function _random() {
      this.used = true;
      var R = this.state;
      var fn;

      if (R.prngstate === undefined) {
        // No call to a random function has been made.
        fn = new alea(R.seed, {
          state: true
        });
      } else {
        fn = new alea('', {
          state: R.prngstate
        });
      }

      var number = fn();
      this.state = _objectSpread2({}, R, {
        prngstate: fn.state()
      });
      return number;
    }
  }, {
    key: "api",
    value: function api() {
      var random = this._random.bind(this);

      var SpotValue = {
        D4: 4,
        D6: 6,
        D8: 8,
        D10: 10,
        D12: 12,
        D20: 20
      }; // Generate functions for predefined dice values D4 - D20.

      var predefined = {};

      var _loop = function _loop(key) {
        var spotvalue = SpotValue[key];

        predefined[key] = function (diceCount) {
          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return _toConsumableArray(new Array(diceCount).keys()).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        };
      };

      for (var key in SpotValue) {
        _loop(key);
      }

      return _objectSpread2({}, predefined, {
        /**
         * Roll a die of specified spot value.
         *
         * @param {number} spotvalue - The die dimension (default: 6).
         * @param {number} diceCount - number of dice to throw.
         *                             if not defined, defaults to 1 and returns the value directly.
         *                             if defined, returns an array containing the random dice values.
         */
        Die: function Die(spotvalue, diceCount) {
          if (spotvalue === undefined) {
            spotvalue = 6;
          }

          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return _toConsumableArray(new Array(diceCount).keys()).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        },

        /**
         * Generate a random number between 0 and 1.
         */
        Number: function Number() {
          return random();
        },

        /**
         * Shuffle an array.
         *
         * @param {Array} deck - The array to shuffle. Does not mutate
         *                       the input, but returns the shuffled array.
         */
        Shuffle: function Shuffle(deck) {
          var clone = deck.slice(0);
          var srcIndex = deck.length;
          var dstIndex = 0;
          var shuffled = new Array(srcIndex);

          while (srcIndex) {
            var randIndex = srcIndex * random() | 0;
            shuffled[dstIndex++] = clone[randIndex];
            clone[randIndex] = clone[--srcIndex];
          }

          return shuffled;
        },
        _obj: this
      });
    }
  }]);

  return Random;
}();
/**
 * Generates a new seed from the current date / time.
 */

Random.seed = function () {
  return (+new Date()).toString(36).slice(-10);
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
var PluginRandom = {
    name: 'random',
    noClient: ({ api }) => {
        return api._obj.isUsed();
    },
    flush: ({ api }) => {
        return api._obj.getState();
    },
    api: ({ data }) => {
        const random = new Random(data);
        return random.api();
    },
    setup: ({ game }) => {
        let seed = game.seed;
        if (seed === undefined) {
            seed = Random.seed();
        }
        return { seed };
    },
};

/**
 * Events
 */

var Events =
/*#__PURE__*/
function () {
  function Events(flow, playerID) {
    _classCallCheck(this, Events);

    this.flow = flow;
    this.playerID = playerID;
    this.dispatch = [];
  }
  /**
   * Attaches the Events API to ctx.
   * @param {object} ctx - The ctx object to attach to.
   */


  _createClass(Events, [{
    key: "api",
    value: function api(ctx) {
      var _this = this;

      var events = {};
      var phase = ctx.phase,
          turn = ctx.turn;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var key = _step.value;

          events[key] = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this.dispatch.push({
              key: key,
              args: args,
              phase: phase,
              turn: turn
            });
          };
        };

        for (var _iterator = this.flow.eventNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      events._obj = this;
      return events;
    }
  }, {
    key: "isUsed",
    value: function isUsed() {
      return this.dispatch.length > 0;
    }
    /**
     * Updates ctx with the triggered events.
     * @param {object} state - The state object { G, ctx }.
     */

  }, {
    key: "update",
    value: function update(state) {
      for (var i = 0; i < this.dispatch.length; i++) {
        var item = this.dispatch[i]; // If the turn already ended some other way,
        // don't try to end the turn again.

        if (item.key === 'endTurn' && item.turn !== state.ctx.turn) {
          continue;
        } // If the phase already ended some other way,
        // don't try to end the phase again.


        if ((item.key === 'endPhase' || item.key === 'setPhase') && item.phase !== state.ctx.phase) {
          continue;
        }

        var action = automaticGameEvent(item.key, item.args, this.playerID);
        state = _objectSpread2({}, state, {}, this.flow.processEvent(state, action));
      }

      return state;
    }
  }]);

  return Events;
}();

/*
 * Copyright 2020 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
var PluginEvents = {
    name: 'events',
    noClient: ({ api }) => {
        return api._obj.isUsed();
    },
    flushRaw: ({ state, api }) => {
        return api._obj.update(state);
    },
    api: ({ game, playerID, ctx }) => {
        return new Events(game.flow, playerID).api(ctx);
    },
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
/**
 * List of plugins that are always added.
 */
const DEFAULT_PLUGINS = [PluginImmer, PluginRandom, PluginEvents];
/**
 * Allow plugins to intercept actions and process them.
 */
const ProcessAction = (state, action, opts) => {
    opts.game.plugins
        .filter(plugin => plugin.action !== undefined)
        .filter(plugin => plugin.name === action.payload.type)
        .forEach(plugin => {
        const name = plugin.name;
        const pluginState = state.plugins[name] || { data: {} };
        const data = plugin.action(pluginState.data, action.payload);
        state = {
            ...state,
            plugins: {
                ...state.plugins,
                [name]: { ...pluginState, data },
            },
        };
    });
    return state;
};
/**
 * The API's created by various plugins are stored in the plugins
 * section of the state object:
 *
 * {
 *   G: {},
 *   ctx: {},
 *   plugins: {
 *     plugin-a: {
 *       data: {},  // this is generated by the plugin at Setup / Flush.
 *       api: {},   // this is ephemeral and generated by Enhance.
 *     }
 *   }
 * }
 *
 * This function takes these API's and stuffs them back into
 * ctx for consumption inside a move function or hook.
 */
const EnhanceCtx = (state) => {
    let ctx = { ...state.ctx };
    const plugins = state.plugins || {};
    Object.entries(plugins).forEach(([name, { api }]) => {
        ctx[name] = api;
    });
    return ctx;
};
/**
 * Applies the provided plugins to the given move / flow function.
 *
 * @param {function} fn - The move function or trigger to apply the plugins to.
 * @param {object} plugins - The list of plugins.
 */
const FnWrap = (fn, plugins) => {
    const reducer = (acc, { fnWrap }) => fnWrap(acc, plugins);
    return [...DEFAULT_PLUGINS, ...plugins]
        .filter(plugin => plugin.fnWrap !== undefined)
        .reduce(reducer, fn);
};
/**
 * Allows the plugin to generate its initial state.
 */
const Setup = (state, opts) => {
    [...DEFAULT_PLUGINS, ...opts.game.plugins]
        .filter(plugin => plugin.setup !== undefined)
        .forEach(plugin => {
        const name = plugin.name;
        const data = plugin.setup({
            G: state.G,
            ctx: state.ctx,
            game: opts.game,
        });
        state = {
            ...state,
            plugins: {
                ...state.plugins,
                [name]: { data },
            },
        };
    });
    return state;
};
/**
 * Invokes the plugin before a move or event.
 * The API that the plugin generates is stored inside
 * the `plugins` section of the state (which is subsequently
 * merged into ctx).
 */
const Enhance = (state, opts) => {
    [...DEFAULT_PLUGINS, ...opts.game.plugins]
        .filter(plugin => plugin.api !== undefined)
        .forEach(plugin => {
        const name = plugin.name;
        const pluginState = state.plugins[name] || { data: {} };
        const api = plugin.api({
            G: state.G,
            ctx: state.ctx,
            data: pluginState.data,
            game: opts.game,
        });
        state = {
            ...state,
            plugins: {
                ...state.plugins,
                [name]: { ...pluginState, api },
            },
        };
    });
    return state;
};
/**
 * Allows plugins to update their state after a move / event.
 */
const Flush = (state, opts) => {
    [...DEFAULT_PLUGINS, ...opts.game.plugins].forEach(plugin => {
        const name = plugin.name;
        const pluginState = state.plugins[name] || { data: {} };
        if (plugin.flush) {
            const newData = plugin.flush({
                G: state.G,
                ctx: state.ctx,
                game: opts.game,
                api: pluginState.api,
                data: pluginState.data,
            });
            state = {
                ...state,
                plugins: {
                    ...state.plugins,
                    [plugin.name]: { data: newData },
                },
            };
        }
        else if (plugin.flushRaw) {
            state = plugin.flushRaw({
                state,
                game: opts.game,
                api: pluginState.api,
                data: pluginState.data,
            });
            // Remove everything other than data.
            const data = state.plugins[name].data;
            state = {
                ...state,
                plugins: {
                    ...state.plugins,
                    [plugin.name]: { data },
                },
            };
        }
    });
    return state;
};
/**
 * Allows plugins to indicate if they should not be materialized on the client.
 * This will cause the client to discard the state update and wait for the
 * master instead.
 */
const NoClient = (state, opts) => {
    return [...DEFAULT_PLUGINS, ...opts.game.plugins]
        .filter(plugin => plugin.noClient !== undefined)
        .map(plugin => {
        const name = plugin.name;
        const pluginState = state.plugins[name];
        if (pluginState) {
            return plugin.noClient({
                G: state.G,
                ctx: state.ctx,
                game: opts.game,
                api: pluginState.api,
                data: pluginState.data,
            });
        }
        return false;
    })
        .some(value => value === true);
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
var production = "development" === 'production';
var logfn = production ? function () {} : console.log;
var errorfn = console.error;
function info(msg) {
  logfn("INFO: ".concat(msg));
}
function error(error) {
  errorfn('ERROR:', error);
}

/**
 * Event to change the active players (and their stages) in the current turn.
 */

function SetActivePlayersEvent(state, _playerID, arg) {
  return _objectSpread2({}, state, {
    ctx: SetActivePlayers(state.ctx, arg)
  });
}
function SetActivePlayers(ctx, arg) {
  var _prevActivePlayers = ctx._prevActivePlayers;

  var _nextActivePlayers = arg.next || null;

  if (arg.revert) {
    _prevActivePlayers = _prevActivePlayers.concat({
      activePlayers: ctx.activePlayers,
      _activePlayersMoveLimit: ctx._activePlayersMoveLimit,
      _activePlayersNumMoves: ctx._activePlayersNumMoves
    });
  } else {
    _prevActivePlayers = [];
  }

  var activePlayers = {};
  var _activePlayersMoveLimit = {};

  if (Array.isArray(arg)) {
    var value = {};
    arg.forEach(function (v) {
      return value[v] = Stage.NULL;
    });
    activePlayers = value;
  }

  if (arg.currentPlayer !== undefined) {
    ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, ctx.currentPlayer, arg.currentPlayer);
  }

  if (arg.others !== undefined) {
    for (var i = 0; i < ctx.playOrder.length; i++) {
      var id = ctx.playOrder[i];

      if (id !== ctx.currentPlayer) {
        ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, id, arg.others);
      }
    }
  }

  if (arg.all !== undefined) {
    for (var _i = 0; _i < ctx.playOrder.length; _i++) {
      var _id = ctx.playOrder[_i];
      ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, _id, arg.all);
    }
  }

  if (arg.value) {
    for (var _id2 in arg.value) {
      ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, _id2, arg.value[_id2]);
    }
  }

  if (arg.moveLimit) {
    for (var _id3 in activePlayers) {
      if (_activePlayersMoveLimit[_id3] === undefined) {
        _activePlayersMoveLimit[_id3] = arg.moveLimit;
      }
    }
  }

  if (Object.keys(activePlayers).length == 0) {
    activePlayers = null;
  }

  if (Object.keys(_activePlayersMoveLimit).length == 0) {
    _activePlayersMoveLimit = null;
  }

  var _activePlayersNumMoves = {};

  for (var _id4 in activePlayers) {
    _activePlayersNumMoves[_id4] = 0;
  }

  return _objectSpread2({}, ctx, {
    activePlayers: activePlayers,
    _activePlayersMoveLimit: _activePlayersMoveLimit,
    _activePlayersNumMoves: _activePlayersNumMoves,
    _prevActivePlayers: _prevActivePlayers,
    _nextActivePlayers: _nextActivePlayers
  });
}
/**
 * Update activePlayers, setting it to previous, next or null values
 * when it becomes empty.
 * @param {Object} ctx
 */

function UpdateActivePlayersOnceEmpty(ctx) {
  var _ctx = ctx,
      activePlayers = _ctx.activePlayers,
      _activePlayersMoveLimit = _ctx._activePlayersMoveLimit,
      _activePlayersNumMoves = _ctx._activePlayersNumMoves,
      _prevActivePlayers = _ctx._prevActivePlayers;

  if (activePlayers && Object.keys(activePlayers).length == 0) {
    if (ctx._nextActivePlayers) {
      ctx = SetActivePlayers(ctx, ctx._nextActivePlayers);
      var _ctx2 = ctx;
      activePlayers = _ctx2.activePlayers;
      _activePlayersMoveLimit = _ctx2._activePlayersMoveLimit;
      _activePlayersNumMoves = _ctx2._activePlayersNumMoves;
      _prevActivePlayers = _ctx2._prevActivePlayers;
    } else if (_prevActivePlayers.length > 0) {
      var lastIndex = _prevActivePlayers.length - 1;
      var _prevActivePlayers$la = _prevActivePlayers[lastIndex];
      activePlayers = _prevActivePlayers$la.activePlayers;
      _activePlayersMoveLimit = _prevActivePlayers$la._activePlayersMoveLimit;
      _activePlayersNumMoves = _prevActivePlayers$la._activePlayersNumMoves;
      _prevActivePlayers = _prevActivePlayers.slice(0, lastIndex);
    } else {
      activePlayers = null;
      _activePlayersMoveLimit = null;
    }
  }

  return _objectSpread2({}, ctx, {
    activePlayers: activePlayers,
    _activePlayersMoveLimit: _activePlayersMoveLimit,
    _activePlayersNumMoves: _activePlayersNumMoves,
    _prevActivePlayers: _prevActivePlayers
  });
}
/**
 * Apply an active player argument to the given player ID
 * @param {Object} activePlayers
 * @param {Object} _activePlayersMoveLimit
 * @param {String} playerID The player to apply the parameter to
 * @param {(String|Object)} arg An active player argument
 */

function ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, playerID, arg) {
  if (_typeof(arg) !== 'object' || arg === Stage.NULL) {
    arg = {
      stage: arg
    };
  }

  if (arg.stage !== undefined) {
    activePlayers[playerID] = arg.stage;
    if (arg.moveLimit) _activePlayersMoveLimit[playerID] = arg.moveLimit;
  }
}
/**
 * Converts a playOrderPos index into its value in playOrder.
 * @param {Array} playOrder - An array of player ID's.
 * @param {number} playOrderPos - An index into the above.
 */


function getCurrentPlayer(playOrder, playOrderPos) {
  return playOrder[playOrderPos] + '';
}
/**
 * Called at the start of a turn to initialize turn order state.
 *
 * TODO: This is called inside StartTurn, which is called from
 * both UpdateTurn and StartPhase (so it's called at the beginning
 * of a new phase as well as between turns). We should probably
 * split it into two.
 *
 * @param {object} G - The game object G.
 * @param {object} ctx - The game object ctx.
 * @param {object} turn - A turn object for this phase.
 */


function InitTurnOrderState(G, ctx, turn) {
  var order = turn.order;

  var playOrder = _toConsumableArray(new Array(ctx.numPlayers)).map(function (d, i) {
    return i + '';
  });

  if (order.playOrder !== undefined) {
    playOrder = order.playOrder(G, ctx);
  }

  var playOrderPos = order.first(G, ctx);
  var currentPlayer = getCurrentPlayer(playOrder, playOrderPos);
  ctx = _objectSpread2({}, ctx, {
    currentPlayer: currentPlayer,
    playOrderPos: playOrderPos,
    playOrder: playOrder
  });
  ctx = SetActivePlayers(ctx, turn.activePlayers || {});
  return ctx;
}
/**
 * Called at the end of each turn to update the turn order state.
 * @param {object} G - The game object G.
 * @param {object} ctx - The game object ctx.
 * @param {object} turn - A turn object for this phase.
 * @param {string} endTurnArg - An optional argument to endTurn that
                                may specify the next player.
 */

function UpdateTurnOrderState(G, ctx, turn, endTurnArg) {
  var order = turn.order;
  var playOrderPos = ctx.playOrderPos;
  var currentPlayer = ctx.currentPlayer;
  var endPhase = false;

  if (endTurnArg && endTurnArg !== true) {
    if (_typeof(endTurnArg) !== 'object') {
      error("invalid argument to endTurn: ".concat(endTurnArg));
    }

    Object.keys(endTurnArg).forEach(function (arg) {
      switch (arg) {
        case 'remove':
          currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);
          break;

        case 'next':
          playOrderPos = ctx.playOrder.indexOf(endTurnArg.next);
          currentPlayer = endTurnArg.next;
          break;

        default:
          error("invalid argument to endTurn: ".concat(arg));
      }
    });
  } else {
    var t = order.next(G, ctx);

    if (t === undefined) {
      endPhase = true;
    } else {
      playOrderPos = t;
      currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);
    }
  }

  ctx = _objectSpread2({}, ctx, {
    playOrderPos: playOrderPos,
    currentPlayer: currentPlayer
  });
  return {
    endPhase: endPhase,
    ctx: ctx
  };
}
/**
 * Set of different turn orders possible in a phase.
 * These are meant to be passed to the `turn` setting
 * in the flow objects.
 *
 * Each object defines the first player when the phase / game
 * begins, and also a function `next` to determine who the
 * next player is when the turn ends.
 *
 * The phase ends if next() returns undefined.
 */

var TurnOrder = {
  /**
   * DEFAULT
   *
   * The default round-robin turn order.
   */
  DEFAULT: {
    first: function first(G, ctx) {
      return ctx.turn === 0 ? ctx.playOrderPos : (ctx.playOrderPos + 1) % ctx.playOrder.length;
    },
    next: function next(G, ctx) {
      return (ctx.playOrderPos + 1) % ctx.playOrder.length;
    }
  },

  /**
   * RESET
   *
   * Similar to DEFAULT, but starts from 0 each time.
   */
  RESET: {
    first: function first() {
      return 0;
    },
    next: function next(G, ctx) {
      return (ctx.playOrderPos + 1) % ctx.playOrder.length;
    }
  },

  /**
   * CONTINUE
   *
   * Similar to DEFAULT, but starts with the player who ended the last phase.
   */
  CONTINUE: {
    first: function first(G, ctx) {
      return ctx.playOrderPos;
    },
    next: function next(G, ctx) {
      return (ctx.playOrderPos + 1) % ctx.playOrder.length;
    }
  },

  /**
   * ONCE
   *
   * Another round-robin turn order, but goes around just once.
   * The phase ends after all players have played.
   */
  ONCE: {
    first: function first() {
      return 0;
    },
    next: function next(G, ctx) {
      if (ctx.playOrderPos < ctx.playOrder.length - 1) {
        return ctx.playOrderPos + 1;
      }
    }
  },

  /**
   * CUSTOM
   *
   * Identical to DEFAULT, but also sets playOrder at the
   * beginning of the phase.
   *
   * @param {Array} playOrder - The play order.
   */
  CUSTOM: function CUSTOM(_playOrder) {
    return {
      playOrder: function playOrder() {
        return _playOrder;
      },
      first: function first() {
        return 0;
      },
      next: function next(G, ctx) {
        return (ctx.playOrderPos + 1) % ctx.playOrder.length;
      }
    };
  },

  /**
   * CUSTOM_FROM
   *
   * Identical to DEFAULT, but also sets playOrder at the
   * beginning of the phase to a value specified by a field
   * in G.
   *
   * @param {string} playOrderField - Field in G.
   */
  CUSTOM_FROM: function CUSTOM_FROM(playOrderField) {
    return {
      playOrder: function playOrder(G) {
        return G[playOrderField];
      },
      first: function first() {
        return 0;
      },
      next: function next(G, ctx) {
        return (ctx.playOrderPos + 1) % ctx.playOrder.length;
      }
    };
  }
};
var Stage = {
  NULL: null
};
var ActivePlayers = {
  /**
   * ALL
   *
   * The turn stays with one player, but any player can play (in any order)
   * until the phase ends.
   */
  ALL: {
    all: Stage.NULL
  },

  /**
   * ALL_ONCE
   *
   * The turn stays with one player, but any player can play (once, and in any order).
   * This is typically used in a phase where you want to elicit a response
   * from every player in the game.
   */
  ALL_ONCE: {
    all: Stage.NULL,
    moveLimit: 1
  },

  /**
   * OTHERS
   *
   * The turn stays with one player, and every *other* player can play (in any order)
   * until the phase ends.
   */
  OTHERS: {
    others: Stage.NULL
  },

  /**
   * OTHERS_ONCE
   *
   * The turn stays with one player, and every *other* player can play (once, and in any order).
   * This is typically used in a phase where you want to elicit a response
   * from every *other* player in the game.
   */
  OTHERS_ONCE: {
    others: Stage.NULL,
    moveLimit: 1
  }
};

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
/**
 * Flow
 *
 * Creates a reducer that updates ctx (analogous to how moves update G).
 */
function Flow({ moves, phases, endIf, onEnd, turn, events, plugins, }) {
    // Attach defaults.
    if (moves === undefined) {
        moves = {};
    }
    if (events === undefined) {
        events = {};
    }
    if (plugins === undefined) {
        plugins = [];
    }
    if (phases === undefined) {
        phases = {};
    }
    if (!endIf)
        endIf = () => undefined;
    if (!onEnd)
        onEnd = G => G;
    if (!turn)
        turn = {};
    const phaseMap = { ...phases };
    if ('' in phaseMap) {
        error('cannot specify phase with empty name');
    }
    phaseMap[''] = {};
    let moveMap = {};
    let moveNames = new Set();
    let startingPhase = null;
    Object.keys(moves).forEach(name => moveNames.add(name));
    const HookWrapper = (fn) => {
        const withPlugins = FnWrap(fn, plugins);
        return (state) => {
            const ctxWithAPI = EnhanceCtx(state);
            return withPlugins(state.G, ctxWithAPI);
        };
    };
    const TriggerWrapper = (endIf) => {
        return (state) => {
            let ctxWithAPI = EnhanceCtx(state);
            return endIf(state.G, ctxWithAPI);
        };
    };
    const wrapped = {
        onEnd: HookWrapper(onEnd),
        endIf: TriggerWrapper(endIf),
    };
    for (let phase in phaseMap) {
        const conf = phaseMap[phase];
        if (conf.start === true) {
            startingPhase = phase;
        }
        if (conf.moves !== undefined) {
            for (let move of Object.keys(conf.moves)) {
                moveMap[phase + '.' + move] = conf.moves[move];
                moveNames.add(move);
            }
        }
        if (conf.endIf === undefined) {
            conf.endIf = () => undefined;
        }
        if (conf.onBegin === undefined) {
            conf.onBegin = G => G;
        }
        if (conf.onEnd === undefined) {
            conf.onEnd = G => G;
        }
        if (conf.turn === undefined) {
            conf.turn = turn;
        }
        if (conf.turn.order === undefined) {
            conf.turn.order = TurnOrder.DEFAULT;
        }
        if (conf.turn.onBegin === undefined) {
            conf.turn.onBegin = G => G;
        }
        if (conf.turn.onEnd === undefined) {
            conf.turn.onEnd = G => G;
        }
        if (conf.turn.endIf === undefined) {
            conf.turn.endIf = () => false;
        }
        if (conf.turn.onMove === undefined) {
            conf.turn.onMove = G => G;
        }
        if (conf.turn.stages === undefined) {
            conf.turn.stages = {};
        }
        for (const stage in conf.turn.stages) {
            const stageConfig = conf.turn.stages[stage];
            const moves = stageConfig.moves || {};
            for (let move of Object.keys(moves)) {
                let key = phase + '.' + stage + '.' + move;
                moveMap[key] = moves[move];
                moveNames.add(move);
            }
        }
        conf.wrapped = {
            onBegin: HookWrapper(conf.onBegin),
            onEnd: HookWrapper(conf.onEnd),
            endIf: TriggerWrapper(conf.endIf),
        };
        conf.turn.wrapped = {
            onMove: HookWrapper(conf.turn.onMove),
            onBegin: HookWrapper(conf.turn.onBegin),
            onEnd: HookWrapper(conf.turn.onEnd),
            endIf: TriggerWrapper(conf.turn.endIf),
        };
    }
    function GetPhase(ctx) {
        return ctx.phase ? phaseMap[ctx.phase] : phaseMap[''];
    }
    function OnMove(s) {
        return s;
    }
    function Process(state, events) {
        const phasesEnded = new Set();
        const turnsEnded = new Set();
        for (let i = 0; i < events.length; i++) {
            const { fn, arg, ...rest } = events[i];
            // Detect a loop of EndPhase calls.
            // This could potentially even be an infinite loop
            // if the endIf condition of each phase blindly
            // returns true. The moment we detect a single
            // loop, we just bail out of all phases.
            if (fn === EndPhase) {
                turnsEnded.clear();
                const phase = state.ctx.phase;
                if (phasesEnded.has(phase)) {
                    const ctx = { ...state.ctx, phase: null };
                    return { ...state, ctx };
                }
                phasesEnded.add(phase);
            }
            // Process event.
            let next = [];
            state = fn(state, {
                ...rest,
                arg,
                next,
            });
            if (fn === EndGame) {
                break;
            }
            // Check if we should end the game.
            const shouldEndGame = ShouldEndGame(state);
            if (shouldEndGame) {
                events.push({
                    fn: EndGame,
                    arg: shouldEndGame,
                    turn: state.ctx.turn,
                    phase: state.ctx.phase,
                    automatic: true,
                });
                continue;
            }
            // Check if we should end the phase.
            const shouldEndPhase = ShouldEndPhase(state);
            if (shouldEndPhase) {
                events.push({
                    fn: EndPhase,
                    arg: shouldEndPhase,
                    turn: state.ctx.turn,
                    phase: state.ctx.phase,
                    automatic: true,
                });
                continue;
            }
            // Check if we should end the turn.
            if (fn === OnMove) {
                const shouldEndTurn = ShouldEndTurn(state);
                if (shouldEndTurn) {
                    events.push({
                        fn: EndTurn,
                        arg: shouldEndTurn,
                        turn: state.ctx.turn,
                        phase: state.ctx.phase,
                        automatic: true,
                    });
                    continue;
                }
            }
            events.push(...next);
        }
        return state;
    }
    ///////////
    // Start //
    ///////////
    function StartGame(state, { next }) {
        next.push({ fn: StartPhase });
        return state;
    }
    function StartPhase(state, { next }) {
        let { G, ctx } = state;
        const conf = GetPhase(ctx);
        // Run any phase setup code provided by the user.
        G = conf.wrapped.onBegin(state);
        next.push({ fn: StartTurn });
        return { ...state, G, ctx };
    }
    function StartTurn(state, { currentPlayer }) {
        let { G, ctx } = state;
        const conf = GetPhase(ctx);
        // Initialize the turn order state.
        if (currentPlayer) {
            ctx = { ...ctx, currentPlayer };
            if (conf.turn.activePlayers) {
                ctx = SetActivePlayers(ctx, conf.turn.activePlayers);
            }
        }
        else {
            // This is only called at the beginning of the phase
            // when there is no currentPlayer yet.
            ctx = InitTurnOrderState(G, ctx, conf.turn);
        }
        const turn = ctx.turn + 1;
        ctx = { ...ctx, turn, numMoves: 0, _prevActivePlayers: [] };
        G = conf.turn.wrapped.onBegin({ ...state, G, ctx });
        const _undo = [{ G, ctx }];
        return { ...state, G, ctx, _undo, _redo: [] };
    }
    ////////////
    // Update //
    ////////////
    function UpdatePhase(state, { arg, next, phase }) {
        const conf = GetPhase({ phase });
        let { ctx } = state;
        if (arg && arg.next) {
            if (arg.next in phaseMap) {
                ctx = { ...ctx, phase: arg.next };
            }
            else {
                error('invalid phase: ' + arg.next);
                return state;
            }
        }
        else if (conf.next !== undefined) {
            ctx = { ...ctx, phase: conf.next };
        }
        else {
            ctx = { ...ctx, phase: null };
        }
        state = { ...state, ctx };
        // Start the new phase.
        next.push({ fn: StartPhase });
        return state;
    }
    function UpdateTurn(state, { arg, currentPlayer, next }) {
        let { G, ctx } = state;
        const conf = GetPhase(ctx);
        // Update turn order state.
        const { endPhase, ctx: newCtx } = UpdateTurnOrderState(G, { ...ctx, currentPlayer }, conf.turn, arg);
        ctx = newCtx;
        state = { ...state, G, ctx };
        if (endPhase) {
            next.push({ fn: EndPhase, turn: ctx.turn, phase: ctx.phase });
        }
        else {
            next.push({ fn: StartTurn, currentPlayer: ctx.currentPlayer });
        }
        return state;
    }
    function UpdateStage(state, { arg, playerID }) {
        if (typeof arg === 'string') {
            arg = { stage: arg };
        }
        let { ctx } = state;
        let { activePlayers, _activePlayersMoveLimit, _activePlayersNumMoves, } = ctx;
        if (arg.stage) {
            if (activePlayers === null) {
                activePlayers = {};
            }
            activePlayers[playerID] = arg.stage;
            _activePlayersNumMoves[playerID] = 0;
            if (arg.moveLimit) {
                if (_activePlayersMoveLimit === null) {
                    _activePlayersMoveLimit = {};
                }
                _activePlayersMoveLimit[playerID] = arg.moveLimit;
            }
        }
        ctx = {
            ...ctx,
            activePlayers,
            _activePlayersMoveLimit,
            _activePlayersNumMoves,
        };
        return { ...state, ctx };
    }
    ///////////////
    // ShouldEnd //
    ///////////////
    function ShouldEndGame(state) {
        return wrapped.endIf(state);
    }
    function ShouldEndPhase(state) {
        const conf = GetPhase(state.ctx);
        return conf.wrapped.endIf(state);
    }
    function ShouldEndTurn(state) {
        const conf = GetPhase(state.ctx);
        // End the turn if the required number of moves has been made.
        const currentPlayerMoves = state.ctx.numMoves || 0;
        if (conf.turn.moveLimit && currentPlayerMoves >= conf.turn.moveLimit) {
            return true;
        }
        return conf.turn.wrapped.endIf(state);
    }
    /////////
    // End //
    /////////
    function EndGame(state, { arg, phase }) {
        state = EndPhase(state, { phase });
        if (arg === undefined) {
            arg = true;
        }
        state = { ...state, ctx: { ...state.ctx, gameover: arg } };
        // Run game end hook.
        const G = wrapped.onEnd(state);
        return { ...state, G };
    }
    function EndPhase(state, { arg, next, turn, automatic }) {
        // End the turn first.
        state = EndTurn(state, { turn, force: true });
        let G = state.G;
        let ctx = state.ctx;
        if (next) {
            next.push({ fn: UpdatePhase, arg, phase: ctx.phase });
        }
        // If we aren't in a phase, there is nothing else to do.
        if (ctx.phase === null) {
            return state;
        }
        // Run any cleanup code for the phase that is about to end.
        const conf = GetPhase(ctx);
        G = conf.wrapped.onEnd(state);
        // Reset the phase.
        ctx = { ...ctx, phase: null };
        // Add log entry.
        const action = gameEvent('endPhase', arg);
        const logEntry = {
            action,
            _stateID: state._stateID,
            turn: state.ctx.turn,
            phase: state.ctx.phase,
        };
        if (automatic) {
            logEntry.automatic = true;
        }
        const deltalog = [...state.deltalog, logEntry];
        return { ...state, G, ctx, deltalog };
    }
    function EndTurn(state, { arg, next, turn, force, automatic, playerID }) {
        // This is not the turn that EndTurn was originally
        // called for. The turn was probably ended some other way.
        if (turn !== state.ctx.turn) {
            return state;
        }
        let { G, ctx } = state;
        const conf = GetPhase(ctx);
        // Prevent ending the turn if moveLimit hasn't been reached.
        const currentPlayerMoves = ctx.numMoves || 0;
        if (!force &&
            conf.turn.moveLimit &&
            currentPlayerMoves < conf.turn.moveLimit) {
            info(`cannot end turn before making ${conf.turn.moveLimit} moves`);
            return state;
        }
        // Run turn-end triggers.
        G = conf.turn.wrapped.onEnd(state);
        if (next) {
            next.push({ fn: UpdateTurn, arg, currentPlayer: ctx.currentPlayer });
        }
        // Reset activePlayers.
        ctx = { ...ctx, activePlayers: null };
        // Remove player from playerOrder
        if (arg && arg.remove) {
            playerID = playerID || ctx.currentPlayer;
            const playOrder = ctx.playOrder.filter(i => i != playerID);
            const playOrderPos = ctx.playOrderPos > playOrder.length - 1 ? 0 : ctx.playOrderPos;
            ctx = { ...ctx, playOrder, playOrderPos };
            if (playOrder.length === 0) {
                next.push({ fn: EndPhase, turn: ctx.turn, phase: ctx.phase });
                return state;
            }
        }
        // Add log entry.
        const action = gameEvent('endTurn', arg);
        const logEntry = {
            action,
            _stateID: state._stateID,
            turn: state.ctx.turn,
            phase: state.ctx.phase,
        };
        if (automatic) {
            logEntry.automatic = true;
        }
        const deltalog = [...(state.deltalog || []), logEntry];
        return { ...state, G, ctx, deltalog, _undo: [], _redo: [] };
    }
    function EndStage(state, { arg, next, automatic, playerID }) {
        playerID = playerID || state.ctx.currentPlayer;
        let { ctx } = state;
        let { activePlayers, _activePlayersMoveLimit } = ctx;
        const playerInStage = activePlayers !== null && playerID in activePlayers;
        if (!arg && playerInStage) {
            const conf = GetPhase(ctx);
            const stage = conf.turn.stages[activePlayers[playerID]];
            if (stage && stage.next)
                arg = stage.next;
        }
        if (next && arg) {
            next.push({ fn: UpdateStage, arg, playerID });
        }
        // If player isnt in a stage, there is nothing else to do.
        if (!playerInStage)
            return state;
        // Remove player from activePlayers.
        activePlayers = Object.keys(activePlayers)
            .filter(id => id !== playerID)
            .reduce((obj, key) => {
            obj[key] = activePlayers[key];
            return obj;
        }, {});
        if (_activePlayersMoveLimit) {
            // Remove player from _activePlayersMoveLimit.
            _activePlayersMoveLimit = Object.keys(_activePlayersMoveLimit)
                .filter(id => id !== playerID)
                .reduce((obj, key) => {
                obj[key] = _activePlayersMoveLimit[key];
                return obj;
            }, {});
        }
        ctx = UpdateActivePlayersOnceEmpty({
            ...ctx,
            activePlayers,
            _activePlayersMoveLimit,
        });
        // Add log entry.
        const action = gameEvent('endStage', arg);
        const logEntry = {
            action,
            _stateID: state._stateID,
            turn: state.ctx.turn,
            phase: state.ctx.phase,
        };
        if (automatic) {
            logEntry.automatic = true;
        }
        const deltalog = [...(state.deltalog || []), logEntry];
        return { ...state, ctx, deltalog };
    }
    /**
     * Retrieves the relevant move that can be played by playerID.
     *
     * If ctx.activePlayers is set (i.e. one or more players are in some stage),
     * then it attempts to find the move inside the stages config for
     * that turn. If the stage for a player is '', then the player is
     * allowed to make a move (as determined by the phase config), but
     * isn't restricted to a particular set as defined in the stage config.
     *
     * If not, it then looks for the move inside the phase.
     *
     * If it doesn't find the move there, it looks at the global move definition.
     *
     * @param {object} ctx
     * @param {string} name
     * @param {string} playerID
     */
    function GetMove(ctx, name, playerID) {
        const conf = GetPhase(ctx);
        const stages = conf.turn.stages;
        const { activePlayers } = ctx;
        if (activePlayers &&
            activePlayers[playerID] !== undefined &&
            activePlayers[playerID] !== Stage.NULL &&
            stages[activePlayers[playerID]] !== undefined &&
            stages[activePlayers[playerID]].moves !== undefined) {
            // Check if moves are defined for the player's stage.
            const stage = stages[activePlayers[playerID]];
            const moves = stage.moves;
            if (name in moves) {
                return moves[name];
            }
        }
        else if (conf.moves) {
            // Check if moves are defined for the current phase.
            if (name in conf.moves) {
                return conf.moves[name];
            }
        }
        else if (name in moves) {
            // Check for the move globally.
            return moves[name];
        }
        return null;
    }
    function ProcessMove(state, action) {
        let conf = GetPhase(state.ctx);
        let { ctx } = state;
        let { _activePlayersNumMoves } = ctx;
        const { playerID } = action;
        if (ctx.activePlayers)
            _activePlayersNumMoves[playerID]++;
        let numMoves = state.ctx.numMoves;
        if (playerID == state.ctx.currentPlayer) {
            numMoves++;
        }
        state = {
            ...state,
            ctx: {
                ...ctx,
                numMoves,
                _activePlayersNumMoves,
            },
        };
        if (ctx._activePlayersMoveLimit &&
            _activePlayersNumMoves[playerID] >= ctx._activePlayersMoveLimit[playerID]) {
            state = EndStage(state, { playerID, automatic: true });
        }
        const G = conf.turn.wrapped.onMove(state);
        state = { ...state, G };
        // Update undo / redo state.
        const undo = state._undo || [];
        const moveType = action.type;
        state = {
            ...state,
            _undo: [...undo, { G: state.G, ctx: state.ctx, moveType }],
            _redo: [],
        };
        let events = [{ fn: OnMove }];
        return Process(state, events);
    }
    function SetStageEvent(state, playerID, arg) {
        return Process(state, [{ fn: EndStage, arg, playerID }]);
    }
    function EndStageEvent(state, playerID) {
        return Process(state, [{ fn: EndStage, playerID }]);
    }
    function SetPhaseEvent(state, _playerID, newPhase) {
        return Process(state, [
            {
                fn: EndPhase,
                phase: state.ctx.phase,
                turn: state.ctx.turn,
                arg: { next: newPhase },
            },
        ]);
    }
    function EndPhaseEvent(state) {
        return Process(state, [
            { fn: EndPhase, phase: state.ctx.phase, turn: state.ctx.turn },
        ]);
    }
    function EndTurnEvent(state, _playerID, arg) {
        return Process(state, [
            { fn: EndTurn, turn: state.ctx.turn, phase: state.ctx.phase, arg },
        ]);
    }
    function PassEvent(state, _playerID, arg) {
        return Process(state, [
            {
                fn: EndTurn,
                turn: state.ctx.turn,
                phase: state.ctx.phase,
                force: true,
                arg,
            },
        ]);
    }
    function EndGameEvent(state, _playerID, arg) {
        return Process(state, [
            { fn: EndGame, turn: state.ctx.turn, phase: state.ctx.phase, arg },
        ]);
    }
    const eventHandlers = {
        endStage: EndStageEvent,
        setStage: SetStageEvent,
        endTurn: EndTurnEvent,
        pass: PassEvent,
        endPhase: EndPhaseEvent,
        setPhase: SetPhaseEvent,
        endGame: EndGameEvent,
        setActivePlayers: SetActivePlayersEvent,
    };
    let enabledEventNames = [];
    if (events.endTurn !== false) {
        enabledEventNames.push('endTurn');
    }
    if (events.pass !== false) {
        enabledEventNames.push('pass');
    }
    if (events.endPhase !== false) {
        enabledEventNames.push('endPhase');
    }
    if (events.setPhase !== false) {
        enabledEventNames.push('setPhase');
    }
    if (events.endGame !== false) {
        enabledEventNames.push('endGame');
    }
    if (events.setActivePlayers !== false) {
        enabledEventNames.push('setActivePlayers');
    }
    if (events.endStage !== false) {
        enabledEventNames.push('endStage');
    }
    if (events.setStage !== false) {
        enabledEventNames.push('setStage');
    }
    function ProcessEvent(state, action) {
        const { type, playerID, args } = action.payload;
        if (eventHandlers.hasOwnProperty(type)) {
            const eventArgs = [state, playerID].concat(args);
            return eventHandlers[type].apply({}, eventArgs);
        }
        return state;
    }
    function IsPlayerActive(_G, ctx, playerID) {
        if (ctx.activePlayers) {
            return playerID in ctx.activePlayers;
        }
        return ctx.currentPlayer === playerID;
    }
    return {
        ctx: (numPlayers) => ({
            numPlayers,
            turn: 0,
            currentPlayer: '0',
            playOrder: [...new Array(numPlayers)].map((_d, i) => i + ''),
            playOrderPos: 0,
            phase: startingPhase,
            activePlayers: null,
        }),
        init: (state) => {
            return Process(state, [{ fn: StartGame }]);
        },
        isPlayerActive: IsPlayerActive,
        eventHandlers,
        eventNames: Object.keys(eventHandlers),
        enabledEventNames,
        moveMap,
        moveNames: [...moveNames.values()],
        processMove: ProcessMove,
        processEvent: ProcessEvent,
        getMove: GetMove,
    };
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
function IsProcessed(game) {
    return game.processMove !== undefined;
}
/**
 * Game
 *
 * Helper to generate the game move reducer. The returned
 * reducer has the following signature:
 *
 * (G, action, ctx) => {}
 *
 * You can roll your own if you like, or use any Redux
 * addon to generate such a reducer.
 *
 * The convention used in this framework is to
 * have action.type contain the name of the move, and
 * action.args contain any additional arguments as an
 * Array.
 */
function Game(game) {
    // The Game() function has already been called on this
    // config object, so just pass it through.
    if (IsProcessed(game)) {
        return game;
    }
    if (game.name === undefined)
        game.name = 'default';
    if (game.setup === undefined)
        game.setup = () => ({});
    if (game.moves === undefined)
        game.moves = {};
    if (game.playerView === undefined)
        game.playerView = G => G;
    if (game.plugins === undefined)
        game.plugins = [];
    game.plugins.forEach(plugin => {
        if (plugin.name === undefined) {
            throw new Error('Plugin missing name attribute');
        }
        if (plugin.name.includes(' ')) {
            throw new Error(plugin.name + ': Plugin name must not include spaces');
        }
    });
    if (game.name.includes(' ')) {
        throw new Error(game.name + ': Game name must not include spaces');
    }
    const flow = Flow(game);
    return {
        ...game,
        flow,
        moveNames: flow.moveNames,
        pluginNames: game.plugins.map(p => p.name),
        processMove: (state, action) => {
            let moveFn = flow.getMove(state.ctx, action.type, action.playerID);
            if (IsLongFormMove(moveFn)) {
                moveFn = moveFn.move;
            }
            if (moveFn instanceof Function) {
                const fn = FnWrap(moveFn, game.plugins);
                const ctxWithAPI = {
                    ...EnhanceCtx(state),
                    playerID: action.playerID,
                };
                let args = [state.G, ctxWithAPI];
                if (action.args !== undefined) {
                    args = args.concat(action.args);
                }
                return fn(...args);
            }
            error(`invalid move object: ${action.type}`);
            return state.G;
        },
    };
}
function IsLongFormMove(move) {
    return move instanceof Object && move.move !== undefined;
}

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
/**
 * Returns true if a move can be undone.
 */
const CanUndoMove = (G, ctx, move) => {
    function HasUndoable(move) {
        return move.undoable !== undefined;
    }
    function IsFunction(undoable) {
        return undoable instanceof Function;
    }
    if (!HasUndoable(move)) {
        return true;
    }
    if (IsFunction(move.undoable)) {
        return move.undoable(G, ctx);
    }
    return move.undoable;
};
/**
 * Moves can return this when they want to indicate
 * that the combination of arguments is illegal and
 * the move ought to be discarded.
 */
const INVALID_MOVE = 'INVALID_MOVE';
/**
 * CreateGameReducer
 *
 * Creates the main game state reducer.
 */
function CreateGameReducer({ game, isClient, }) {
    game = Game(game);
    /**
     * GameReducer
     *
     * Redux reducer that maintains the overall game state.
     * @param {object} state - The state before the action.
     * @param {object} action - A Redux action.
     */
    return (state = null, action) => {
        switch (action.type) {
            case GAME_EVENT: {
                state = { ...state, deltalog: [] };
                // Process game events only on the server.
                // These events like `endTurn` typically
                // contain code that may rely on secret state
                // and cannot be computed on the client.
                if (isClient) {
                    return state;
                }
                // Disallow events once the game is over.
                if (state.ctx.gameover !== undefined) {
                    error(`cannot call event after game end`);
                    return state;
                }
                // Ignore the event if the player isn't active.
                if (action.payload.playerID !== null &&
                    action.payload.playerID !== undefined &&
                    !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {
                    error(`disallowed event: ${action.payload.type}`);
                    return state;
                }
                // Execute plugins.
                state = Enhance(state, { game, isClient: false });
                // Process event.
                let newState = game.flow.processEvent(state, action);
                // Execute plugins.
                newState = Flush(newState, { game, isClient: false });
                return { ...newState, _stateID: state._stateID + 1 };
            }
            case MAKE_MOVE: {
                state = { ...state, deltalog: [] };
                // Check whether the move is allowed at this time.
                const move = game.flow.getMove(state.ctx, action.payload.type, action.payload.playerID || state.ctx.currentPlayer);
                if (move === null) {
                    error(`disallowed move: ${action.payload.type}`);
                    return state;
                }
                // Don't run move on client if move says so.
                if (isClient && move.client === false) {
                    return state;
                }
                // Disallow moves once the game is over.
                if (state.ctx.gameover !== undefined) {
                    error(`cannot make move after game end`);
                    return state;
                }
                // Ignore the move if the player isn't active.
                if (action.payload.playerID !== null &&
                    action.payload.playerID !== undefined &&
                    !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {
                    error(`disallowed move: ${action.payload.type}`);
                    return state;
                }
                // Execute plugins.
                state = Enhance(state, {
                    game,
                    isClient,
                });
                // Process the move.
                let G = game.processMove(state, action.payload);
                // The game declared the move as invalid.
                if (G === INVALID_MOVE) {
                    error(`invalid move: ${action.payload.type} args: ${action.payload.args}`);
                    return state;
                }
                // Create a log entry for this move.
                let logEntry = {
                    action,
                    _stateID: state._stateID,
                    turn: state.ctx.turn,
                    phase: state.ctx.phase,
                };
                if (move.redact === true) {
                    logEntry.redact = true;
                }
                const newState = {
                    ...state,
                    G,
                    deltalog: [logEntry],
                    _stateID: state._stateID + 1,
                };
                // Some plugin indicated that it is not suitable to be
                // materialized on the client (and must wait for the server
                // response instead).
                if (isClient && NoClient(newState, { game })) {
                    return state;
                }
                state = newState;
                // If we're on the client, just process the move
                // and no triggers in multiplayer mode.
                // These will be processed on the server, which
                // will send back a state update.
                if (isClient) {
                    state = Flush(state, {
                        game,
                        isClient: true,
                    });
                    return state;
                }
                // Allow the flow reducer to process any triggers that happen after moves.
                state = game.flow.processMove(state, action.payload);
                state = Flush(state, { game });
                return state;
            }
            case RESET:
            case UPDATE:
            case SYNC: {
                return action.state;
            }
            case UNDO: {
                const { _undo, _redo } = state;
                if (_undo.length < 2) {
                    return state;
                }
                const last = _undo[_undo.length - 1];
                const restore = _undo[_undo.length - 2];
                // Only allow undoable moves to be undone.
                const lastMove = game.flow.getMove(state.ctx, last.moveType, state.ctx.currentPlayer);
                if (!CanUndoMove(state.G, state.ctx, lastMove)) {
                    return state;
                }
                return {
                    ...state,
                    G: restore.G,
                    ctx: restore.ctx,
                    _undo: _undo.slice(0, _undo.length - 1),
                    _redo: [last, ..._redo],
                };
            }
            case REDO: {
                const { _undo, _redo } = state;
                if (_redo.length == 0) {
                    return state;
                }
                const first = _redo[0];
                return {
                    ...state,
                    G: first.G,
                    ctx: first.ctx,
                    _undo: [..._undo, first],
                    _redo: _redo.slice(1),
                };
            }
            case PLUGIN: {
                return ProcessAction(state, action, { game });
            }
            default: {
                return state;
            }
        }
    };
}




/***/ }),

/***/ "./node_modules/immer/dist/immer.module.js":
/*!*************************************************!*\
  !*** ./node_modules/immer/dist/immer.module.js ***!
  \*************************************************/
/*! exports provided: produce, setAutoFreeze, setUseProxies, applyPatches, Immer, original, isDraft, isDraftable, nothing, immerable, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "produce", function() { return produce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAutoFreeze", function() { return setAutoFreeze; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setUseProxies", function() { return setUseProxies; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPatches", function() { return applyPatches$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Immer", function() { return Immer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "original", function() { return original; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraft", function() { return isDraft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraftable", function() { return isDraftable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nothing", function() { return NOTHING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "immerable", function() { return DRAFTABLE; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var NOTHING = typeof Symbol !== "undefined" ? Symbol("immer-nothing") : defineProperty({}, "immer-nothing", true);

var DRAFTABLE = typeof Symbol !== "undefined" ? Symbol("immer-draftable") : "__$immer_draftable";

var DRAFT_STATE = typeof Symbol !== "undefined" ? Symbol("immer-state") : "__$immer_state";

function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
}

function isDraftable(value) {
    if (!value || (typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object") return false;
    if (Array.isArray(value)) return true;
    var proto = Object.getPrototypeOf(value);
    if (!proto || proto === Object.prototype) return true;
    return !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE];
}

function original(value) {
    if (value && value[DRAFT_STATE]) {
        return value[DRAFT_STATE].base;
    }
    // otherwise return undefined
}

var assign = Object.assign || function assign(target, value) {
    for (var key in value) {
        if (has(value, key)) {
            target[key] = value[key];
        }
    }
    return target;
};

var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) {
    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : Object.getOwnPropertyNames;

function shallowCopy(base) {
    var invokeGetters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (Array.isArray(base)) return base.slice();
    var clone = Object.create(Object.getPrototypeOf(base));
    ownKeys(base).forEach(function (key) {
        if (key === DRAFT_STATE) {
            return; // Never copy over draft state.
        }
        var desc = Object.getOwnPropertyDescriptor(base, key);
        if (desc.get) {
            if (!invokeGetters) {
                throw new Error("Immer drafts cannot have computed properties");
            }
            desc.value = desc.get.call(base);
        }
        if (desc.enumerable) {
            clone[key] = desc.value;
        } else {
            Object.defineProperty(clone, key, {
                value: desc.value,
                writable: true,
                configurable: true
            });
        }
    });
    return clone;
}

function each(value, cb) {
    if (Array.isArray(value)) {
        for (var i = 0; i < value.length; i++) {
            cb(i, value[i], value);
        }
    } else {
        ownKeys(value).forEach(function (key) {
            return cb(key, value[key], value);
        });
    }
}

function isEnumerable(base, prop) {
    return Object.getOwnPropertyDescriptor(base, prop).enumerable;
}

function has(thing, prop) {
    return Object.prototype.hasOwnProperty.call(thing, prop);
}

function is(x, y) {
    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}

// @ts-check

var descriptors = {};

// For nested produce calls:
var scopes = [];
var currentScope = function currentScope() {
    return scopes[scopes.length - 1];
};

function willFinalize(result, baseDraft, needPatches) {
    var scope = currentScope();
    scope.forEach(function (state) {
        return state.finalizing = true;
    });
    if (result === undefined || result === baseDraft) {
        if (needPatches) markChangesRecursively(baseDraft);
        // This is faster when we don't care about which attributes changed.
        markChangesSweep(scope);
    }
}

function createDraft(base, parent) {
    var isArray = Array.isArray(base);
    var draft = clonePotentialDraft(base);
    each(draft, function (prop) {
        proxyProperty(draft, prop, isArray || isEnumerable(base, prop));
    });

    // See "proxy.js" for property documentation.
    var state = {
        scope: parent ? parent.scope : currentScope(),
        modified: false,
        finalizing: false, // es5 only
        finalized: false,
        assigned: {},
        parent: parent,
        base: base,
        draft: draft,
        copy: null,
        revoke: revoke,
        revoked: false // es5 only
    };

    createHiddenProperty(draft, DRAFT_STATE, state);
    state.scope.push(state);
    return draft;
}

function revoke() {
    this.revoked = true;
}

function source(state) {
    return state.copy || state.base;
}

function _get(state, prop) {
    assertUnrevoked(state);
    var value = source(state)[prop];
    // Drafts are only created for proxyable values that exist in the base state.
    if (!state.finalizing && value === state.base[prop] && isDraftable(value)) {
        prepareCopy(state);
        return state.copy[prop] = createDraft(value, state);
    }
    return value;
}

function _set(state, prop, value) {
    assertUnrevoked(state);
    state.assigned[prop] = true;
    if (!state.modified) {
        if (is(source(state)[prop], value)) return;
        markChanged(state);
        prepareCopy(state);
    }
    state.copy[prop] = value;
}

function markChanged(state) {
    if (!state.modified) {
        state.modified = true;
        if (state.parent) markChanged(state.parent);
    }
}

function prepareCopy(state) {
    if (!state.copy) state.copy = clonePotentialDraft(state.base);
}

function clonePotentialDraft(base) {
    var state = base && base[DRAFT_STATE];
    if (state) {
        state.finalizing = true;
        var draft = shallowCopy(state.draft, true);
        state.finalizing = false;
        return draft;
    }
    return shallowCopy(base);
}

function proxyProperty(draft, prop, enumerable) {
    var desc = descriptors[prop];
    if (desc) {
        desc.enumerable = enumerable;
    } else {
        descriptors[prop] = desc = {
            configurable: true,
            enumerable: enumerable,
            get: function get$$1() {
                return _get(this[DRAFT_STATE], prop);
            },
            set: function set$$1(value) {
                _set(this[DRAFT_STATE], prop, value);
            }
        };
    }
    Object.defineProperty(draft, prop, desc);
}

function assertUnrevoked(state) {
    if (state.revoked === true) throw new Error("Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + JSON.stringify(source(state)));
}

// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.
function markChangesSweep(scope) {
    // The natural order of drafts in the `scope` array is based on when they
    // were accessed. By processing drafts in reverse natural order, we have a
    // better chance of processing leaf nodes first. When a leaf node is known to
    // have changed, we can avoid any traversal of its ancestor nodes.
    for (var i = scope.length - 1; i >= 0; i--) {
        var state = scope[i];
        if (state.modified === false) {
            if (Array.isArray(state.base)) {
                if (hasArrayChanges(state)) markChanged(state);
            } else if (hasObjectChanges(state)) markChanged(state);
        }
    }
}

function markChangesRecursively(object) {
    if (!object || (typeof object === "undefined" ? "undefined" : _typeof(object)) !== "object") return;
    var state = object[DRAFT_STATE];
    if (!state) return;
    var base = state.base,
        draft = state.draft,
        assigned = state.assigned;

    if (!Array.isArray(object)) {
        // Look for added keys.
        Object.keys(draft).forEach(function (key) {
            // The `undefined` check is a fast path for pre-existing keys.
            if (base[key] === undefined && !has(base, key)) {
                assigned[key] = true;
                markChanged(state);
            } else if (!assigned[key]) {
                // Only untouched properties trigger recursion.
                markChangesRecursively(draft[key]);
            }
        });
        // Look for removed keys.
        Object.keys(base).forEach(function (key) {
            // The `undefined` check is a fast path for pre-existing keys.
            if (draft[key] === undefined && !has(draft, key)) {
                assigned[key] = false;
                markChanged(state);
            }
        });
    } else if (hasArrayChanges(state)) {
        markChanged(state);
        assigned.length = true;
        if (draft.length < base.length) {
            for (var i = draft.length; i < base.length; i++) {
                assigned[i] = false;
            }
        } else {
            for (var _i = base.length; _i < draft.length; _i++) {
                assigned[_i] = true;
            }
        }
        for (var _i2 = 0; _i2 < draft.length; _i2++) {
            // Only untouched indices trigger recursion.
            if (assigned[_i2] === undefined) markChangesRecursively(draft[_i2]);
        }
    }
}

function hasObjectChanges(state) {
    var base = state.base,
        draft = state.draft;

    // Search for added keys. Start at the back, because non-numeric keys
    // are ordered by time of definition on the object.

    var keys = Object.keys(draft);
    for (var i = keys.length - 1; i >= 0; i--) {
        // The `undefined` check is a fast path for pre-existing keys.
        if (base[keys[i]] === undefined && !has(base, keys[i])) {
            return true;
        }
    }

    // Since no keys have been added, we can compare lengths to know if an
    // object has been deleted.
    return keys.length !== Object.keys(base).length;
}

function hasArrayChanges(state) {
    var draft = state.draft;

    if (draft.length !== state.base.length) return true;
    // See #116
    // If we first shorten the length, our array interceptors will be removed.
    // If after that new items are added, result in the same original length,
    // those last items will have no intercepting property.
    // So if there is no own descriptor on the last position, we know that items were removed and added
    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
    // the last one
    var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1);
    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)
    if (descriptor && !descriptor.get) return true;
    // For all other cases, we don't have to compare, as they would have been picked up by the index setters
    return false;
}

function createHiddenProperty(target, prop, value) {
    Object.defineProperty(target, prop, {
        value: value,
        enumerable: false,
        writable: true
    });
}



var legacyProxy = Object.freeze({
	scopes: scopes,
	currentScope: currentScope,
	willFinalize: willFinalize,
	createDraft: createDraft
});

// @ts-check

// For nested produce calls:
var scopes$1 = [];
var currentScope$1 = function currentScope() {
    return scopes$1[scopes$1.length - 1];
};

// Do nothing before being finalized.
function willFinalize$1() {}

function createDraft$1(base, parent) {
    var state = {
        // Track which produce call this is associated with.
        scope: parent ? parent.scope : currentScope$1(),
        // True for both shallow and deep changes.
        modified: false,
        // Used during finalization.
        finalized: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned: {},
        // The parent draft state.
        parent: parent,
        // The base state.
        base: base,
        // The base proxy.
        draft: null,
        // Any property proxies.
        drafts: {},
        // The base copy with any updated values.
        copy: null,
        // Called by the `produce` function.
        revoke: null
    };

    var _ref = Array.isArray(base) ? Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps),
        revoke = _ref.revoke,
        proxy = _ref.proxy;

    state.draft = proxy;
    state.revoke = revoke;

    state.scope.push(state);
    return proxy;
}

var objectTraps = {
    get: get$1,
    has: function has$$1(target, prop) {
        return prop in source$1(target);
    },
    ownKeys: function ownKeys$$1(target) {
        return Reflect.ownKeys(source$1(target));
    },

    set: set$1,
    deleteProperty: deleteProperty,
    getOwnPropertyDescriptor: getOwnPropertyDescriptor,
    defineProperty: function defineProperty() {
        throw new Error("Object.defineProperty() cannot be used on an Immer draft"); // prettier-ignore
    },
    getPrototypeOf: function getPrototypeOf(target) {
        return Object.getPrototypeOf(target.base);
    },
    setPrototypeOf: function setPrototypeOf() {
        throw new Error("Object.setPrototypeOf() cannot be used on an Immer draft"); // prettier-ignore
    }
};

var arrayTraps = {};
each(objectTraps, function (key, fn) {
    arrayTraps[key] = function () {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
    };
});
arrayTraps.deleteProperty = function (state, prop) {
    if (isNaN(parseInt(prop))) {
        throw new Error("Immer only supports deleting array indices"); // prettier-ignore
    }
    return objectTraps.deleteProperty.call(this, state[0], prop);
};
arrayTraps.set = function (state, prop, value) {
    if (prop !== "length" && isNaN(parseInt(prop))) {
        throw new Error("Immer only supports setting array indices and the 'length' property"); // prettier-ignore
    }
    return objectTraps.set.call(this, state[0], prop, value);
};

function source$1(state) {
    return state.copy || state.base;
}

function get$1(state, prop) {
    if (prop === DRAFT_STATE) return state;
    var drafts = state.drafts;

    // Check for existing draft in unmodified state.

    if (!state.modified && has(drafts, prop)) {
        return drafts[prop];
    }

    var value = source$1(state)[prop];
    if (state.finalized || !isDraftable(value)) return value;

    // Check for existing draft in modified state.
    if (state.modified) {
        // Assigned values are never drafted. This catches any drafts we created, too.
        if (value !== state.base[prop]) return value;
        // Store drafts on the copy (when one exists).
        drafts = state.copy;
    }

    return drafts[prop] = createDraft$1(value, state);
}

function set$1(state, prop, value) {
    if (!state.modified) {
        // Optimize based on value's truthiness. Truthy values are guaranteed to
        // never be undefined, so we can avoid the `in` operator. Lastly, truthy
        // values may be drafts, but falsy values are never drafts.
        var isUnchanged = value ? is(state.base[prop], value) || value === state.drafts[prop] : is(state.base[prop], value) && prop in state.base;
        if (isUnchanged) return true;
        markChanged$1(state);
    }
    state.assigned[prop] = true;
    state.copy[prop] = value;
    return true;
}

function deleteProperty(state, prop) {
    // The `undefined` check is a fast path for pre-existing keys.
    if (state.base[prop] !== undefined || prop in state.base) {
        state.assigned[prop] = false;
        markChanged$1(state);
    }
    if (state.copy) delete state.copy[prop];
    return true;
}

function getOwnPropertyDescriptor(state, prop) {
    var owner = source$1(state);
    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (desc) {
        desc.writable = true;
        desc.configurable = !Array.isArray(owner) || prop !== "length";
    }
    return desc;
}

function markChanged$1(state) {
    if (!state.modified) {
        state.modified = true;
        state.copy = assign(shallowCopy(state.base), state.drafts);
        state.drafts = null;
        if (state.parent) markChanged$1(state.parent);
    }
}

var modernProxy = Object.freeze({
	scopes: scopes$1,
	currentScope: currentScope$1,
	willFinalize: willFinalize$1,
	createDraft: createDraft$1
});

function generatePatches(state, basePath, patches, inversePatches) {
    Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);
}

function generateArrayPatches(state, basePath, patches, inversePatches) {
    var base = state.base,
        copy = state.copy,
        assigned = state.assigned;

    var minLength = Math.min(base.length, copy.length);

    // Look for replaced indices.
    for (var i = 0; i < minLength; i++) {
        if (assigned[i] && base[i] !== copy[i]) {
            var path = basePath.concat(i);
            patches.push({ op: "replace", path: path, value: copy[i] });
            inversePatches.push({ op: "replace", path: path, value: base[i] });
        }
    }

    // Did the array expand?
    if (minLength < copy.length) {
        for (var _i = minLength; _i < copy.length; _i++) {
            patches.push({
                op: "add",
                path: basePath.concat(_i),
                value: copy[_i]
            });
        }
        inversePatches.push({
            op: "replace",
            path: basePath.concat("length"),
            value: base.length
        });
    }

    // ...or did it shrink?
    else if (minLength < base.length) {
            patches.push({
                op: "replace",
                path: basePath.concat("length"),
                value: copy.length
            });
            for (var _i2 = minLength; _i2 < base.length; _i2++) {
                inversePatches.push({
                    op: "add",
                    path: basePath.concat(_i2),
                    value: base[_i2]
                });
            }
        }
}

function generateObjectPatches(state, basePath, patches, inversePatches) {
    var base = state.base,
        copy = state.copy;

    each(state.assigned, function (key, assignedValue) {
        var origValue = base[key];
        var value = copy[key];
        var op = !assignedValue ? "remove" : key in base ? "replace" : "add";
        if (origValue === value && op === "replace") return;
        var path = basePath.concat(key);
        patches.push(op === "remove" ? { op: op, path: path } : { op: op, path: path, value: value });
        inversePatches.push(op === "add" ? { op: "remove", path: path } : op === "remove" ? { op: "add", path: path, value: origValue } : { op: "replace", path: path, value: origValue });
    });
}

function applyPatches(draft, patches) {
    for (var i = 0; i < patches.length; i++) {
        var patch = patches[i];
        var path = patch.path;

        if (path.length === 0 && patch.op === "replace") {
            draft = patch.value;
        } else {
            var base = draft;
            for (var _i3 = 0; _i3 < path.length - 1; _i3++) {
                base = base[path[_i3]];
                if (!base || (typeof base === "undefined" ? "undefined" : _typeof(base)) !== "object") throw new Error("Cannot apply patch, path doesn't resolve: " + path.join("/")); // prettier-ignore
            }
            var key = path[path.length - 1];
            switch (patch.op) {
                case "replace":
                case "add":
                    // TODO: add support is not extensive, it does not support insertion or `-` atm!
                    base[key] = patch.value;
                    break;
                case "remove":
                    if (Array.isArray(base)) {
                        if (key !== base.length - 1) throw new Error("Only the last index of an array can be removed, index: " + key + ", length: " + base.length); // prettier-ignore
                        base.length -= 1;
                    } else {
                        delete base[key];
                    }
                    break;
                default:
                    throw new Error("Unsupported patch operation: " + patch.op);
            }
        }
    }
    return draft;
}

function verifyMinified() {}

var configDefaults = {
    useProxies: typeof Proxy !== "undefined" && typeof Reflect !== "undefined",
    autoFreeze: typeof process !== "undefined" ? "development" !== "production" : verifyMinified.name === "verifyMinified",
    onAssign: null,
    onDelete: null,
    onCopy: null
};

var Immer = function () {
    function Immer(config) {
        classCallCheck(this, Immer);

        assign(this, configDefaults, config);
        this.setUseProxies(this.useProxies);
        this.produce = this.produce.bind(this);
    }

    createClass(Immer, [{
        key: "produce",
        value: function produce(base, recipe, patchListener) {
            var _this = this;

            // curried invocation
            if (typeof base === "function" && typeof recipe !== "function") {
                var defaultBase = recipe;
                recipe = base;

                // prettier-ignore
                return function () {
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }

                    var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultBase;
                    return _this.produce(base, function (draft) {
                        var _recipe;

                        return (_recipe = recipe).call.apply(_recipe, [draft, draft].concat(args));
                    });
                };
            }

            // prettier-ignore
            {
                if (typeof recipe !== "function") throw new Error("if first argument is not a function, the second argument to produce should be a function");
                if (patchListener !== undefined && typeof patchListener !== "function") throw new Error("the third argument of a producer should not be set or a function");
            }

            var result = void 0;
            // Only create proxies for plain objects/arrays.
            if (!isDraftable(base)) {
                result = recipe(base);
                if (result === undefined) return base;
            }
            // The given value must be proxied.
            else {
                    this.scopes.push([]);
                    var baseDraft = this.createDraft(base);
                    try {
                        result = recipe.call(baseDraft, baseDraft);
                        this.willFinalize(result, baseDraft, !!patchListener);

                        // Never generate patches when no listener exists.
                        var patches = patchListener && [],
                            inversePatches = patchListener && [];

                        // Finalize the modified draft...
                        if (result === undefined || result === baseDraft) {
                            result = this.finalize(baseDraft, [], patches, inversePatches);
                        }
                        // ...or use a replacement value.
                        else {
                                // Users must never modify the draft _and_ return something else.
                                if (baseDraft[DRAFT_STATE].modified) throw new Error("An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft."); // prettier-ignore

                                // Finalize the replacement in case it contains (or is) a subset of the draft.
                                if (isDraftable(result)) result = this.finalize(result);

                                if (patchListener) {
                                    patches.push({
                                        op: "replace",
                                        path: [],
                                        value: result
                                    });
                                    inversePatches.push({
                                        op: "replace",
                                        path: [],
                                        value: base
                                    });
                                }
                            }
                    } finally {
                        this.currentScope().forEach(function (state) {
                            return state.revoke();
                        });
                        this.scopes.pop();
                    }
                    patchListener && patchListener(patches, inversePatches);
                }
            // Normalize the result.
            return result === NOTHING ? undefined : result;
        }
    }, {
        key: "setAutoFreeze",
        value: function setAutoFreeze(value) {
            this.autoFreeze = value;
        }
    }, {
        key: "setUseProxies",
        value: function setUseProxies(value) {
            this.useProxies = value;
            assign(this, value ? modernProxy : legacyProxy);
        }
    }, {
        key: "applyPatches",
        value: function applyPatches$$1(base, patches) {
            // Mutate the base state when a draft is passed.
            if (isDraft(base)) {
                return applyPatches(base, patches);
            }
            // Otherwise, produce a copy of the base state.
            return this.produce(base, function (draft) {
                return applyPatches(draft, patches);
            });
        }
        /**
         * @internal
         * Finalize a draft, returning either the unmodified base state or a modified
         * copy of the base state.
         */

    }, {
        key: "finalize",
        value: function finalize(draft, path, patches, inversePatches) {
            var _this2 = this;

            var state = draft[DRAFT_STATE];
            if (!state) {
                if (Object.isFrozen(draft)) return draft;
                return this.finalizeTree(draft);
            }
            // Never finalize drafts owned by an outer scope.
            if (state.scope !== this.currentScope()) {
                return draft;
            }
            if (!state.modified) return state.base;
            if (!state.finalized) {
                state.finalized = true;
                this.finalizeTree(state.draft, path, patches, inversePatches);
                if (this.onDelete) {
                    // The `assigned` object is unreliable with ES5 drafts.
                    if (this.useProxies) {
                        var assigned = state.assigned;

                        for (var prop in assigned) {
                            if (!assigned[prop]) this.onDelete(state, prop);
                        }
                    } else {
                        var base = state.base,
                            copy = state.copy;

                        each(base, function (prop) {
                            if (!has(copy, prop)) _this2.onDelete(state, prop);
                        });
                    }
                }
                if (this.onCopy) this.onCopy(state);

                // Nested producers must never auto-freeze their result,
                // because it may contain drafts from parent producers.
                if (this.autoFreeze && this.scopes.length === 1) {
                    Object.freeze(state.copy);
                }

                if (patches) generatePatches(state, path, patches, inversePatches);
            }
            return state.copy;
        }
        /**
         * @internal
         * Finalize all drafts in the given state tree.
         */

    }, {
        key: "finalizeTree",
        value: function finalizeTree(root, path, patches, inversePatches) {
            var _this3 = this;

            var state = root[DRAFT_STATE];
            if (state) {
                if (!this.useProxies) {
                    state.finalizing = true;
                    state.copy = shallowCopy(state.draft, true);
                    state.finalizing = false;
                }
                root = state.copy;
            }

            var onAssign = this.onAssign;

            var finalizeProperty = function finalizeProperty(prop, value, parent) {
                if (value === parent) {
                    throw Error("Immer forbids circular references");
                }

                // The only possible draft (in the scope of a `finalizeTree` call) is the `root` object.
                var inDraft = !!state && parent === root;

                if (isDraft(value)) {
                    value =
                    // Patches are never generated for assigned properties.
                    patches && inDraft && !state.assigned[prop] ? _this3.finalize(value, path.concat(prop), patches, inversePatches) // prettier-ignore
                    : _this3.finalize(value);

                    // Preserve non-enumerable properties.
                    if (Array.isArray(parent) || isEnumerable(parent, prop)) {
                        parent[prop] = value;
                    } else {
                        Object.defineProperty(parent, prop, { value: value });
                    }

                    // Unchanged drafts are never passed to the `onAssign` hook.
                    if (inDraft && value === state.base[prop]) return;
                }
                // Unchanged draft properties are ignored.
                else if (inDraft && is(value, state.base[prop])) {
                        return;
                    }
                    // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.
                    else if (isDraftable(value) && !Object.isFrozen(value)) {
                            each(value, finalizeProperty);
                        }

                if (inDraft && onAssign) {
                    onAssign(state, prop, value);
                }
            };

            each(root, finalizeProperty);
            return root;
        }
    }]);
    return Immer;
}();

var immer = new Immer();

/**
 * The `produce` function takes a value and a "recipe function" (whose
 * return value often depends on the base state). The recipe function is
 * free to mutate its first argument however it wants. All mutations are
 * only ever applied to a __copy__ of the base state.
 *
 * Pass only a function to create a "curried producer" which relieves you
 * from passing the recipe function every time.
 *
 * Only plain objects and arrays are made mutable. All other objects are
 * considered uncopyable.
 *
 * Note: This function is __bound__ to its `Immer` instance.
 *
 * @param {any} base - the initial state
 * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
 * @param {Function} patchListener - optional function that will be called with all the patches produced here
 * @returns {any} a new state, or the initial state if nothing was modified
 */
var produce = immer.produce;
/**
 * Pass true to automatically freeze all copies created by Immer.
 *
 * By default, auto-freezing is disabled in production.
 */
var setAutoFreeze = immer.setAutoFreeze.bind(immer);

/**
 * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
 * always faster than using ES5 proxies.
 *
 * By default, feature detection is used, so calling this is rarely necessary.
 */
var setUseProxies = immer.setUseProxies.bind(immer);

/**
 * Apply an array of Immer patches to the first argument.
 *
 * This function is a producer, which means copy-on-write is in effect.
 */
var applyPatches$1 = immer.applyPatches.bind(immer);


/* harmony default export */ __webpack_exports__["default"] = (produce);
//# sourceMappingURL=immer.module.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mobile-detect/mobile-detect.js":
/*!*****************************************************!*\
  !*** ./node_modules/mobile-detect/mobile-detect.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// THIS FILE IS GENERATED - DO NOT EDIT!
/*!mobile-detect v1.4.4 2019-09-21*/
/*global module:false, define:false*/
/*jshint latedef:false*/
/*!@license Copyright 2013, Heinrich Goebl, License: MIT, see https://github.com/hgoebl/mobile-detect.js*/
(function (define, undefined) {
define(function () {
    'use strict';

    var impl = {};

    impl.mobileDetectRules = {
    "phones": {
        "iPhone": "\\biPhone\\b|\\biPod\\b",
        "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+|\\b(BBA100|BBB100|BBD100|BBE100|BBF100|STH100)\\b-[0-9]+",
        "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel",
        "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",
        "Dell": "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
        "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052",
        "Samsung": "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F",
        "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)|LM-G710",
        "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",
        "Asus": "Asus.*Galaxy|PadFone.*Mobile",
        "NokiaLumia": "Lumia [0-9]{3,4}",
        "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
        "Palm": "PalmSource|Palm",
        "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
        "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
        "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
        "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
        "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
        "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
        "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
        "Alcatel": "Alcatel",
        "Nintendo": "Nintendo (3DS|Switch)",
        "Amoi": "Amoi",
        "INQ": "INQ",
        "OnePlus": "ONEPLUS",
        "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
    },
    "tablets": {
        "iPad": "iPad|iPad.*Mobile",
        "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
        "GoogleTablet": "Android.*Pixel C",
        "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835|SM-T830|SM-T837V|SM-T720|SM-T510|SM-T387V",
        "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk\/[0-9.]+ like Chrome\/[0-9.]+ (?!Mobile)",
        "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
        "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
        "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b",
        "BlackBerryTablet": "PlayBook|RIM Tablet",
        "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
        "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
        "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
        "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30",
        "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
        "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
        "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
        "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
        "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304X|TB-X304F|TB-X304L|TB-X505F|TB-X505L|TB-X505X|TB-X605F|TB-X605L|TB-8703F|TB-8703X|TB-8703N|TB-8704N|TB-8704F|TB-8704X|TB-8704V|TB-7304F|TB-7304I|TB-7304X|Tab2A7-10F|Tab2A7-20F|TB2-X30L|YT3-X50L|YT3-X50F|YT3-X50M|YT-X705F|YT-X703F|YT-X703L|YT-X705L|YT-X705X|TB2-X30F|TB2-X30L|TB2-X30M|A2107A-F|A2107A-H|TB3-730F|TB3-730M|TB3-730X|TB-7504F|TB-7504X",
        "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
        "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
        "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
        "ArnovaTablet": "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
        "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
        "IRUTablet": "M702pro",
        "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
        "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
        "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
        "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
        "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
        "NokiaLumiaTablet": "Lumia 2520",
        "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712",
        "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
        "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
        "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
        "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
        "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
        "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
        "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
        "FlyTablet": "IQ310|Fly Vision",
        "bqTablet": "Android.*(bq)?.*\\b(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))\\b|Maxwell.*Lite|Maxwell.*Plus",
        "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09|AGS-L09|CMR-AL19",
        "NecTablet": "\\bN-06D|\\bN-08D",
        "PantechTablet": "Pantech.*P4100",
        "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
        "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
        "ZyncTablet": "z1000|Z99 2G|z930|z990|z909|Z919|z900",
        "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
        "NabiTablet": "Android.*\\bNabi",
        "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
        "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
        "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
        "PlaystationTablet": "Playstation.*(Portable|Vita)",
        "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
        "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
        "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
        "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
        "GalapadTablet": "Android.*\\bG1\\b(?!\\))",
        "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
        "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
        "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
        "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
        "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
        "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
        "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
        "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
        "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027",
        "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
        "DPSTablet": "DPS Dream 9|DPS Dual 7",
        "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
        "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
        "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
        "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
        "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
        "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
        "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
        "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
        "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
        "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497|VFD 1400",
        "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
        "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
        "iMobileTablet": "i-mobile i-note",
        "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
        "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
        "AMPETablet": "Android.* A78 ",
        "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
        "TecnoTablet": "TECNO P9|TECNO DP8D",
        "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
        "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
        "FX2Tablet": "FX2 PAD7|FX2 PAD10",
        "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
        "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
        "VerizonTablet": "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1",
        "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
        "CaptivaTablet": "CAPTIVA PAD",
        "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
        "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
        "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b",
        "JaytechTablet": "TPC-PA762",
        "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
        "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
        "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
        "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
        "AocTablet": "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712",
        "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
        "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
        "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
        "MediacomTablet": "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA",
        "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
        "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
        "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
        "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
        "UbislateTablet": "UbiSlate[\\s]?7C",
        "PocketBookTablet": "Pocketbook",
        "KocasoTablet": "\\b(TB-1207)\\b",
        "HisenseTablet": "\\b(F5281|E2371)\\b",
        "Hudl": "Hudl HT7S3|Hudl 2",
        "TelstraTablet": "T-Hub2",
        "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107"
    },
    "oss": {
        "AndroidOS": "Android",
        "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
        "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
        "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
        "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Windows Mobile|Windows Phone [0-9.]+|WCE;",
        "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
        "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia",
        "iPadOS": "CPU OS 13",
        "MeeGoOS": "MeeGo",
        "MaemoOS": "Maemo",
        "JavaOS": "J2ME\/|\\bMIDP\\b|\\bCLDC\\b",
        "webOS": "webOS|hpwOS",
        "badaOS": "\\bBada\\b",
        "BREWOS": "BREW"
    },
    "uas": {
        "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome\/[.0-9]* (Mobile)?",
        "Dolfin": "\\bDolfin\\b",
        "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR\/[0-9.]+$|Coast\/[0-9.]+",
        "Skyfire": "Skyfire",
        "Edge": "Mobile Safari\/[.0-9]* Edge",
        "IE": "IEMobile|MSIEMobile",
        "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS",
        "Bolt": "bolt",
        "TeaShark": "teashark",
        "Blazer": "Blazer",
        "Safari": "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",
        "WeChat": "\\bMicroMessenger\\b",
        "UCBrowser": "UC.*Browser|UCWEB",
        "baiduboxapp": "baiduboxapp",
        "baidubrowser": "baidubrowser",
        "DiigoBrowser": "DiigoBrowser",
        "Mercury": "\\bMercury\\b",
        "ObigoBrowser": "Obigo",
        "NetFront": "NF-Browser",
        "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger",
        "PaleMoon": "Android.*PaleMoon|Mobile.*PaleMoon"
    },
    "props": {
        "Mobile": "Mobile\/[VER]",
        "Build": "Build\/[VER]",
        "Version": "Version\/[VER]",
        "VendorID": "VendorID\/[VER]",
        "iPad": "iPad.*CPU[a-z ]+[VER]",
        "iPhone": "iPhone.*CPU[a-z ]+[VER]",
        "iPod": "iPod.*CPU[a-z ]+[VER]",
        "Kindle": "Kindle\/[VER]",
        "Chrome": [
            "Chrome\/[VER]",
            "CriOS\/[VER]",
            "CrMo\/[VER]"
        ],
        "Coast": [
            "Coast\/[VER]"
        ],
        "Dolfin": "Dolfin\/[VER]",
        "Firefox": [
            "Firefox\/[VER]",
            "FxiOS\/[VER]"
        ],
        "Fennec": "Fennec\/[VER]",
        "Edge": "Edge\/[VER]",
        "IE": [
            "IEMobile\/[VER];",
            "IEMobile [VER]",
            "MSIE [VER];",
            "Trident\/[0-9.]+;.*rv:[VER]"
        ],
        "NetFront": "NetFront\/[VER]",
        "NokiaBrowser": "NokiaBrowser\/[VER]",
        "Opera": [
            " OPR\/[VER]",
            "Opera Mini\/[VER]",
            "Version\/[VER]"
        ],
        "Opera Mini": "Opera Mini\/[VER]",
        "Opera Mobi": "Version\/[VER]",
        "UCBrowser": [
            "UCWEB[VER]",
            "UC.*Browser\/[VER]"
        ],
        "MQQBrowser": "MQQBrowser\/[VER]",
        "MicroMessenger": "MicroMessenger\/[VER]",
        "baiduboxapp": "baiduboxapp\/[VER]",
        "baidubrowser": "baidubrowser\/[VER]",
        "SamsungBrowser": "SamsungBrowser\/[VER]",
        "Iron": "Iron\/[VER]",
        "Safari": [
            "Version\/[VER]",
            "Safari\/[VER]"
        ],
        "Skyfire": "Skyfire\/[VER]",
        "Tizen": "Tizen\/[VER]",
        "Webkit": "webkit[ \/][VER]",
        "PaleMoon": "PaleMoon\/[VER]",
        "Gecko": "Gecko\/[VER]",
        "Trident": "Trident\/[VER]",
        "Presto": "Presto\/[VER]",
        "Goanna": "Goanna\/[VER]",
        "iOS": " \\bi?OS\\b [VER][ ;]{1}",
        "Android": "Android [VER]",
        "BlackBerry": [
            "BlackBerry[\\w]+\/[VER]",
            "BlackBerry.*Version\/[VER]",
            "Version\/[VER]"
        ],
        "BREW": "BREW [VER]",
        "Java": "Java\/[VER]",
        "Windows Phone OS": [
            "Windows Phone OS [VER]",
            "Windows Phone [VER]"
        ],
        "Windows Phone": "Windows Phone [VER]",
        "Windows CE": "Windows CE\/[VER]",
        "Windows NT": "Windows NT [VER]",
        "Symbian": [
            "SymbianOS\/[VER]",
            "Symbian\/[VER]"
        ],
        "webOS": [
            "webOS\/[VER]",
            "hpwOS\/[VER];"
        ]
    },
    "utils": {
        "Bot": "Googlebot|facebookexternalhit|Google-AMPHTML|s~amp-validator|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom|contentkingapp",
        "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker\/M1A1-R2D2",
        "DesktopMode": "WPDesktop",
        "TV": "SonyDTV|HbbTV",
        "WebKit": "(webkit)[ \/]([\\w.]+)",
        "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b",
        "Watch": "SM-V700"
    }
};

    // following patterns come from http://detectmobilebrowsers.com/
    impl.detectMobileBrowsers = {
        fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
        shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
        tabletPattern: /android|ipad|playbook|silk/i
    };

    var hasOwnProp = Object.prototype.hasOwnProperty,
        isArray;

    impl.FALLBACK_PHONE = 'UnknownPhone';
    impl.FALLBACK_TABLET = 'UnknownTablet';
    impl.FALLBACK_MOBILE = 'UnknownMobile';

    isArray = ('isArray' in Array) ?
        Array.isArray : function (value) { return Object.prototype.toString.call(value) === '[object Array]'; };

    function equalIC(a, b) {
        return a != null && b != null && a.toLowerCase() === b.toLowerCase();
    }

    function containsIC(array, value) {
        var valueLC, i, len = array.length;
        if (!len || !value) {
            return false;
        }
        valueLC = value.toLowerCase();
        for (i = 0; i < len; ++i) {
            if (valueLC === array[i].toLowerCase()) {
                return true;
            }
        }
        return false;
    }

    function convertPropsToRegExp(object) {
        for (var key in object) {
            if (hasOwnProp.call(object, key)) {
                object[key] = new RegExp(object[key], 'i');
            }
        }
    }

    function prepareUserAgent(userAgent) {
        return (userAgent || '').substr(0, 500); // mitigate vulnerable to ReDoS
    }

    (function init() {
        var key, values, value, i, len, verPos, mobileDetectRules = impl.mobileDetectRules;
        for (key in mobileDetectRules.props) {
            if (hasOwnProp.call(mobileDetectRules.props, key)) {
                values = mobileDetectRules.props[key];
                if (!isArray(values)) {
                    values = [values];
                }
                len = values.length;
                for (i = 0; i < len; ++i) {
                    value = values[i];
                    verPos = value.indexOf('[VER]');
                    if (verPos >= 0) {
                        value = value.substring(0, verPos) + '([\\w._\\+]+)' + value.substring(verPos + 5);
                    }
                    values[i] = new RegExp(value, 'i');
                }
                mobileDetectRules.props[key] = values;
            }
        }
        convertPropsToRegExp(mobileDetectRules.oss);
        convertPropsToRegExp(mobileDetectRules.phones);
        convertPropsToRegExp(mobileDetectRules.tablets);
        convertPropsToRegExp(mobileDetectRules.uas);
        convertPropsToRegExp(mobileDetectRules.utils);

        // copy some patterns to oss0 which are tested first (see issue#15)
        mobileDetectRules.oss0 = {
            WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
            WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
        };
    }());

    /**
     * Test userAgent string against a set of rules and find the first matched key.
     * @param {Object} rules (key is String, value is RegExp)
     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
     * @returns {String|null} the matched key if found, otherwise <tt>null</tt>
     * @private
     */
    impl.findMatch = function(rules, userAgent) {
        for (var key in rules) {
            if (hasOwnProp.call(rules, key)) {
                if (rules[key].test(userAgent)) {
                    return key;
                }
            }
        }
        return null;
    };

    /**
     * Test userAgent string against a set of rules and return an array of matched keys.
     * @param {Object} rules (key is String, value is RegExp)
     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
     * @returns {Array} an array of matched keys, may be empty when there is no match, but not <tt>null</tt>
     * @private
     */
    impl.findMatches = function(rules, userAgent) {
        var result = [];
        for (var key in rules) {
            if (hasOwnProp.call(rules, key)) {
                if (rules[key].test(userAgent)) {
                    result.push(key);
                }
            }
        }
        return result;
    };

    /**
     * Check the version of the given property in the User-Agent.
     *
     * @param {String} propertyName
     * @param {String} userAgent
     * @return {String} version or <tt>null</tt> if version not found
     * @private
     */
    impl.getVersionStr = function (propertyName, userAgent) {
        var props = impl.mobileDetectRules.props, patterns, i, len, match;
        if (hasOwnProp.call(props, propertyName)) {
            patterns = props[propertyName];
            len = patterns.length;
            for (i = 0; i < len; ++i) {
                match = patterns[i].exec(userAgent);
                if (match !== null) {
                    return match[1];
                }
            }
        }
        return null;
    };

    /**
     * Check the version of the given property in the User-Agent.
     * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
     *
     * @param {String} propertyName
     * @param {String} userAgent
     * @return {Number} version or <tt>NaN</tt> if version not found
     * @private
     */
    impl.getVersion = function (propertyName, userAgent) {
        var version = impl.getVersionStr(propertyName, userAgent);
        return version ? impl.prepareVersionNo(version) : NaN;
    };

    /**
     * Prepare the version number.
     *
     * @param {String} version
     * @return {Number} the version number as a floating number
     * @private
     */
    impl.prepareVersionNo = function (version) {
        var numbers;

        numbers = version.split(/[a-z._ \/\-]/i);
        if (numbers.length === 1) {
            version = numbers[0];
        }
        if (numbers.length > 1) {
            version = numbers[0] + '.';
            numbers.shift();
            version += numbers.join('');
        }
        return Number(version);
    };

    impl.isMobileFallback = function (userAgent) {
        return impl.detectMobileBrowsers.fullPattern.test(userAgent) ||
            impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0,4));
    };

    impl.isTabletFallback = function (userAgent) {
        return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
    };

    impl.prepareDetectionCache = function (cache, userAgent, maxPhoneWidth) {
        if (cache.mobile !== undefined) {
            return;
        }
        var phone, tablet, phoneSized;

        // first check for stronger tablet rules, then phone (see issue#5)
        tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
        if (tablet) {
            cache.mobile = cache.tablet = tablet;
            cache.phone = null;
            return; // unambiguously identified as tablet
        }

        phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
        if (phone) {
            cache.mobile = cache.phone = phone;
            cache.tablet = null;
            return; // unambiguously identified as phone
        }

        // our rules haven't found a match -> try more general fallback rules
        if (impl.isMobileFallback(userAgent)) {
            phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);
            if (phoneSized === undefined) {
                cache.mobile = impl.FALLBACK_MOBILE;
                cache.tablet = cache.phone = null;
            } else if (phoneSized) {
                cache.mobile = cache.phone = impl.FALLBACK_PHONE;
                cache.tablet = null;
            } else {
                cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
                cache.phone = null;
            }
        } else if (impl.isTabletFallback(userAgent)) {
            cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
            cache.phone = null;
        } else {
            // not mobile at all!
            cache.mobile = cache.tablet = cache.phone = null;
        }
    };

    // t is a reference to a MobileDetect instance
    impl.mobileGrade = function (t) {
        // impl note:
        // To keep in sync w/ Mobile_Detect.php easily, the following code is tightly aligned to the PHP version.
        // When changes are made in Mobile_Detect.php, copy this method and replace:
        //     $this-> / t.
        //     self::MOBILE_GRADE_(.) / '$1'
        //     , self::VERSION_TYPE_FLOAT / (nothing)
        //     isIOS() / os('iOS')
        //     [reg] / (nothing)   <-- jsdelivr complaining about unescaped unicode character U+00AE
        var $isMobile = t.mobile() !== null;

        if (
            // Apple iOS 3.2-5.1 - Tested on the original iPad (4.3 / 5.0), iPad 2 (4.3), iPad 3 (5.1), original iPhone (3.1), iPhone 3 (3.2), 3GS (4.3), 4 (4.3 / 5.0), and 4S (5.1)
            t.os('iOS') && t.version('iPad')>=4.3 ||
            t.os('iOS') && t.version('iPhone')>=3.1 ||
            t.os('iOS') && t.version('iPod')>=3.1 ||

            // Android 2.1-2.3 - Tested on the HTC Incredible (2.2), original Droid (2.2), HTC Aria (2.1), Google Nexus S (2.3). Functional on 1.5 & 1.6 but performance may be sluggish, tested on Google G1 (1.5)
            // Android 3.1 (Honeycomb)  - Tested on the Samsung Galaxy Tab 10.1 and Motorola XOOM
            // Android 4.0 (ICS)  - Tested on a Galaxy Nexus. Note: transition performance can be poor on upgraded devices
            // Android 4.1 (Jelly Bean)  - Tested on a Galaxy Nexus and Galaxy 7
            ( t.version('Android')>2.1 && t.is('Webkit') ) ||

            // Windows Phone 7-7.5 - Tested on the HTC Surround (7.0) HTC Trophy (7.5), LG-E900 (7.5), Nokia Lumia 800
            t.version('Windows Phone OS')>=7.0 ||

            // Blackberry 7 - Tested on BlackBerry Torch 9810
            // Blackberry 6.0 - Tested on the Torch 9800 and Style 9670
            t.is('BlackBerry') && t.version('BlackBerry')>=6.0 ||
            // Blackberry Playbook (1.0-2.0) - Tested on PlayBook
            t.match('Playbook.*Tablet') ||

            // Palm WebOS (1.4-2.0) - Tested on the Palm Pixi (1.4), Pre (1.4), Pre 2 (2.0)
            ( t.version('webOS')>=1.4 && t.match('Palm|Pre|Pixi') ) ||
            // Palm WebOS 3.0  - Tested on HP TouchPad
            t.match('hp.*TouchPad') ||

            // Firefox Mobile (12 Beta) - Tested on Android 2.3 device
            ( t.is('Firefox') && t.version('Firefox')>=12 ) ||

            // Chrome for Android - Tested on Android 4.0, 4.1 device
            ( t.is('Chrome') && t.is('AndroidOS') && t.version('Android')>=4.0 ) ||

            // Skyfire 4.1 - Tested on Android 2.3 device
            ( t.is('Skyfire') && t.version('Skyfire')>=4.1 && t.is('AndroidOS') && t.version('Android')>=2.3 ) ||

            // Opera Mobile 11.5-12: Tested on Android 2.3
            ( t.is('Opera') && t.version('Opera Mobi')>11 && t.is('AndroidOS') ) ||

            // Meego 1.2 - Tested on Nokia 950 and N9
            t.is('MeeGoOS') ||

            // Tizen (pre-release) - Tested on early hardware
            t.is('Tizen') ||

            // Samsung Bada 2.0 - Tested on a Samsung Wave 3, Dolphin browser
            // @todo: more tests here!
            t.is('Dolfin') && t.version('Bada')>=2.0 ||

            // UC Browser - Tested on Android 2.3 device
            ( (t.is('UC Browser') || t.is('Dolfin')) && t.version('Android')>=2.3 ) ||

            // Kindle 3 and Fire  - Tested on the built-in WebKit browser for each
            ( t.match('Kindle Fire') ||
                t.is('Kindle') && t.version('Kindle')>=3.0 ) ||

            // Nook Color 1.4.1 - Tested on original Nook Color, not Nook Tablet
            t.is('AndroidOS') && t.is('NookTablet') ||

            // Chrome Desktop 11-21 - Tested on OS X 10.7 and Windows 7
            t.version('Chrome')>=11 && !$isMobile ||

            // Safari Desktop 4-5 - Tested on OS X 10.7 and Windows 7
            t.version('Safari')>=5.0 && !$isMobile ||

            // Firefox Desktop 4-13 - Tested on OS X 10.7 and Windows 7
            t.version('Firefox')>=4.0 && !$isMobile ||

            // Internet Explorer 7-9 - Tested on Windows XP, Vista and 7
            t.version('MSIE')>=7.0 && !$isMobile ||

            // Opera Desktop 10-12 - Tested on OS X 10.7 and Windows 7
            // @reference: http://my.opera.com/community/openweb/idopera/
            t.version('Opera')>=10 && !$isMobile

            ){
            return 'A';
        }

        if (
            t.os('iOS') && t.version('iPad')<4.3 ||
            t.os('iOS') && t.version('iPhone')<3.1 ||
            t.os('iOS') && t.version('iPod')<3.1 ||

            // Blackberry 5.0: Tested on the Storm 2 9550, Bold 9770
            t.is('Blackberry') && t.version('BlackBerry')>=5 && t.version('BlackBerry')<6 ||

            //Opera Mini (5.0-6.5) - Tested on iOS 3.2/4.3 and Android 2.3
            ( t.version('Opera Mini')>=5.0 && t.version('Opera Mini')<=6.5 &&
                (t.version('Android')>=2.3 || t.is('iOS')) ) ||

            // Nokia Symbian^3 - Tested on Nokia N8 (Symbian^3), C7 (Symbian^3), also works on N97 (Symbian^1)
            t.match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') ||

            // @todo: report this (tested on Nokia N71)
            t.version('Opera Mobi')>=11 && t.is('SymbianOS')
            ){
            return 'B';
        }

        if (
        // Blackberry 4.x - Tested on the Curve 8330
            t.version('BlackBerry')<5.0 ||
            // Windows Mobile - Tested on the HTC Leo (WinMo 5.2)
            t.match('MSIEMobile|Windows CE.*Mobile') || t.version('Windows Mobile')<=5.2

            ){
            return 'C';
        }

        //All older smartphone platforms and featurephones - Any device that doesn't support media queries
        //will receive the basic, C grade experience.
        return 'C';
    };

    impl.detectOS = function (ua) {
        return impl.findMatch(impl.mobileDetectRules.oss0, ua) ||
            impl.findMatch(impl.mobileDetectRules.oss, ua);
    };

    impl.getDeviceSmallerSide = function () {
        return window.screen.width < window.screen.height ?
            window.screen.width :
            window.screen.height;
    };

    /**
     * Constructor for MobileDetect object.
     * <br>
     * Such an object will keep a reference to the given user-agent string and cache most of the detect queries.<br>
     * <div style="background-color: #d9edf7; border: 1px solid #bce8f1; color: #3a87ad; padding: 14px; border-radius: 2px; margin-top: 20px">
     *     <strong>Find information how to download and install:</strong>
     *     <a href="https://github.com/hgoebl/mobile-detect.js/">github.com/hgoebl/mobile-detect.js/</a>
     * </div>
     *
     * @example <pre>
     *     var md = new MobileDetect(window.navigator.userAgent);
     *     if (md.mobile()) {
     *         location.href = (md.mobileGrade() === 'A') ? '/mobile/' : '/lynx/';
     *     }
     * </pre>
     *
     * @param {string} userAgent typically taken from window.navigator.userAgent or http_header['User-Agent']
     * @param {number} [maxPhoneWidth=600] <strong>only for browsers</strong> specify a value for the maximum
     *        width of smallest device side (in logical "CSS" pixels) until a device detected as mobile will be handled
     *        as phone.
     *        This is only used in cases where the device cannot be classified as phone or tablet.<br>
     *        See <a href="http://developer.android.com/guide/practices/screens_support.html">Declaring Tablet Layouts
     *        for Android</a>.<br>
     *        If you provide a value < 0, then this "fuzzy" check is disabled.
     * @constructor
     * @global
     */
    function MobileDetect(userAgent, maxPhoneWidth) {
        this.ua = prepareUserAgent(userAgent);
        this._cache = {};
        //600dp is typical 7" tablet minimum width
        this.maxPhoneWidth = maxPhoneWidth || 600;
    }

    MobileDetect.prototype = {
        constructor: MobileDetect,

        /**
         * Returns the detected phone or tablet type or <tt>null</tt> if it is not a mobile device.
         * <br>
         * For a list of possible return values see {@link MobileDetect#phone} and {@link MobileDetect#tablet}.<br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownPhone</code>, <code>UnknownTablet</code> or
         * <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>UnknownMobile</code> here.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key for the phone family or tablet family, e.g. "Nexus".
         * @function MobileDetect#mobile
         */
        mobile: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.mobile;
        },

        /**
         * Returns the detected phone type/family string or <tt>null</tt>.
         * <br>
         * The returned tablet (family or producer) is one of following keys:<br>
         * <br><tt>iPhone, BlackBerry, HTC, Nexus, Dell, Motorola, Samsung, LG, Sony, Asus,
         * NokiaLumia, Micromax, Palm, Vertu, Pantech, Fly, Wiko, iMobile, SimValley,
         * Wolfgang, Alcatel, Nintendo, Amoi, INQ, OnePlus, GenericPhone</tt><br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownPhone</code> or <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
         * will return <code>UnknownMobile</code>.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key of the phone family or producer, e.g. "iPhone"
         * @function MobileDetect#phone
         */
        phone: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.phone;
        },

        /**
         * Returns the detected tablet type/family string or <tt>null</tt>.
         * <br>
         * The returned tablet (family or producer) is one of following keys:<br>
         * <br><tt>iPad, NexusTablet, GoogleTablet, SamsungTablet, Kindle, SurfaceTablet,
         * HPTablet, AsusTablet, BlackBerryTablet, HTCtablet, MotorolaTablet, NookTablet,
         * AcerTablet, ToshibaTablet, LGTablet, FujitsuTablet, PrestigioTablet,
         * LenovoTablet, DellTablet, YarvikTablet, MedionTablet, ArnovaTablet,
         * IntensoTablet, IRUTablet, MegafonTablet, EbodaTablet, AllViewTablet,
         * ArchosTablet, AinolTablet, NokiaLumiaTablet, SonyTablet, PhilipsTablet,
         * CubeTablet, CobyTablet, MIDTablet, MSITablet, SMiTTablet, RockChipTablet,
         * FlyTablet, bqTablet, HuaweiTablet, NecTablet, PantechTablet, BronchoTablet,
         * VersusTablet, ZyncTablet, PositivoTablet, NabiTablet, KoboTablet, DanewTablet,
         * TexetTablet, PlaystationTablet, TrekstorTablet, PyleAudioTablet, AdvanTablet,
         * DanyTechTablet, GalapadTablet, MicromaxTablet, KarbonnTablet, AllFineTablet,
         * PROSCANTablet, YONESTablet, ChangJiaTablet, GUTablet, PointOfViewTablet,
         * OvermaxTablet, HCLTablet, DPSTablet, VistureTablet, CrestaTablet,
         * MediatekTablet, ConcordeTablet, GoCleverTablet, ModecomTablet, VoninoTablet,
         * ECSTablet, StorexTablet, VodafoneTablet, EssentielBTablet, RossMoorTablet,
         * iMobileTablet, TolinoTablet, AudioSonicTablet, AMPETablet, SkkTablet,
         * TecnoTablet, JXDTablet, iJoyTablet, FX2Tablet, XoroTablet, ViewsonicTablet,
         * VerizonTablet, OdysTablet, CaptivaTablet, IconbitTablet, TeclastTablet,
         * OndaTablet, JaytechTablet, BlaupunktTablet, DigmaTablet, EvolioTablet,
         * LavaTablet, AocTablet, MpmanTablet, CelkonTablet, WolderTablet, MediacomTablet,
         * MiTablet, NibiruTablet, NexoTablet, LeaderTablet, UbislateTablet,
         * PocketBookTablet, KocasoTablet, HisenseTablet, Hudl, TelstraTablet,
         * GenericTablet</tt><br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownTablet</code> or <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
         * will return <code>UnknownMobile</code>.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key of the tablet family or producer, e.g. "SamsungTablet"
         * @function MobileDetect#tablet
         */
        tablet: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.tablet;
        },

        /**
         * Returns the (first) detected user-agent string or <tt>null</tt>.
         * <br>
         * The returned user-agent is one of following keys:<br>
         * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
         * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Mercury,
         * ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
         * <br>
         * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
         * cases where a mobile device pretends to be more than one particular browser. You can get the
         * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
         * providing one of the defined keys as first argument to {@link MobileDetect#is}.
         *
         * @returns {String} the key for the detected user-agent or <tt>null</tt>
         * @function MobileDetect#userAgent
         */
        userAgent: function () {
            if (this._cache.userAgent === undefined) {
                this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
            }
            return this._cache.userAgent;
        },

        /**
         * Returns all detected user-agent strings.
         * <br>
         * The array is empty or contains one or more of following keys:<br>
         * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
         * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Mercury,
         * ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
         * <br>
         * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
         * cases where a mobile device pretends to be more than one particular browser. You can get the
         * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
         * providing one of the defined keys as first argument to {@link MobileDetect#is}.
         *
         * @returns {Array} the array of detected user-agent keys or <tt>[]</tt>
         * @function MobileDetect#userAgents
         */
        userAgents: function () {
            if (this._cache.userAgents === undefined) {
                this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
            }
            return this._cache.userAgents;
        },

        /**
         * Returns the detected operating system string or <tt>null</tt>.
         * <br>
         * The operating system is one of following keys:<br>
         * <br><tt>AndroidOS, BlackBerryOS, PalmOS, SymbianOS, WindowsMobileOS, WindowsPhoneOS,
         * iOS, iPadOS, MeeGoOS, MaemoOS, JavaOS, webOS, badaOS, BREWOS</tt><br>
         *
         * @returns {String} the key for the detected operating system.
         * @function MobileDetect#os
         */
        os: function () {
            if (this._cache.os === undefined) {
                this._cache.os = impl.detectOS(this.ua);
            }
            return this._cache.os;
        },

        /**
         * Get the version (as Number) of the given property in the User-Agent.
         * <br>
         * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
         *
         * @param {String} key a key defining a thing which has a version.<br>
         *        You can use one of following keys:<br>
         * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
         * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
         * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
         * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
         * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
         * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
         *
         * @returns {Number} the version as float or <tt>NaN</tt> if User-Agent doesn't contain this version.
         *          Be careful when comparing this value with '==' operator!
         * @function MobileDetect#version
         */
        version: function (key) {
            return impl.getVersion(key, this.ua);
        },

        /**
         * Get the version (as String) of the given property in the User-Agent.
         * <br>
         *
         * @param {String} key a key defining a thing which has a version.<br>
         *        You can use one of following keys:<br>
         * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
         * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
         * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
         * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
         * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
         * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
         *
         * @returns {String} the "raw" version as String or <tt>null</tt> if User-Agent doesn't contain this version.
         *
         * @function MobileDetect#versionStr
         */
        versionStr: function (key) {
            return impl.getVersionStr(key, this.ua);
        },

        /**
         * Global test key against userAgent, os, phone, tablet and some other properties of userAgent string.
         *
         * @param {String} key the key (case-insensitive) of a userAgent, an operating system, phone or
         *        tablet family.<br>
         *        For a complete list of possible values, see {@link MobileDetect#userAgent},
         *        {@link MobileDetect#os}, {@link MobileDetect#phone}, {@link MobileDetect#tablet}.<br>
         *        Additionally you have following keys:<br>
         * <br><tt>Bot, MobileBot, DesktopMode, TV, WebKit, Console, Watch</tt><br>
         *
         * @returns {boolean} <tt>true</tt> when the given key is one of the defined keys of userAgent, os, phone,
         *                    tablet or one of the listed additional keys, otherwise <tt>false</tt>
         * @function MobileDetect#is
         */
        is: function (key) {
            return containsIC(this.userAgents(), key) ||
                   equalIC(key, this.os()) ||
                   equalIC(key, this.phone()) ||
                   equalIC(key, this.tablet()) ||
                   containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
        },

        /**
         * Do a quick test against navigator::userAgent.
         *
         * @param {String|RegExp} pattern the pattern, either as String or RegExp
         *                        (a string will be converted to a case-insensitive RegExp).
         * @returns {boolean} <tt>true</tt> when the pattern matches, otherwise <tt>false</tt>
         * @function MobileDetect#match
         */
        match: function (pattern) {
            if (!(pattern instanceof RegExp)) {
                pattern = new RegExp(pattern, 'i');
            }
            return pattern.test(this.ua);
        },

        /**
         * Checks whether the mobile device can be considered as phone regarding <code>screen.width</code>.
         * <br>
         * Obviously this method makes sense in browser environments only (not for Node.js)!
         * @param {number} [maxPhoneWidth] the maximum logical pixels (aka. CSS-pixels) to be considered as phone.<br>
         *        The argument is optional and if not present or falsy, the value of the constructor is taken.
         * @returns {boolean|undefined} <code>undefined</code> if screen size wasn't detectable, else <code>true</code>
         *          when screen.width is less or equal to maxPhoneWidth, otherwise <code>false</code>.<br>
         *          Will always return <code>undefined</code> server-side.
         */
        isPhoneSized: function (maxPhoneWidth) {
            return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
        },

        /**
         * Returns the mobile grade ('A', 'B', 'C').
         *
         * @returns {String} one of the mobile grades ('A', 'B', 'C').
         * @function MobileDetect#mobileGrade
         */
        mobileGrade: function () {
            if (this._cache.grade === undefined) {
                this._cache.grade = impl.mobileGrade(this);
            }
            return this._cache.grade;
        }
    };

    // environment-dependent
    if (typeof window !== 'undefined' && window.screen) {
        MobileDetect.isPhoneSized = function (maxPhoneWidth) {
            return maxPhoneWidth < 0 ? undefined : impl.getDeviceSmallerSide() <= maxPhoneWidth;
        };
    } else {
        MobileDetect.isPhoneSized = function () {};
    }

    // should not be replaced by a completely new object - just overwrite existing methods
    MobileDetect._impl = impl;
    
    MobileDetect.version = '1.4.4 2019-09-21';

    return MobileDetect;
}); // end of call of define()
})((function (undefined) {
    if ( true && module.exports) {
        return function (factory) { module.exports = factory(); };
    } else if (true) {
        return __webpack_require__(/*! !webpack amd define */ "./node_modules/next/node_modules/webpack/buildin/amd-define.js");
    } else {}
})());

/***/ }),

/***/ "./node_modules/nanoid/format.browser.js":
/*!***********************************************!*\
  !*** ./node_modules/nanoid/format.browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// This file replaces `format.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.

module.exports = function (random, alphabet, size) {
  // We cant use bytes bigger than the alphabet. To make bytes values closer
  // to the alphabet, we apply bitmask on them. We look for the closest
  // `2 ** x - 1` number, which will be bigger than alphabet size. If we have
  // 30 symbols in the alphabet, we will take 31 (00011111).
  // We do not use faster Math.clz32, because it is not available in browsers.
  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1
  // Bitmask is not a perfect solution (in our example it will pass 31 bytes,
  // which is bigger than the alphabet). As a result, we will need more bytes,
  // than ID size, because we will refuse bytes bigger than the alphabet.

  // Every hardware random generator call is costly,
  // because we need to wait for entropy collection. This is why often it will
  // be faster to ask for few extra bytes in advance, to avoid additional calls.

  // Here we calculate how many random bytes should we call in advance.
  // It depends on ID length, mask / alphabet size and magic number 1.6
  // (which was selected according benchmarks).

  // -~f => Math.ceil(f) if n is float number
  // -~i => i + 1 if n is integer number
  var step = -~(1.6 * mask * size / alphabet.length)
  var id = ''

  while (true) {
    var bytes = random(step)
    // Compact alternative for `for (var i = 0; i < step; i++)`
    var i = step
    while (i--) {
      // If random byte is bigger than alphabet even after bitmask,
      // we refuse it by `|| ''`.
      id += alphabet[bytes[i] & mask] || ''
      // More compact than `id.length + 1 === size`
      if (id.length === +size) return id
    }
  }
}


/***/ }),

/***/ "./node_modules/next/node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),

/***/ "./node_modules/react-ga/dist/esm/components/OutboundLink.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/components/OutboundLink.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OutboundLink; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_console_warn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/console/warn */ "./node_modules/react-ga/dist/esm/utils/console/warn.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var NEWTAB = '_blank';
var MIDDLECLICK = 1;

var OutboundLink =
/*#__PURE__*/
function (_Component) {
  _inherits(OutboundLink, _Component);

  function OutboundLink() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, OutboundLink);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(OutboundLink)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "handleClick", function (event) {
      var _this$props = _this.props,
          target = _this$props.target,
          eventLabel = _this$props.eventLabel,
          to = _this$props.to,
          onClick = _this$props.onClick,
          trackerNames = _this$props.trackerNames;
      var eventMeta = {
        label: eventLabel
      };
      var sameTarget = target !== NEWTAB;
      var normalClick = !(event.ctrlKey || event.shiftKey || event.metaKey || event.button === MIDDLECLICK);

      if (sameTarget && normalClick) {
        event.preventDefault();
        OutboundLink.trackLink(eventMeta, function () {
          window.location.href = to;
        }, trackerNames);
      } else {
        OutboundLink.trackLink(eventMeta, function () {}, trackerNames);
      }

      if (onClick) {
        onClick(event);
      }
    });

    return _this;
  }

  _createClass(OutboundLink, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          href = _this$props2.to,
          oldProps = _objectWithoutProperties(_this$props2, ["to"]);

      var props = _objectSpread({}, oldProps, {
        href: href,
        onClick: this.handleClick
      });

      if (this.props.target === NEWTAB) {
        props.rel = 'noopener noreferrer';
      }

      delete props.eventLabel;
      delete props.trackerNames;
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('a', props);
    }
  }]);

  return OutboundLink;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

_defineProperty(OutboundLink, "trackLink", function () {
  Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_2__["default"])('ga tracking not enabled');
});

_defineProperty(OutboundLink, "propTypes", {
  eventLabel: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  target: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  to: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  onClick: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
  trackerNames: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string)
});

_defineProperty(OutboundLink, "defaultProps", {
  target: null,
  to: null,
  onClick: null,
  trackerNames: null
});



/***/ }),

/***/ "./node_modules/react-ga/dist/esm/core.js":
/*!************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/core.js ***!
  \************************************************/
/*! exports provided: initialize, ga, set, send, pageview, modalview, timing, event, exception, plugin, outboundLink, testModeAPI, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initialize", function() { return initialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ga", function() { return ga; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "send", function() { return send; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pageview", function() { return pageview; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modalview", function() { return modalview; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timing", function() { return timing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exception", function() { return exception; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plugin", function() { return plugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outboundLink", function() { return outboundLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testModeAPI", function() { return testModeAPI; });
/* harmony import */ var _utils_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/format */ "./node_modules/react-ga/dist/esm/utils/format.js");
/* harmony import */ var _utils_removeLeadingSlash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/removeLeadingSlash */ "./node_modules/react-ga/dist/esm/utils/removeLeadingSlash.js");
/* harmony import */ var _utils_trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/trim */ "./node_modules/react-ga/dist/esm/utils/trim.js");
/* harmony import */ var _utils_loadGA__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/loadGA */ "./node_modules/react-ga/dist/esm/utils/loadGA.js");
/* harmony import */ var _utils_console_warn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/console/warn */ "./node_modules/react-ga/dist/esm/utils/console/warn.js");
/* harmony import */ var _utils_console_log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/console/log */ "./node_modules/react-ga/dist/esm/utils/console/log.js");
/* harmony import */ var _utils_testModeAPI__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/testModeAPI */ "./node_modules/react-ga/dist/esm/utils/testModeAPI.js");
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/**
 * React Google Analytics Module
 *
 * @package react-ga
 * @author  Adam Lofting <adam@mozillafoundation.org>
 *          Atul Varma <atul@mozillafoundation.org>
 */

/**
 * Utilities
 */








var _isNotBrowser = typeof window === 'undefined' || typeof document === 'undefined';

var _debug = false;
var _titleCase = true;
var _testMode = false;
var _alwaysSendToDefaultTracker = true;

var internalGa = function internalGa() {
  var _window;

  if (_testMode) return _utils_testModeAPI__WEBPACK_IMPORTED_MODULE_6__["default"].ga.apply(_utils_testModeAPI__WEBPACK_IMPORTED_MODULE_6__["default"], arguments);
  if (_isNotBrowser) return false;
  if (!window.ga) return Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('ReactGA.initialize must be called first or GoogleAnalytics should be loaded manually');
  return (_window = window).ga.apply(_window, arguments);
};

function _format(s) {
  return Object(_utils_format__WEBPACK_IMPORTED_MODULE_0__["default"])(s, _titleCase);
}

function _gaCommand(trackerNames) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var command = args[0];

  if (typeof internalGa === 'function') {
    if (typeof command !== 'string') {
      Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('ga command must be a string');
      return;
    }

    if (_alwaysSendToDefaultTracker || !Array.isArray(trackerNames)) internalGa.apply(void 0, args);

    if (Array.isArray(trackerNames)) {
      trackerNames.forEach(function (name) {
        internalGa.apply(void 0, _toConsumableArray(["".concat(name, ".").concat(command)].concat(args.slice(1))));
      });
    }
  }
}

function _initialize(gaTrackingID, options) {
  if (!gaTrackingID) {
    Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('gaTrackingID is required in initialize()');
    return;
  }

  if (options) {
    if (options.debug && options.debug === true) {
      _debug = true;
    }

    if (options.titleCase === false) {
      _titleCase = false;
    }

    if (options.useExistingGa) {
      return;
    }
  }

  if (options && options.gaOptions) {
    internalGa('create', gaTrackingID, options.gaOptions);
  } else {
    internalGa('create', gaTrackingID, 'auto');
  }
}

function initialize(configsOrTrackingId, options) {
  if (options && options.testMode === true) {
    _testMode = true;
  } else {
    if (_isNotBrowser) {
      return false;
    }

    if (!options || options.standardImplementation !== true) Object(_utils_loadGA__WEBPACK_IMPORTED_MODULE_3__["default"])(options);
  }

  _alwaysSendToDefaultTracker = options && typeof options.alwaysSendToDefaultTracker === 'boolean' ? options.alwaysSendToDefaultTracker : true;

  if (Array.isArray(configsOrTrackingId)) {
    configsOrTrackingId.forEach(function (config) {
      if (_typeof(config) !== 'object') {
        Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('All configs must be an object');
        return;
      }

      _initialize(config.trackingId, config);
    });
  } else {
    _initialize(configsOrTrackingId, options);
  }

  return true;
}
/**
 * ga:
 * Returns the original GA object.
 */

function ga() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  if (args.length > 0) {
    internalGa.apply(void 0, args);

    if (_debug) {
      Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])('called ga(\'arguments\');');
      Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("with arguments: ".concat(JSON.stringify(args)));
    }
  }

  return window.ga;
}
/**
 * set:
 * GA tracker set method
 * @param {Object} fieldsObject - a field/value pair or a group of field/value pairs on the tracker
 * @param {Array} trackerNames - (optional) a list of extra trackers to run the command on
 */

function set(fieldsObject, trackerNames) {
  if (!fieldsObject) {
    Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('`fieldsObject` is required in .set()');
    return;
  }

  if (_typeof(fieldsObject) !== 'object') {
    Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('Expected `fieldsObject` arg to be an Object');
    return;
  }

  if (Object.keys(fieldsObject).length === 0) {
    Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('empty `fieldsObject` given to .set()');
  }

  _gaCommand(trackerNames, 'set', fieldsObject);

  if (_debug) {
    Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])('called ga(\'set\', fieldsObject);');
    Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("with fieldsObject: ".concat(JSON.stringify(fieldsObject)));
  }
}
/**
 * send:
 * Clone of the low level `ga.send` method
 * WARNING: No validations will be applied to this
 * @param  {Object} fieldObject - field object for tracking different analytics
 * @param  {Array} trackerNames - trackers to send the command to
 * @param {Array} trackerNames - (optional) a list of extra trackers to run the command on
 */

function send(fieldObject, trackerNames) {
  _gaCommand(trackerNames, 'send', fieldObject);

  if (_debug) {
    Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])('called ga(\'send\', fieldObject);');
    Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("with fieldObject: ".concat(JSON.stringify(fieldObject)));
    Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("with trackers: ".concat(JSON.stringify(trackerNames)));
  }
}
/**
 * pageview:
 * Basic GA pageview tracking
 * @param  {String} path - the current page page e.g. '/about'
 * @param {Array} trackerNames - (optional) a list of extra trackers to run the command on
 * @param {String} title - (optional) the page title e. g. 'My Website'
 */

function pageview(rawPath, trackerNames, title) {
  if (!rawPath) {
    Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('path is required in .pageview()');
    return;
  }

  var path = Object(_utils_trim__WEBPACK_IMPORTED_MODULE_2__["default"])(rawPath);

  if (path === '') {
    Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('path cannot be an empty string in .pageview()');
    return;
  }

  var extraFields = {};

  if (title) {
    extraFields.title = title;
  }

  if (typeof ga === 'function') {
    _gaCommand(trackerNames, 'send', _objectSpread({
      hitType: 'pageview',
      page: path
    }, extraFields));

    if (_debug) {
      Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])('called ga(\'send\', \'pageview\', path);');
      var extraLog = '';

      if (title) {
        extraLog = " and title: ".concat(title);
      }

      Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("with path: ".concat(path).concat(extraLog));
    }
  }
}
/**
 * modalview:
 * a proxy to basic GA pageview tracking to consistently track
 * modal views that are an equivalent UX to a traditional pageview
 * @param  {String} modalName e.g. 'add-or-edit-club'
 * @param {Array} trackerNames - (optional) a list of extra trackers to run the command on
 */

function modalview(rawModalName, trackerNames) {
  if (!rawModalName) {
    Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('modalName is required in .modalview(modalName)');
    return;
  }

  var modalName = Object(_utils_removeLeadingSlash__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_utils_trim__WEBPACK_IMPORTED_MODULE_2__["default"])(rawModalName));

  if (modalName === '') {
    Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('modalName cannot be an empty string or a single / in .modalview()');
    return;
  }

  if (typeof ga === 'function') {
    var path = "/modal/".concat(modalName);

    _gaCommand(trackerNames, 'send', 'pageview', path);

    if (_debug) {
      Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])('called ga(\'send\', \'pageview\', path);');
      Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("with path: ".concat(path));
    }
  }
}
/**
 * timing:
 * GA timing
 * @param args.category {String} required
 * @param args.variable {String} required
 * @param args.value  {Int}  required
 * @param args.label  {String} required
 * @param {Array} trackerNames - (optional) a list of extra trackers to run the command on
 */

function timing() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      category = _ref.category,
      variable = _ref.variable,
      value = _ref.value,
      label = _ref.label;

  var trackerNames = arguments.length > 1 ? arguments[1] : undefined;

  if (typeof ga === 'function') {
    if (!category || !variable || !value || typeof value !== 'number') {
      Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('args.category, args.variable ' + 'AND args.value are required in timing() ' + 'AND args.value has to be a number');
      return;
    } // Required Fields


    var fieldObject = {
      hitType: 'timing',
      timingCategory: _format(category),
      timingVar: _format(variable),
      timingValue: value
    };

    if (label) {
      fieldObject.timingLabel = _format(label);
    }

    send(fieldObject, trackerNames);
  }
}
/**
 * event:
 * GA event tracking
 * @param args.category {String} required
 * @param args.action {String} required
 * @param args.label {String} optional
 * @param args.value {Int} optional
 * @param args.nonInteraction {boolean} optional
 * @param args.transport {string} optional
 * @param {Array} trackerNames - (optional) a list of extra trackers to run the command on
 */

function event() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      category = _ref2.category,
      action = _ref2.action,
      label = _ref2.label,
      value = _ref2.value,
      nonInteraction = _ref2.nonInteraction,
      transport = _ref2.transport,
      args = _objectWithoutProperties(_ref2, ["category", "action", "label", "value", "nonInteraction", "transport"]);

  var trackerNames = arguments.length > 1 ? arguments[1] : undefined;

  if (typeof ga === 'function') {
    // Simple Validation
    if (!category || !action) {
      Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('args.category AND args.action are required in event()');
      return;
    } // Required Fields


    var fieldObject = {
      hitType: 'event',
      eventCategory: _format(category),
      eventAction: _format(action)
    }; // Optional Fields

    if (label) {
      fieldObject.eventLabel = _format(label);
    }

    if (typeof value !== 'undefined') {
      if (typeof value !== 'number') {
        Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('Expected `args.value` arg to be a Number.');
      } else {
        fieldObject.eventValue = value;
      }
    }

    if (typeof nonInteraction !== 'undefined') {
      if (typeof nonInteraction !== 'boolean') {
        Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('`args.nonInteraction` must be a boolean.');
      } else {
        fieldObject.nonInteraction = nonInteraction;
      }
    }

    if (typeof transport !== 'undefined') {
      if (typeof transport !== 'string') {
        Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('`args.transport` must be a string.');
      } else {
        if (['beacon', 'xhr', 'image'].indexOf(transport) === -1) {
          Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('`args.transport` must be either one of these values: `beacon`, `xhr` or `image`');
        }

        fieldObject.transport = transport;
      }
    }

    Object.keys(args).filter(function (key) {
      return key.substr(0, 'dimension'.length) === 'dimension';
    }).forEach(function (key) {
      fieldObject[key] = args[key];
    });
    Object.keys(args).filter(function (key) {
      return key.substr(0, 'metric'.length) === 'metric';
    }).forEach(function (key) {
      fieldObject[key] = args[key];
    }); // Send to GA

    send(fieldObject, trackerNames);
  }
}
/**
 * exception:
 * GA exception tracking
 * @param args.description {String} optional
 * @param args.fatal {boolean} optional
 * @param {Array} trackerNames - (optional) a list of extra trackers to run the command on
 */

function exception(_ref3, trackerNames) {
  var description = _ref3.description,
      fatal = _ref3.fatal;

  if (typeof ga === 'function') {
    // Required Fields
    var fieldObject = {
      hitType: 'exception'
    }; // Optional Fields

    if (description) {
      fieldObject.exDescription = _format(description);
    }

    if (typeof fatal !== 'undefined') {
      if (typeof fatal !== 'boolean') {
        Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('`args.fatal` must be a boolean.');
      } else {
        fieldObject.exFatal = fatal;
      }
    } // Send to GA


    send(fieldObject, trackerNames);
  }
}
var plugin = {
  /**
   * require:
   * GA requires a plugin
   * @param name {String} e.g. 'ecommerce' or 'myplugin'
   * @param options {Object} optional e.g {path: '/log', debug: true}
   * @param trackerName {String} optional e.g 'trackerName'
   */
  require: function require(rawName, options, trackerName) {
    if (typeof ga === 'function') {
      // Required Fields
      if (!rawName) {
        Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('`name` is required in .require()');
        return;
      }

      var name = Object(_utils_trim__WEBPACK_IMPORTED_MODULE_2__["default"])(rawName);

      if (name === '') {
        Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('`name` cannot be an empty string in .require()');
        return;
      }

      var requireString = trackerName ? "".concat(trackerName, ".require") : 'require'; // Optional Fields

      if (options) {
        if (_typeof(options) !== 'object') {
          Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('Expected `options` arg to be an Object');
          return;
        }

        if (Object.keys(options).length === 0) {
          Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('Empty `options` given to .require()');
        }

        ga(requireString, name, options);

        if (_debug) {
          Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("called ga('require', '".concat(name, "', ").concat(JSON.stringify(options)));
        }
      } else {
        ga(requireString, name);

        if (_debug) {
          Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("called ga('require', '".concat(name, "');"));
        }
      }
    }
  },

  /**
   * execute:
   * GA execute action for plugin
   * Takes variable number of arguments
   * @param pluginName {String} e.g. 'ecommerce' or 'myplugin'
   * @param action {String} e.g. 'addItem' or 'myCustomAction'
   * @param actionType {String} optional e.g. 'detail'
   * @param payload {Object} optional e.g { id: '1x5e', name : 'My product to track' }
   */
  execute: function execute(pluginName, action) {
    var payload;
    var actionType;

    if ((arguments.length <= 2 ? 0 : arguments.length - 2) === 1) {
      payload = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      actionType = arguments.length <= 2 ? undefined : arguments[2];
      payload = arguments.length <= 3 ? undefined : arguments[3];
    }

    if (typeof ga === 'function') {
      if (typeof pluginName !== 'string') {
        Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('Expected `pluginName` arg to be a String.');
      } else if (typeof action !== 'string') {
        Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('Expected `action` arg to be a String.');
      } else {
        var command = "".concat(pluginName, ":").concat(action);
        payload = payload || null;

        if (actionType && payload) {
          ga(command, actionType, payload);

          if (_debug) {
            Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("called ga('".concat(command, "');"));
            Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("actionType: \"".concat(actionType, "\" with payload: ").concat(JSON.stringify(payload)));
          }
        } else if (payload) {
          ga(command, payload);

          if (_debug) {
            Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("called ga('".concat(command, "');"));
            Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("with payload: ".concat(JSON.stringify(payload)));
          }
        } else {
          ga(command);

          if (_debug) {
            Object(_utils_console_log__WEBPACK_IMPORTED_MODULE_5__["default"])("called ga('".concat(command, "');"));
          }
        }
      }
    }
  }
};
/**
 * outboundLink:
 * GA outboundLink tracking
 * @param args.label {String} e.g. url, or 'Create an Account'
 * @param {function} hitCallback - Called after processing a hit.
 */

function outboundLink(args, hitCallback, trackerNames) {
  if (typeof hitCallback !== 'function') {
    Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('hitCallback function is required');
    return;
  }

  if (typeof ga === 'function') {
    // Simple Validation
    if (!args || !args.label) {
      Object(_utils_console_warn__WEBPACK_IMPORTED_MODULE_4__["default"])('args.label is required in outboundLink()');
      return;
    } // Required Fields


    var fieldObject = {
      hitType: 'event',
      eventCategory: 'Outbound',
      eventAction: 'Click',
      eventLabel: _format(args.label)
    };
    var safetyCallbackCalled = false;

    var safetyCallback = function safetyCallback() {
      // This prevents a delayed response from GA
      // causing hitCallback from being fired twice
      safetyCallbackCalled = true;
      hitCallback();
    }; // Using a timeout to ensure the execution of critical application code
    // in the case when the GA server might be down
    // or an ad blocker prevents sending the data
    // register safety net timeout:


    var t = setTimeout(safetyCallback, 250);

    var clearableCallbackForGA = function clearableCallbackForGA() {
      clearTimeout(t);

      if (!safetyCallbackCalled) {
        hitCallback();
      }
    };

    fieldObject.hitCallback = clearableCallbackForGA; // Send to GA

    send(fieldObject, trackerNames);
  } else {
    // if ga is not defined, return the callback so the application
    // continues to work as expected
    setTimeout(hitCallback, 0);
  }
}
var testModeAPI = _utils_testModeAPI__WEBPACK_IMPORTED_MODULE_6__["default"];
/* harmony default export */ __webpack_exports__["default"] = ({
  initialize: initialize,
  ga: ga,
  set: set,
  send: send,
  pageview: pageview,
  modalview: modalview,
  timing: timing,
  event: event,
  exception: exception,
  plugin: plugin,
  outboundLink: outboundLink,
  testModeAPI: _utils_testModeAPI__WEBPACK_IMPORTED_MODULE_6__["default"]
});

/***/ }),

/***/ "./node_modules/react-ga/dist/esm/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/index.js ***!
  \*************************************************/
/*! exports provided: initialize, ga, set, send, pageview, modalview, timing, event, exception, plugin, outboundLink, testModeAPI, OutboundLink, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initialize", function() { return initialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ga", function() { return ga; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "send", function() { return send; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pageview", function() { return pageview; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modalview", function() { return modalview; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timing", function() { return timing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exception", function() { return exception; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plugin", function() { return plugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outboundLink", function() { return outboundLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testModeAPI", function() { return testModeAPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OutboundLink", function() { return OutboundLink; });
/* harmony import */ var _components_OutboundLink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/OutboundLink */ "./node_modules/react-ga/dist/esm/components/OutboundLink.js");
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ "./node_modules/react-ga/dist/esm/core.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var initialize = _core__WEBPACK_IMPORTED_MODULE_1__["initialize"];
var ga = _core__WEBPACK_IMPORTED_MODULE_1__["ga"];
var set = _core__WEBPACK_IMPORTED_MODULE_1__["set"];
var send = _core__WEBPACK_IMPORTED_MODULE_1__["send"];
var pageview = _core__WEBPACK_IMPORTED_MODULE_1__["pageview"];
var modalview = _core__WEBPACK_IMPORTED_MODULE_1__["modalview"];
var timing = _core__WEBPACK_IMPORTED_MODULE_1__["timing"];
var event = _core__WEBPACK_IMPORTED_MODULE_1__["event"];
var exception = _core__WEBPACK_IMPORTED_MODULE_1__["exception"];
var plugin = _core__WEBPACK_IMPORTED_MODULE_1__["plugin"];
var outboundLink = _core__WEBPACK_IMPORTED_MODULE_1__["outboundLink"];
var testModeAPI = _core__WEBPACK_IMPORTED_MODULE_1__["testModeAPI"];
_components_OutboundLink__WEBPACK_IMPORTED_MODULE_0__["default"].origTrackLink = _components_OutboundLink__WEBPACK_IMPORTED_MODULE_0__["default"].trackLink;
_components_OutboundLink__WEBPACK_IMPORTED_MODULE_0__["default"].trackLink = _core__WEBPACK_IMPORTED_MODULE_1__["outboundLink"];
var OutboundLink = _components_OutboundLink__WEBPACK_IMPORTED_MODULE_0__["default"];
/* harmony default export */ __webpack_exports__["default"] = (_objectSpread({}, _core__WEBPACK_IMPORTED_MODULE_1__, {
  OutboundLink: OutboundLink
}));

/***/ }),

/***/ "./node_modules/react-ga/dist/esm/utils/console/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/utils/console/log.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return log; });
function log(s) {
  console.info('[react-ga]', s);
}

/***/ }),

/***/ "./node_modules/react-ga/dist/esm/utils/console/warn.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/utils/console/warn.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return warn; });
function warn(s) {
  console.warn('[react-ga]', s);
}

/***/ }),

/***/ "./node_modules/react-ga/dist/esm/utils/format.js":
/*!********************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/utils/format.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return format; });
/* harmony import */ var _mightBeEmail__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mightBeEmail */ "./node_modules/react-ga/dist/esm/utils/mightBeEmail.js");
/* harmony import */ var _toTitleCase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toTitleCase */ "./node_modules/react-ga/dist/esm/utils/toTitleCase.js");
/* harmony import */ var _console_warn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./console/warn */ "./node_modules/react-ga/dist/esm/utils/console/warn.js");



var redacted = 'REDACTED (Potential Email Address)';
function format(s, titleCase) {
  if (Object(_mightBeEmail__WEBPACK_IMPORTED_MODULE_0__["default"])(s)) {
    Object(_console_warn__WEBPACK_IMPORTED_MODULE_2__["default"])('This arg looks like an email address, redacting.');
    return redacted;
  }

  if (titleCase) {
    return Object(_toTitleCase__WEBPACK_IMPORTED_MODULE_1__["default"])(s);
  }

  return s;
}

/***/ }),

/***/ "./node_modules/react-ga/dist/esm/utils/loadGA.js":
/*!********************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/utils/loadGA.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (options) {
  var gaAddress = 'https://www.google-analytics.com/analytics.js';

  if (options && options.gaAddress) {
    gaAddress = options.gaAddress;
  } else if (options && options.debug) {
    gaAddress = 'https://www.google-analytics.com/analytics_debug.js';
  } // https://developers.google.com/analytics/devguides/collection/analyticsjs/

  /* eslint-disable */


  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments);
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(window, document, 'script', gaAddress, 'ga');
  /* eslint-enable */

});

/***/ }),

/***/ "./node_modules/react-ga/dist/esm/utils/mightBeEmail.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/utils/mightBeEmail.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mightBeEmail; });
// See if s could be an email address. We don't want to send personal data like email.
// https://support.google.com/analytics/answer/2795983?hl=en
function mightBeEmail(s) {
  // There's no point trying to validate rfc822 fully, just look for ...@...
  return typeof s === 'string' && s.indexOf('@') !== -1;
}

/***/ }),

/***/ "./node_modules/react-ga/dist/esm/utils/removeLeadingSlash.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/utils/removeLeadingSlash.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return removeLeadingSlash; });
function removeLeadingSlash(string) {
  if (string.substring(0, 1) === '/') {
    return string.substring(1);
  }

  return string;
}

/***/ }),

/***/ "./node_modules/react-ga/dist/esm/utils/testModeAPI.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/utils/testModeAPI.js ***!
  \*************************************************************/
/*! exports provided: gaCalls, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gaCalls", function() { return gaCalls; });
var gaCalls = [];
/* harmony default export */ __webpack_exports__["default"] = ({
  calls: gaCalls,
  ga: function ga() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    gaCalls.push([].concat(args));
  },
  resetCalls: function resetCalls() {
    gaCalls.length = 0;
  }
});

/***/ }),

/***/ "./node_modules/react-ga/dist/esm/utils/toTitleCase.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/utils/toTitleCase.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return toTitleCase; });
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trim */ "./node_modules/react-ga/dist/esm/utils/trim.js");
/**
 * To Title Case 2.1 - http://individed.com/code/to-title-case/
 * Copyright 2008-2013 David Gouch. Licensed under the MIT License.
 * https://github.com/gouch/to-title-case
 */

var smallWords = /^(a|an|and|as|at|but|by|en|for|if|in|nor|of|on|or|per|the|to|vs?\.?|via)$/i;
function toTitleCase(string) {
  return Object(_trim__WEBPACK_IMPORTED_MODULE_0__["default"])(string).replace(/[A-Za-z0-9\u00C0-\u00FF]+[^\s-]*/g, function (match, index, title) {
    if (index > 0 && index + match.length !== title.length && match.search(smallWords) > -1 && title.charAt(index - 2) !== ':' && (title.charAt(index + match.length) !== '-' || title.charAt(index - 1) === '-') && title.charAt(index - 1).search(/[^\s-]/) < 0) {
      return match.toLowerCase();
    }

    if (match.substr(1).search(/[A-Z]|\../) > -1) {
      return match;
    }

    return match.charAt(0).toUpperCase() + match.substr(1);
  });
}

/***/ }),

/***/ "./node_modules/react-ga/dist/esm/utils/trim.js":
/*!******************************************************!*\
  !*** ./node_modules/react-ga/dist/esm/utils/trim.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return trim; });
// GA strings need to have leading/trailing whitespace trimmed, and not all
// browsers have String.prototoype.trim().
function trim(s) {
  return s.replace(/^\s+|\s+$/g, '');
}

/***/ }),

/***/ "./node_modules/shortid/index.js":
/*!***************************************!*\
  !*** ./node_modules/shortid/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = __webpack_require__(/*! ./lib/index */ "./node_modules/shortid/lib/index.js");


/***/ }),

/***/ "./node_modules/shortid/lib/alphabet.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/alphabet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var randomFromSeed = __webpack_require__(/*! ./random/random-from-seed */ "./node_modules/shortid/lib/random/random-from-seed.js");

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

function get () {
  return alphabet || ORIGINAL;
}

module.exports = {
    get: get,
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};


/***/ }),

/***/ "./node_modules/shortid/lib/build.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/build.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var generate = __webpack_require__(/*! ./generate */ "./node_modules/shortid/lib/generate.js");
var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1567752802062;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 7;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function build(clusterWorkerId) {
    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + generate(version);
    str = str + generate(clusterWorkerId);
    if (counter > 0) {
        str = str + generate(counter);
    }
    str = str + generate(seconds);
    return str;
}

module.exports = build;


/***/ }),

/***/ "./node_modules/shortid/lib/generate.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/generate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
var random = __webpack_require__(/*! ./random/random-byte */ "./node_modules/shortid/lib/random/random-byte-browser.js");
var format = __webpack_require__(/*! nanoid/format */ "./node_modules/nanoid/format.browser.js");

function generate(number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + format(random, alphabet.get(), 1);
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

module.exports = generate;


/***/ }),

/***/ "./node_modules/shortid/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
var build = __webpack_require__(/*! ./build */ "./node_modules/shortid/lib/build.js");
var isValid = __webpack_require__(/*! ./is-valid */ "./node_modules/shortid/lib/is-valid.js");

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
var clusterWorkerId = __webpack_require__(/*! ./util/cluster-worker-id */ "./node_modules/shortid/lib/util/cluster-worker-id-browser.js") || 0;

/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}

/**
 * Generate unique id
 * Returns string id
 */
function generate() {
  return build(clusterWorkerId);
}

// Export all other functions as properties of the generate function
module.exports = generate;
module.exports.generate = generate;
module.exports.seed = seed;
module.exports.worker = worker;
module.exports.characters = characters;
module.exports.isValid = isValid;


/***/ }),

/***/ "./node_modules/shortid/lib/is-valid.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/is-valid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var nonAlphabetic = new RegExp('[^' +
      alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') +
    ']');
    return !nonAlphabetic.test(id);
}

module.exports = isShortId;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-byte-browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-byte-browser.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

var randomByte;

if (!crypto || !crypto.getRandomValues) {
    randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
            bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
    };
} else {
    randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
    };
}

module.exports = randomByte;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-from-seed.js":
/*!*************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-from-seed.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed(_seed_) {
    seed = _seed_;
}

module.exports = {
    nextValue: getNextValue,
    seed: setSeed
};


/***/ }),

/***/ "./node_modules/shortid/lib/util/cluster-worker-id-browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/shortid/lib/util/cluster-worker-id-browser.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = 0;


/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/*! exports provided: ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, ClosedSplineCurve3, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, CubeGeometry, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DirectionalLightShadow, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, Face3, Face4, FaceColors, FileLoader, FlatShading, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontFaceDirectionCCW, FrontFaceDirectionCW, FrontSide, Frustum, GammaEncoding, Geometry, GeometryUtils, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, LightShadow, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, Math, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBIntegerFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SphericalReflectionMapping, Spline, SplineCurve, SplineCurve3, SpotLight, SpotLightHelper, SpotLightShadow, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uncharted2ToneMapping, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VideoTexture, WebGLCubeRenderTarget, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, sRGBEncoding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return ACESFilmicToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function() { return AlwaysStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLightProbe", function() { return AmbientLightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return AnimationClip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationLoader", function() { return AnimationLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return AnimationMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return AnimationUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() { return ArrayCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return ArrowHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return AudioAnalyser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return AudioListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return AudioLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxesHelper", function() { return AxesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return AxisHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() { return BinaryTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return Bone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() { return BoundingBoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return Box2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return Box3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3Helper", function() { return Box3Helper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return BoxBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return BoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return BufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return CameraHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return CanvasRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return CanvasTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return CircleBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return CircleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClosedSplineCurve3", function() { return ClosedSplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return CompressedTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return ConeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return ConeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return CubeCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return CubeTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return CubeTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return CubicInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return CurvePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return CylinderBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return CylinderGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return Cylindrical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return DataTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture2DArray", function() { return DataTexture2DArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture3D", function() { return DataTexture3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return DataTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function() { return DecrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function() { return DecrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return DepthTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightShadow", function() { return DirectionalLightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return DodecahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() { return DynamicBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function() { return DynamicCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function() { return DynamicDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function() { return DynamicReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return EdgesGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() { return EdgesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return EllipseCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function() { return EqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() { return ExtrudeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face3", function() { return Face3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face4", function() { return Face4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return FileLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() { return Float32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() { return Float64Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return Fog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return FogExp2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Font", function() { return Font; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontLoader", function() { return FontLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() { return FrontFaceDirectionCCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() { return FrontFaceDirectionCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryUtils", function() { return GeometryUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function() { return GreaterEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function() { return GreaterStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return GridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return HemisphereLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightProbe", function() { return HemisphereLightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return IcosahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return ImageUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() { return ImmediateRenderObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function() { return IncrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function() { return IncrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedMesh", function() { return InstancedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() { return Int16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() { return Int32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() { return Int8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return InterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return Interpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function() { return InvertStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function() { return KeepStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return KeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return LOD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return LatheBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return LatheGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LensFlare", function() { return LensFlare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function() { return LessEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function() { return LessStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return Light; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightProbe", function() { return LightProbe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightShadow", function() { return LightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return Line3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return LineBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return LineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return LineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return LineDashedMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return LineLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinePieces", function() { return LinePieces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return LineSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineStrip", function() { return LineStrip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return LinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function() { return LinearMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function() { return LinearMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoaderUtils", function() { return LoaderUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return LoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return MaterialLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math", function() { return MathUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MathUtils", function() { return MathUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() { return MeshDistanceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() { return MeshFaceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshMatcapMaterial", function() { return MeshMatcapMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return MeshToonMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() { return MultiMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function() { return NearestMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function() { return NearestMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function() { return NeverStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function() { return NotEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return ObjectLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return ObjectSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return OctahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return OctahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return OrthographicCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PMREMGenerator", function() { return PMREMGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() { return ParametricBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return ParametricGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() { return ParticleBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() { return ParticleSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() { return ParticleSystemMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return PerspectiveCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return PlaneBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() { return PlaneHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return PointCloud; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() { return PointCloudMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return PointLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return PointsMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return PolarGridHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return PolyhedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return PositionalAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return PropertyBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return PropertyMixer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAIntegerFormat", function() { return RGBAIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return RGBA_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_BPTC_Format", function() { return RGBA_BPTC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ETC2_EAC_Format", function() { return RGBA_ETC2_EAC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBIntegerFormat", function() { return RGBIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC2_Format", function() { return RGB_ETC2_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGFormat", function() { return RGFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGIntegerFormat", function() { return RGIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return RawShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return Raycaster; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return RectAreaLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return RedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedIntegerFormat", function() { return RedIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function() { return ReplaceStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return RingBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return RingGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x10_Format", function() { return SRGB8_ALPHA8_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x5_Format", function() { return SRGB8_ALPHA8_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x6_Format", function() { return SRGB8_ALPHA8_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x8_Format", function() { return SRGB8_ALPHA8_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x10_Format", function() { return SRGB8_ALPHA8_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x12_Format", function() { return SRGB8_ALPHA8_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_4x4_Format", function() { return SRGB8_ALPHA8_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x4_Format", function() { return SRGB8_ALPHA8_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x5_Format", function() { return SRGB8_ALPHA8_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x5_Format", function() { return SRGB8_ALPHA8_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x6_Format", function() { return SRGB8_ALPHA8_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x5_Format", function() { return SRGB8_ALPHA8_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x6_Format", function() { return SRGB8_ALPHA8_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x8_Format", function() { return SRGB8_ALPHA8_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneUtils", function() { return SceneUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return ShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return ShaderLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return ShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return ShadowMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return ShapeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return ShapeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return ShapePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return ShapeUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return Skeleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return SkeletonHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return SkinnedMesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return SphereBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return SphereGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return Spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalHarmonics3", function() { return SphericalHarmonics3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() { return SphericalReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spline", function() { return Spline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return SplineCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve3", function() { return SplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return SpotLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return SpotLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightShadow", function() { return SpotLightShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return SpriteMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function() { return StaticCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function() { return StaticDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function() { return StaticReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return StereoCamera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function() { return StreamCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function() { return StreamDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function() { return StreamReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return TetrahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() { return TextBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return TextGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return TextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return TorusBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return TorusGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return TorusKnotBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return TubeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return TubeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() { return Uint16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() { return Uint32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() { return Uint8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() { return Uint8ClampedAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() { return Uncharted2ToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return Uniform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return UniformsLib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return UniformsUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function() { return VSMShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return Vector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vertex", function() { return Vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return VideoTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeRenderTarget", function() { return WebGLCubeRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMultisampleRenderTarget", function() { return WebGLMultisampleRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() { return WebGLRenderTargetCube; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return WebGLRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() { return WebGLUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return WireframeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() { return WireframeHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return XHRLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function() { return ZeroStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
// Polyfills

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, - 52 );

}

if ( Number.isInteger === undefined ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

	Number.isInteger = function ( value ) {

		return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

	};

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( 'name' in Function.prototype === false ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

		}

	} );

}

if ( Object.assign === undefined ) {

	// Missing in IE
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

	Object.assign = function ( target ) {

		if ( target === undefined || target === null ) {

			throw new TypeError( 'Cannot convert undefined or null to object' );

		}

		var output = Object( target );

		for ( var index = 1; index < arguments.length; index ++ ) {

			var source = arguments[ index ];

			if ( source !== undefined && source !== null ) {

				for ( var nextKey in source ) {

					if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

						output[ nextKey ] = source[ nextKey ];

					}

				}

			}

		}

		return output;

	};

}

var REVISION = '115';
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var ACESFilmicToneMapping = 5;

var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipMapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipMapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBIntegerFormat = 1032;
var RGBAIntegerFormat = 1033;

var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;

var ZeroStencilOp = 0;
var KeepStencilOp = 7680;
var ReplaceStencilOp = 7681;
var IncrementStencilOp = 7682;
var DecrementStencilOp = 7683;
var IncrementWrapStencilOp = 34055;
var DecrementWrapStencilOp = 34056;
var InvertStencilOp = 5386;

var NeverStencilFunc = 512;
var LessStencilFunc = 513;
var EqualStencilFunc = 514;
var LessEqualStencilFunc = 515;
var GreaterStencilFunc = 516;
var NotEqualStencilFunc = 517;
var GreaterEqualStencilFunc = 518;
var AlwaysStencilFunc = 519;

var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var StreamDrawUsage = 35040;
var StaticReadUsage = 35045;
var DynamicReadUsage = 35049;
var StreamReadUsage = 35041;
var StaticCopyUsage = 35046;
var DynamicCopyUsage = 35050;
var StreamCopyUsage = 35042;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			var array = listenerArray.slice( 0 );

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author thezwap
 */

var _lut = [];

for ( var i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

var MathUtils = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		var d0 = Math.random() * 0xffffffff | 0;
		var d1 = Math.random() * 0xffffffff | 0;
		var d2 = Math.random() * 0xffffffff | 0;
		var d3 = Math.random() * 0xffffffff | 0;
		var uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toUpperCase() here flattens concatenated strings to save heap memory space.
		return uuid.toUpperCase();

	},

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * MathUtils.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * MathUtils.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	ceilPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	},

	floorPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	},

	setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians

		var cos = Math.cos;
		var sin = Math.sin;

		var c2 = cos( b / 2 );
		var s2 = sin( b / 2 );

		var c13 = cos( ( a + c ) / 2 );
		var s13 = sin( ( a + c ) / 2 );

		var c1_3 = cos( ( a - c ) / 2 );
		var s1_3 = sin( ( a - c ) / 2 );

		var c3_1 = cos( ( c - a ) / 2 );
		var s3_1 = sin( ( c - a ) / 2 );

		if ( order === 'XYX' ) {

			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );

		} else if ( order === 'YZY' ) {

			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );

		} else if ( order === 'ZXZ' ) {

			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );

		} else if ( order === 'XZX' ) {

			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );

		} else if ( order === 'YXY' ) {

			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );

		} else if ( order === 'ZYZ' ) {

			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );

		} else {

			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );

		}

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

function Vector2( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

}

Object.defineProperties( Vector2.prototype, {

	"width": {

		get: function () {

			return this.x;

		},

		set: function ( value ) {

			this.x = value;

		}

	},

	"height": {

		get: function () {

			return this.y;

		},

		set: function ( value ) {

			this.y = value;

		}

	}

} );

Object.assign( Vector2.prototype, {

	isVector2: true,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	},

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	cross: function ( v ) {

		return this.x * v.y - this.y * v.x;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	angle: function () {

		// computes the angle in radians with respect to the positive x-axis

		var angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	manhattanDistanceTo: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3() {

	this.elements = [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix3.prototype, {

	isMatrix3: true,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	},

	setFromMatrix4: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	multiply: function ( m ) {

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		if ( throwOnDegenerate !== undefined ) {

			console.warn( "THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate." );

		}

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

		var c = Math.cos( rotation );
		var s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

	},

	scale: function ( sx, sy ) {

		var te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	},

	rotate: function ( theta ) {

		var c = Math.cos( theta );
		var s = Math.sin( theta );

		var te = this.elements;

		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	},

	translate: function ( tx, ty ) {

		var te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for ( var i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var _canvas;

var ImageUtils = {

	getDataURL: function ( image ) {

		var canvas;

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		} else if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			var context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var textureId = 0;

function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	Object.defineProperty( this, 'id', { value: textureId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : RGBAFormat;
	this.internalFormat = null;
	this.type = type !== undefined ? type : UnsignedByteType;

	this.offset = new Vector2( 0, 0 );
	this.repeat = new Vector2( 1, 1 );
	this.center = new Vector2( 0, 0 );
	this.rotation = 0;

	this.matrixAutoUpdate = true;
	this.matrix = new Matrix3();

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
	//
	// Also changing the encoding after already used by a Material will not automatically make the Material
	// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
	this.encoding = encoding !== undefined ? encoding : LinearEncoding;

	this.version = 0;
	this.onUpdate = null;

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;

Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Texture,

	isTexture: true,

	updateMatrix: function () {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	},

	toJSON: function ( meta ) {

		var isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		var output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = MathUtils.generateUUID(); // UGH

			}

			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				var url;

				if ( Array.isArray( image ) ) {

					// process array of images e.g. CubeTexture

					url = [];

					for ( var i = 0, l = image.length; i < l; i ++ ) {

						url.push( ImageUtils.getDataURL( image[ i ] ) );

					}

				} else {

					// process single image

					url = ImageUtils.getDataURL( image );

				}

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: url
				};

			}

			output.image = image.uuid;

		}

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}
					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}
					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

} );

Object.defineProperty( Texture.prototype, "needsUpdate", {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

}

Object.defineProperties( Vector4.prototype, {

	"width": {

		get: function () {

			return this.z;

		},

		set: function ( value ) {

			this.z = value;

		}

	},

	"height": {

		get: function () {

			return this.w;

		},

		set: function ( value ) {

			this.w = value;

		}

	}

} );

Object.assign( Vector4.prototype, {

	isVector4: true,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z, w = this.w;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
		                   ( m13 - m31 ) * ( m13 - m31 ) +
		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	},

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

} );

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
function WebGLRenderTarget( width, height, options ) {

	this.width = width;
	this.height = height;

	this.scissor = new Vector4( 0, 0, width, height );
	this.scissorTest = false;

	this.viewport = new Vector4( 0, 0, width, height );

	options = options || {};

	this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

	this.texture.image = {};
	this.texture.image.width = width;
	this.texture.image.height = height;

	this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
	this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

}

WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: WebGLRenderTarget,

	isWebGLRenderTarget: true,

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.texture.image.width = width;
			this.texture.image.height = height;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author Mugen87 / https://github.com/Mugen87
 * @author Matt DesLauriers / @mattdesl
 */

function WebGLMultisampleRenderTarget( width, height, options ) {

	WebGLRenderTarget.call( this, width, height, options );

	this.samples = 4;

}

WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {

	constructor: WebGLMultisampleRenderTarget,

	isWebGLMultisampleRenderTarget: true,

	copy: function ( source ) {

		WebGLRenderTarget.prototype.copy.call( this, source );

		this.samples = source.samples;

		return this;

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

}

Object.assign( Quaternion, {

	slerp: function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

} );

Object.defineProperties( Quaternion.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this._onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this._onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this._onChangeCallback();

		}

	},

	w: {

		get: function () {

			return this._w;

		},

		set: function ( value ) {

			this._w = value;
			this._onChangeCallback();

		}

	}

} );

Object.assign( Quaternion.prototype, {

	isQuaternion: true,

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var cos = Math.cos;
		var sin = Math.sin;

		var c1 = cos( x / 2 );
		var c2 = cos( y / 2 );
		var c3 = cos( z / 2 );

		var s1 = sin( x / 2 );
		var s2 = sin( y / 2 );
		var s3 = sin( z / 2 );

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	},

	setFromUnitVectors: function ( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		var EPS = 0.000001;

		var r = vFrom.dot( vTo ) + 1;

		if ( r < EPS ) {

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	},

	angleTo: function ( q ) {

		return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );

	},

	rotateTowards: function ( q, step ) {

		var angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		var t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	},

	inverse: function () {

		// quaternion is assumed to have unit length

		return this.conjugate();

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	premultiply: function ( q ) {

		return this.multiplyQuaternions( q, this );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			var s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	fromBufferAttribute: function ( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	},

	_onChange: function ( callback ) {

		this._onChangeCallback = callback;

		return this;

	},

	_onChangeCallback: function () {}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _vector = new Vector3();
var _quaternion = new Quaternion();

function Vector3( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

}

Object.assign( Vector3.prototype, {

	isVector3: true,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	},

	applyAxisAngle: function ( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	},

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyNormalMatrix: function ( m ) {

		return this.applyMatrix3( m ).normalize();

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix = qw * x + qy * z - qz * y;
		var iy = qw * y + qz * x - qx * z;
		var iz = qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function ( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	},

	unproject: function ( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	},

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	},

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	// TODO lengthSquared?

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function ( v ) {

		var denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		var scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	},

	projectOnPlane: function ( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	},

	reflect: function ( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	},

	angleTo: function ( v ) {

		var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		var theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	manhattanDistanceTo: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	},

	setFromSpherical: function ( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	},

	setFromSphericalCoords: function ( radius, phi, theta ) {

		var sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	},

	setFromCylindrical: function ( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	},

	setFromCylindricalCoords: function ( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		var e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	},

	setFromMatrix3Column: function ( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

} );

var _v1 = new Vector3();
var _m1 = new Matrix4();
var _zero = new Vector3( 0, 0, 0 );
var _one = new Vector3( 1, 1, 1 );
var _x = new Vector3();
var _y = new Vector3();
var _z = new Vector3();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {

	this.elements = [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix4.prototype, {

	isMatrix4: true,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	},

	copyPosition: function ( m ) {

		var te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	},

	extractRotation: function ( m ) {

		// this method does not support reflection matrices

		var te = this.elements;
		var me = m.elements;

		var scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
		var scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
		var scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromQuaternion: function ( q ) {

		return this.compose( _zero, q, _one );

	},

	lookAt: function ( eye, target, up ) {

		var te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	},

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	setPosition: function ( x, y, z ) {

		var te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	},

	getInverse: function ( m, throwOnDegenerate ) {

		if ( throwOnDegenerate !== undefined ) {

			console.warn( "THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate." );

		}

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,
			me = m.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeShear: function ( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		var te = this.elements;

		var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		var x2 = x + x,	y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		var sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	},

	decompose: function ( position, quaternion, scale ) {

		var te = this.elements;

		var sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		var sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		var sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		var det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		var invSX = 1 / sx;
		var invSY = 1 / sy;
		var invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	},

	makePerspective: function ( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for ( var i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

var _matrix = new Matrix4();
var _quaternion$1 = new Quaternion();

function Euler( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || Euler.DefaultOrder;

}

Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

Euler.DefaultOrder = 'XYZ';

Object.defineProperties( Euler.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this._onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this._onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this._onChangeCallback();

		}

	},

	order: {

		get: function () {

			return this._order;

		},

		set: function ( value ) {

			this._order = value;
			this._onChangeCallback();

		}

	}

} );

Object.assign( Euler.prototype, {

	isEuler: true,

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = MathUtils.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.9999999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.9999999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.9999999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.9999999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.9999999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.9999999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	},

	setFromQuaternion: function ( q, order, update ) {

		_matrix.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix, order, update );

	},

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function ( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$1.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$1, newOrder );

	},

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3( this._x, this._y, this._z );

		}

	},

	_onChange: function ( callback ) {

		this._onChangeCallback = callback;

		return this;

	},

	_onChangeCallback: function () {}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {

	this.mask = 1 | 0;

}

Object.assign( Layers.prototype, {

	set: function ( channel ) {

		this.mask = 1 << channel | 0;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel | 0;

	},

	enableAll: function () {

		this.mask = 0xffffffff | 0;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel | 0;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	},

	disableAll: function () {

		this.mask = 0;

	},

	test: function ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

} );

var _object3DId = 0;

var _v1$1 = new Vector3();
var _q1 = new Quaternion();
var _m1$1 = new Matrix4();
var _target = new Vector3();

var _position = new Vector3();
var _scale = new Vector3();
var _quaternion$2 = new Quaternion();

var _xAxis = new Vector3( 1, 0, 0 );
var _yAxis = new Vector3( 0, 1, 0 );
var _zAxis = new Vector3( 0, 0, 1 );

var _addedEvent = { type: 'added' };
var _removedEvent = { type: 'removed' };

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

function Object3D() {

	Object.defineProperty( this, 'id', { value: _object3DId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	var position = new Vector3();
	var rotation = new Euler();
	var quaternion = new Quaternion();
	var scale = new Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation._onChange( onRotationChange );
	quaternion._onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		rotation: {
			configurable: true,
			enumerable: true,
			value: rotation
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );

	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Object3D,

	isObject3D: true,

	onBeforeRender: function () {},
	onAfterRender: function () {},

	applyMatrix4: function ( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	applyQuaternion: function ( q ) {

		this.quaternion.premultiply( q );

		return this;

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function ( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	},

	rotateOnWorldAxis: function ( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	},

	rotateX: function ( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	},

	rotateY: function ( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	},

	rotateZ: function ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	},

	translateOnAxis: function ( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$1.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$1.multiplyScalar( distance ) );

		return this;

	},

	translateX: function ( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	},

	translateY: function ( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	},

	translateZ: function ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	},

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function ( vector ) {

		return vector.applyMatrix4( _m1$1.getInverse( this.matrixWorld ) );

	},

	lookAt: function ( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		var parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.inverse() );

		}

	},

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( ( object && object.isObject3D ) ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	},

	attach: function ( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1$1.getInverse( this.matrixWorld );

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		object.updateWorldMatrix( false, false );

		this.add( object );

		return this;

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		return target.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
			target = new Quaternion();

		}

		this.updateMatrixWorld( true );

		this.matrixWorld.decompose( _position, target, _scale );

		return target;

	},

	getWorldScale: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		this.matrixWorld.decompose( _position, _quaternion$2, target );

		return target;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		var e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	},

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		var parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	},

	toJSON: function ( meta ) {

		// meta is a string when called from JSON.stringify
		var isRootObject = ( meta === undefined || typeof meta === 'string' );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			var parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				var shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( var i = 0, l = shapes.length; i < l; i ++ ) {

						var shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				var uuids = [];

				for ( var i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );
			var shapes = extractFromCache( meta.shapes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene() {

	Object3D.call( this );

	this.type = 'Scene';

	this.background = null;
	this.environment = null;
	this.fog = null;

	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	}

}

Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Scene,

	isScene: true,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
		if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		return data;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

var _points = [
	new Vector3(),
	new Vector3(),
	new Vector3(),
	new Vector3(),
	new Vector3(),
	new Vector3(),
	new Vector3(),
	new Vector3()
];

var _vector$1 = new Vector3();

var _box = new Box3();

// triangle centered vertices

var _v0 = new Vector3();
var _v1$2 = new Vector3();
var _v2 = new Vector3();

// triangle edge vectors

var _f0 = new Vector3();
var _f1 = new Vector3();
var _f2 = new Vector3();

var _center = new Vector3();
var _extents = new Vector3();
var _triangleNormal = new Vector3();
var _testAxis = new Vector3();

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

}


Object.assign( Box3.prototype, {

	isBox3: true,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromArray: function ( array ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = array.length; i < l; i += 3 ) {

			var x = array[ i ];
			var y = array[ i + 1 ];
			var z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	},

	setFromBufferAttribute: function ( attribute ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			var x = attribute.getX( i );
			var y = attribute.getY( i );
			var z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function ( center, size ) {

		var halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	},

	setFromObject: function ( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	getCenter: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getCenter() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getSize() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	expandByObject: function ( object ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		var geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( geometry.boundingBox === null ) {

				geometry.computeBoundingBox();

			}

			_box.copy( geometry.boundingBox );
			_box.applyMatrix4( object.matrixWorld );

			this.union( _box );

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ] );

		}

		return this;

	},

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	},

	getParameter: function ( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getParameter() target is now required' );
			target = new Vector3();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	},

	intersectsSphere: function ( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$1 );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	},

	intersectsPlane: function ( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		var min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	},

	intersectsTriangle: function ( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0.subVectors( triangle.a, _center );
		_v1$2.subVectors( triangle.b, _center );
		_v2.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$2, _v0 );
		_f1.subVectors( _v2, _v1$2 );
		_f2.subVectors( _v0, _v2 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		var axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0, _v1$2, _v2, _extents );

	},

	clampPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .clampPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function ( point ) {

		var clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	},

	getBoundingSphere: function ( target ) {

		if ( target === undefined ) {

			console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
			//target = new Sphere(); // removed to avoid cyclic dependency

		}

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$1 ).length() * 0.5;

		return target;

	},

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function ( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

} );

function satForAxes( axes, v0, v1, v2, extents ) {

	var i, j;

	for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the seperating axis
		var r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the seperating axis
		var p0 = v0.dot( _testAxis );
		var p1 = v1.dot( _testAxis );
		var p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is seperating and we can exit
			return false;

		}

	}

	return true;

}

var _box$1 = new Box3();

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Sphere( center, radius ) {

	this.center = ( center !== undefined ) ? center : new Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

}

Object.assign( Sphere.prototype, {

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function ( points, optionalCenter ) {

		var center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$1.setFromPoints( points ).getCenter( center );

		}

		var maxRadiusSq = 0;

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	intersectsBox: function ( box ) {

		return box.intersectsSphere( this );

	},

	intersectsPlane: function ( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	},

	clampPoint: function ( point, target ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
			target = new Vector3();

		}

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	},

	getBoundingBox: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
			target = new Box3();

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

} );

var _vector$2 = new Vector3();
var _segCenter = new Vector3();
var _segDir = new Vector3();
var _diff = new Vector3();

var _edge1 = new Vector3();
var _edge2 = new Vector3();
var _normal = new Vector3();

/**
 * @author bhouston / http://clara.io
 */

function Ray( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new Vector3();
	this.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );

}

Object.assign( Ray.prototype, {

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .at() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	lookAt: function ( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	},

	recast: function ( t ) {

		this.origin.copy( this.at( t, _vector$2 ) );

		return this;

	},

	closestPointToPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		target.subVectors( point, this.origin );

		var directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function ( point ) {

		var directionDistance = _vector$2.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$2.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$2.distanceToSquared( point );

	},

	distanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		var segExtent = v0.distanceTo( v1 ) * 0.5;
		var a01 = - this.direction.dot( _segDir );
		var b0 = _diff.dot( this.direction );
		var b1 = - _diff.dot( _segDir );
		var c = _diff.lengthSq();
		var det = Math.abs( 1 - a01 * a01 );
		var s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						var invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	},

	intersectSphere: function ( sphere, target ) {

		_vector$2.subVectors( sphere.center, this.origin );
		var tca = _vector$2.dot( this.direction );
		var d2 = _vector$2.dot( _vector$2 ) - tca * tca;
		var radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		var thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		var t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		var t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	},

	intersectsSphere: function ( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	},

	intersectPlane: function ( plane, target ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	},

	intersectsPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	intersectBox: function ( box, target ) {

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	},

	intersectsBox: function ( box ) {

		return this.intersectBox( box, _vector$2 ) !== null;

	},

	intersectTriangle: function ( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		var DdN = this.direction.dot( _normal );
		var sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		var DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		var DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		var QdN = - sign * _diff.dot( _normal );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	},

	applyMatrix4: function ( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

} );

/**
 * @author bhouston / http://clara.io
 */

var _vector1 = new Vector3();
var _vector2 = new Vector3();
var _normalMatrix = new Matrix3();

function Plane( normal, constant ) {

	// normal is assumed to be normalized

	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

}

Object.assign( Plane.prototype, {

	isPlane: true,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	},

	setFromCoplanarPoints: function ( a, b, c ) {

		var normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .projectPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	},

	intersectLine: function ( line, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .intersectLine() target is now required' );
			target = new Vector3();

		}

		var direction = line.delta( _vector1 );

		var denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return undefined;

		}

		var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return undefined;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	},

	intersectsLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectsBox: function ( box ) {

		return box.intersectsPlane( this );

	},

	intersectsSphere: function ( sphere ) {

		return sphere.intersectsPlane( this );

	},

	coplanarPoint: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function ( matrix, optionalNormalMatrix ) {

		var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	},

	translate: function ( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

var _v0$1 = new Vector3();
var _v1$3 = new Vector3();
var _v2$1 = new Vector3();
var _v3 = new Vector3();

var _vab = new Vector3();
var _vac = new Vector3();
var _vbc = new Vector3();
var _vap = new Vector3();
var _vbp = new Vector3();
var _vcp = new Vector3();

function Triangle( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new Vector3();
	this.b = ( b !== undefined ) ? b : new Vector3();
	this.c = ( c !== undefined ) ? c : new Vector3();

}

Object.assign( Triangle, {

	getNormal: function ( a, b, c, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getNormal() target is now required' );
			target = new Vector3();

		}

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		var targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	},

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	getBarycoord: function ( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$1.subVectors( point, a );

		var dot00 = _v0$1.dot( _v0$1 );
		var dot01 = _v0$1.dot( _v1$3 );
		var dot02 = _v0$1.dot( _v2$1 );
		var dot11 = _v1$3.dot( _v1$3 );
		var dot12 = _v1$3.dot( _v2$1 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
			target = new Vector3();

		}

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	},

	containsPoint: function ( point, a, b, c ) {

		Triangle.getBarycoord( point, a, b, c, _v3 );

		return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );

	},

	getUV: function ( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3.x );
		target.addScaledVector( uv2, _v3.y );
		target.addScaledVector( uv3, _v3.z );

		return target;

	},

	isFrontFacing: function ( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

} );

Object.assign( Triangle.prototype, {

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	getArea: function () {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	},

	getMidpoint: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
			target = new Vector3();

		}

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	getNormal: function ( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	},

	getPlane: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getPlane() target is now required' );
			target = new Plane();

		}

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	getBarycoord: function ( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	},

	getUV: function ( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	},

	containsPoint: function ( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	isFrontFacing: function ( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	},

	intersectsBox: function ( box ) {

		return box.intersectsTriangle( this );

	},

	closestPointToPoint: function ( p, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		var a = this.a, b = this.b, c = this.c;
		var v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		var d1 = _vab.dot( _vap );
		var d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		var d3 = _vab.dot( _vbp );
		var d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		var vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		var d5 = _vab.dot( _vcp );
		var d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		var vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		var va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		var denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };

function Color( r, g, b ) {

	if ( g === undefined && b === undefined ) {

		// r is THREE.Color, hex or string
		return this.set( r );

	}

	return this.setRGB( r, g, b );

}

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

Object.assign( Color.prototype, {

	isColor: true,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setScalar: function ( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = MathUtils.euclideanModulo( h, 1 );
		s = MathUtils.clamp( s, 0, 1 );
		l = MathUtils.clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style );

		}

		return this;

	},

	setColorName: function ( style ) {

		// color keywords
		var hex = _colorKeywords[ style ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function ( gammaFactor ) {

		this.copyGammaToLinear( this, gammaFactor );

		return this;

	},

	convertLinearToGamma: function ( gammaFactor ) {

		this.copyLinearToGamma( this, gammaFactor );

		return this;

	},

	copySRGBToLinear: function ( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	},

	copyLinearToSRGB: function ( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	},

	convertSRGBToLinear: function () {

		this.copySRGBToLinear( this );

		return this;

	},

	convertLinearToSRGB: function () {

		this.copyLinearToSRGB( this );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( target ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( target === undefined ) {

			console.warn( 'THREE.Color: .getHSL() target is now required' );
			target = { h: 0, s: 0, l: 0 };

		}

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	sub: function ( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	lerpHSL: function ( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		var h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
		var s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
		var l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	},

	toJSON: function () {

		return this.getHex();

	}

} );

Color.NAMES = _colorKeywords;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Face3( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = ( color && color.isColor ) ? color : new Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

}

Object.assign( Face3.prototype, {

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

var materialId = 0;

function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;

	this.blending = NormalBlending;
	this.side = FrontSide;
	this.flatShading = false;
	this.vertexColors = false;

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = SrcAlphaFactor;
	this.blendDst = OneMinusSrcAlphaFactor;
	this.blendEquation = AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.stencilWriteMask = 0xff;
	this.stencilFunc = AlwaysStencilFunc;
	this.stencilRef = 0;
	this.stencilFuncMask = 0xff;
	this.stencilFail = KeepStencilOp;
	this.stencilZFail = KeepStencilOp;
	this.stencilZPass = KeepStencilOp;
	this.stencilWrite = false;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.shadowSide = null;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.dithering = false;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.visible = true;

	this.toneMapped = true;

	this.userData = {};

	this.version = 0;

}

Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Material,

	isMaterial: true,

	onBeforeCompile: function () {},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			// for backward compatability if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		var data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap
			data.refractionRatio = this.refractionRatio;

			if ( this.combine !== undefined ) data.combine = this.combine;
			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

		}

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.flatShading === true ) data.flatShading = this.flatShading;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.morphTargets === true ) data.morphTargets = true;
		if ( this.morphNormals === true ) data.morphNormals = true;
		if ( this.skinning === true ) data.skinning = true;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			var values = [];

			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;

		this.blending = source.blending;
		this.side = source.side;
		this.flatShading = source.flatShading;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		var srcPlanes = source.clippingPlanes,
			dstPlanes = null;

		if ( srcPlanes !== null ) {

			var n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( var i = 0; i !== n; ++ i )
				dstPlanes[ i ] = srcPlanes[ i ].clone();

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

Object.defineProperty( Material.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

}

MeshBasicMaterial.prototype = Object.create( Material.prototype );
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _vector$3 = new Vector3();

function BufferAttribute( array, itemSize, normalized ) {

	if ( Array.isArray( array ) ) {

		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

	}

	this.name = '';

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.usage = StaticDrawUsage;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

}

Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( BufferAttribute.prototype, {

	isBufferAttribute: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	applyMatrix3: function ( m ) {

		for ( var i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.applyMatrix3( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	applyMatrix4: function ( m ) {

		for ( var i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.applyMatrix4( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	applyNormalMatrix: function ( m ) {

		for ( var i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.applyNormalMatrix( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	transformDirection: function ( m ) {

		for ( var i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.transformDirection( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	clone: function () {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	},

	toJSON: function () {

		return {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call( this.array ),
			normalized: this.normalized
		};

	}

} );

//

function Int8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

}

Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


function Uint8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

}

Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

}

Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


function Int16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

}

Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


function Uint16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


function Int32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

}

Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


function Uint32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

}

Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


function Float32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

}

Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


function Float64BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

}

Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectGeometry() {

	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Object.assign( DirectGeometry.prototype, {

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex = undefined;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		var morphTargetsPosition;

		if ( morphTargetsLength > 0 ) {

			morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = {
					name: morphTargets[ i ].name,
				 	data: []
				};

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		var morphTargetsNormal;

		if ( morphNormalsLength > 0 ) {

			morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = {
					name: morphNormals[ i ].name,
				 	data: []
				};

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		if ( vertices.length > 0 && faces.length === 0 ) {

			console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

		}

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function arrayMax( array ) {

	if ( array.length === 0 ) return - Infinity;

	var max = array[ 0 ];

	for ( var i = 1, l = array.length; i < l; ++ i ) {

		if ( array[ i ] > max ) max = array[ i ];

	}

	return max;

}

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

var _m1$2 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var _box$2 = new Box3();
var _boxMorphTargets = new Box3();
var _vector$4 = new Vector3();

function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};
	this.morphTargetsRelative = false;

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

	this.userData = {};

}

BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: BufferGeometry,

	isBufferGeometry: true,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	setAttribute: function ( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	},

	deleteAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix4: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		var tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function ( angle ) {

		// rotate geometry around world x-axis

		_m1$2.makeRotationX( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	rotateY: function ( angle ) {

		// rotate geometry around world y-axis

		_m1$2.makeRotationY( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	rotateZ: function ( angle ) {

		// rotate geometry around world z-axis

		_m1$2.makeRotationZ( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	translate: function ( x, y, z ) {

		// translate geometry

		_m1$2.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	scale: function ( x, y, z ) {

		// scale geometry

		_m1$2.makeScale( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	lookAt: function ( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	},

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object.isPoints || object.isLine ) {

			var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
			var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

			this.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

				this.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object.isMesh ) {

			if ( geometry && geometry.isGeometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	setFromPoints: function ( points ) {

		var position = [];

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object.isMesh ) {

			var direct = geometry.__directGeometry;

			if ( geometry.elementsNeedUpdate === true ) {

				direct = undefined;
				geometry.elementsNeedUpdate = false;

			}

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		var attribute;

		if ( geometry.verticesNeedUpdate === true ) {

			attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

			attribute = this.attributes.uv;

			if ( attribute !== undefined ) {

				attribute.copyVector2sArray( geometry.uvs );
				attribute.needsUpdate = true;

			}

			geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
				attribute.name = morphTarget.name;

				array.push( attribute.copyVector3sArray( morphTarget.data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
			this.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
			this.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		var position = this.attributes.position;
		var morphAttributesPosition = this.morphAttributes.position;

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					var morphAttribute = morphAttributesPosition[ i ];
					_box$2.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$4.addVectors( this.boundingBox.min, _box$2.min );
						this.boundingBox.expandByPoint( _vector$4 );

						_vector$4.addVectors( this.boundingBox.max, _box$2.max );
						this.boundingBox.expandByPoint( _vector$4 );

					} else {

						this.boundingBox.expandByPoint( _box$2.min );
						this.boundingBox.expandByPoint( _box$2.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		var position = this.attributes.position;
		var morphAttributesPosition = this.morphAttributes.position;

		if ( position ) {

			// first, find the center of the bounding sphere

			var center = this.boundingSphere.center;

			_box$2.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					var morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );
						_box$2.expandByPoint( _vector$4 );

						_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );
						_box$2.expandByPoint( _vector$4 );

					} else {

						_box$2.expandByPoint( _boxMorphTargets.min );
						_box$2.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$2.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			var maxRadiusSq = 0;

			for ( var i = 0, il = position.count; i < il; i ++ ) {

				_vector$4.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					var morphAttribute = morphAttributesPosition[ i ];
					var morphTargetsRelative = this.morphTargetsRelative;

					for ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$4.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$4.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	},

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.setAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var array = attributes.normal.array;

				for ( var i = 0, il = array.length; i < il; i ++ ) {

					array[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC;
			var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			var cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				for ( var i = 0, il = index.count; i < il; i += 3 ) {

					vA = indices[ i + 0 ] * 3;
					vB = indices[ i + 1 ] * 3;
					vC = indices[ i + 2 ] * 3;

					pA.fromArray( positions, vA );
					pB.fromArray( positions, vB );
					pC.fromArray( positions, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ vA ] += cb.x;
					normals[ vA + 1 ] += cb.y;
					normals[ vA + 2 ] += cb.z;

					normals[ vB ] += cb.x;
					normals[ vB + 1 ] += cb.y;
					normals[ vB + 2 ] += cb.z;

					normals[ vC ] += cb.x;
					normals[ vC + 1 ] += cb.y;
					normals[ vC + 2 ] += cb.z;

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeOffset = attribute2.itemSize * offset;
			var length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			for ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal;

		for ( var i = 0, il = normals.count; i < il; i ++ ) {

			_vector$4.x = normals.getX( i );
			_vector$4.y = normals.getY( i );
			_vector$4.z = normals.getZ( i );

			_vector$4.normalize();

			normals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );

		}

	},

	toNonIndexed: function () {

		function convertBufferAttribute( attribute, indices ) {

			var array = attribute.array;
			var itemSize = attribute.itemSize;

			var array2 = new array.constructor( indices.length * itemSize );

			var index = 0, index2 = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( var j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
			return this;

		}

		var geometry2 = new BufferGeometry();

		var indices = this.index.array;
		var attributes = this.attributes;

		// attributes

		for ( var name in attributes ) {

			var attribute = attributes[ name ];

			var newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		var morphAttributes = this.morphAttributes;

		for ( name in morphAttributes ) {

			var morphArray = [];
			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {

				var attribute = morphAttribute[ i ];

				var newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		var groups = this.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var attributeData = attribute.toJSON();

			if ( attribute.name !== '' ) attributeData.name = attribute.name;

			data.data.attributes[ key ] = attributeData;

		}

		var morphAttributes = {};
		var hasMorphAttributes = false;

		for ( var key in this.morphAttributes ) {

			var attributeArray = this.morphAttributes[ key ];

			var array = [];

			for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

				var attribute = attributeArray[ i ];

				var attributeData = attribute.toJSON();

				if ( attribute.name !== '' ) attributeData.name = attribute.name;

				array.push( attributeData );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		var name, i, l;

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// index

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		// attributes

		var attributes = source.attributes;

		for ( name in attributes ) {

			var attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone() );

		}

		// morph attributes

		var morphAttributes = source.morphAttributes;

		for ( name in morphAttributes ) {

			var array = [];
			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone() );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		var groups = source.groups;

		for ( i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		var boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		var boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

var _inverseMatrix = new Matrix4();
var _ray = new Ray();
var _sphere = new Sphere();

var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();

var _tempA = new Vector3();
var _tempB = new Vector3();
var _tempC = new Vector3();

var _morphA = new Vector3();
var _morphB = new Vector3();
var _morphC = new Vector3();

var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();

var _intersectionPoint = new Vector3();
var _intersectionPointWorld = new Vector3();

function Mesh( geometry, material ) {

	Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new MeshBasicMaterial();

	this.updateMorphTargets();

}

Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Mesh,

	isMesh: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		return this;

	},

	updateMorphTargets: function () {

		var geometry = this.geometry;
		var m, ml, name;

		if ( geometry.isBufferGeometry ) {

			var morphAttributes = geometry.morphAttributes;
			var keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				var morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			var morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	},

	raycast: function ( raycaster, intersects ) {

		var geometry = this.geometry;
		var material = this.material;
		var matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.getInverse( matrixWorld );
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		var intersection;

		if ( geometry.isBufferGeometry ) {

			var a, b, c;
			var index = geometry.index;
			var position = geometry.attributes.position;
			var morphPosition = geometry.morphAttributes.position;
			var morphTargetsRelative = geometry.morphTargetsRelative;
			var uv = geometry.attributes.uv;
			var uv2 = geometry.attributes.uv2;
			var groups = geometry.groups;
			var drawRange = geometry.drawRange;
			var i, j, il, jl;
			var group, groupMaterial;
			var start, end;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( i = 0, il = groups.length; i < il; i ++ ) {

						group = groups[ i ];
						groupMaterial = material[ group.materialIndex ];

						start = Math.max( group.start, drawRange.start );
						end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( j = start, jl = end; j < jl; j += 3 ) {

							a = index.getX( j );
							b = index.getX( j + 1 );
							c = index.getX( j + 2 );

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					start = Math.max( 0, drawRange.start );
					end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( i = start, il = end; i < il; i += 3 ) {

						a = index.getX( i );
						b = index.getX( i + 1 );
						c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( i = 0, il = groups.length; i < il; i ++ ) {

						group = groups[ i ];
						groupMaterial = material[ group.materialIndex ];

						start = Math.max( group.start, drawRange.start );
						end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( j = start, jl = end; j < jl; j += 3 ) {

							a = j;
							b = j + 1;
							c = j + 2;

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					start = Math.max( 0, drawRange.start );
					end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( i = start, il = end; i < il; i += 3 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		} else if ( geometry.isGeometry ) {

			var fvA, fvB, fvC;
			var isMultiMaterial = Array.isArray( material );

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var uvs;

			var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
			if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

			for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

				var face = faces[ f ];
				var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

				if ( faceMaterial === undefined ) continue;

				fvA = vertices[ face.a ];
				fvB = vertices[ face.b ];
				fvC = vertices[ face.c ];

				intersection = checkIntersection( this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint );

				if ( intersection ) {

					if ( uvs && uvs[ f ] ) {

						var uvs_f = uvs[ f ];
						_uvA.copy( uvs_f[ 0 ] );
						_uvB.copy( uvs_f[ 1 ] );
						_uvC.copy( uvs_f[ 2 ] );

						intersection.uv = Triangle.getUV( _intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2() );

					}

					intersection.face = face;
					intersection.faceIndex = f;
					intersects.push( intersection );

				}

			}

		}

	},

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	var intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	_vA.fromBufferAttribute( position, a );
	_vB.fromBufferAttribute( position, b );
	_vC.fromBufferAttribute( position, c );

	var morphInfluences = object.morphTargetInfluences;

	if ( material.morphTargets && morphPosition && morphInfluences ) {

		_morphA.set( 0, 0, 0 );
		_morphB.set( 0, 0, 0 );
		_morphC.set( 0, 0, 0 );

		for ( var i = 0, il = morphPosition.length; i < il; i ++ ) {

			var influence = morphInfluences[ i ];
			var morphAttribute = morphPosition[ i ];

			if ( influence === 0 ) continue;

			_tempA.fromBufferAttribute( morphAttribute, a );
			_tempB.fromBufferAttribute( morphAttribute, b );
			_tempC.fromBufferAttribute( morphAttribute, c );

			if ( morphTargetsRelative ) {

				_morphA.addScaledVector( _tempA, influence );
				_morphB.addScaledVector( _tempB, influence );
				_morphC.addScaledVector( _tempC, influence );

			} else {

				_morphA.addScaledVector( _tempA.sub( _vA ), influence );
				_morphB.addScaledVector( _tempB.sub( _vB ), influence );
				_morphC.addScaledVector( _tempC.sub( _vC ), influence );

			}

		}

		_vA.add( _morphA );
		_vB.add( _morphB );
		_vC.add( _morphC );

	}

	var intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA.fromBufferAttribute( uv, a );
			_uvB.fromBufferAttribute( uv, b );
			_uvC.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

		}

		if ( uv2 ) {

			_uvA.fromBufferAttribute( uv2, a );
			_uvB.fromBufferAttribute( uv2, b );
			_uvC.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

		}

		var face = new Face3( a, b, c );
		Triangle.getNormal( _vA, _vB, _vC, face.normal );

		intersection.face = face;

	}

	return intersection;

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

var _geometryId = 0; // Geometry uses even numbers as Id
var _m1$3 = new Matrix4();
var _obj$1 = new Object3D();
var _offset$1 = new Vector3();

function Geometry() {

	Object.defineProperty( this, 'id', { value: _geometryId += 2 } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.elementsNeedUpdate = false;
	this.verticesNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Geometry,

	isGeometry: true,

	applyMatrix4: function ( matrix ) {

		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

		return this;

	},

	rotateX: function ( angle ) {

		// rotate geometry around world x-axis

		_m1$3.makeRotationX( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	rotateY: function ( angle ) {

		// rotate geometry around world y-axis

		_m1$3.makeRotationY( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	rotateZ: function ( angle ) {

		// rotate geometry around world z-axis

		_m1$3.makeRotationZ( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	translate: function ( x, y, z ) {

		// translate geometry

		_m1$3.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	scale: function ( x, y, z ) {

		// scale geometry

		_m1$3.makeScale( x, y, z );

		this.applyMatrix4( _m1$3 );

		return this;

	},

	lookAt: function ( vector ) {

		_obj$1.lookAt( vector );

		_obj$1.updateMatrix();

		this.applyMatrix4( _obj$1.matrix );

		return this;

	},

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		if ( attributes.position === undefined ) {

			console.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );
			return this;

		}

		var positions = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		for ( var i = 0; i < positions.length; i += 3 ) {

			scope.vertices.push( new Vector3().fromArray( positions, i ) );

			if ( colors !== undefined ) {

				scope.colors.push( new Color().fromArray( colors, i ) );

			}

		}

		function addFace( a, b, c, materialIndex ) {

			var vertexColors = ( colors === undefined ) ? [] : [
				scope.colors[ a ].clone(),
				scope.colors[ b ].clone(),
				scope.colors[ c ].clone() ];

			var vertexNormals = ( normals === undefined ) ? [] : [
				new Vector3().fromArray( normals, a * 3 ),
				new Vector3().fromArray( normals, b * 3 ),
				new Vector3().fromArray( normals, c * 3 )
			];

			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [
					new Vector2().fromArray( uvs, a * 2 ),
					new Vector2().fromArray( uvs, b * 2 ),
					new Vector2().fromArray( uvs, c * 2 )
				] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [
					new Vector2().fromArray( uvs2, a * 2 ),
					new Vector2().fromArray( uvs2, b * 2 ),
					new Vector2().fromArray( uvs2, c * 2 )
				] );

			}

		}

		var groups = geometry.groups;

		if ( groups.length > 0 ) {

			for ( var i = 0; i < groups.length; i ++ ) {

				var group = groups[ i ];

				var start = group.start;
				var count = group.count;

				for ( var j = start, jl = start + count; j < jl; j += 3 ) {

					if ( indices !== undefined ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

					} else {

						addFace( j, j + 1, j + 2, group.materialIndex );

					}

				}

			}

		} else {

			if ( indices !== undefined ) {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			} else {

				for ( var i = 0; i < positions.length / 3; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset$1 ).negate();

		this.translate( _offset$1.x, _offset$1.y, _offset$1.z );

		return this;

	},

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix4( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new Vector3(), ab = new Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		if ( areaWeighted === undefined ) areaWeighted = true;

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new Vector3(), ab = new Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeFlatVertexNormals: function () {

		var f, fl, face;

		this.computeFaceNormals();

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( face.normal );
				vertexNormals[ 1 ].copy( face.normal );
				vertexNormals[ 2 ].copy( face.normal );

			} else {

				vertexNormals[ 0 ] = face.normal.clone();
				vertexNormals[ 1 ] = face.normal.clone();
				vertexNormals[ 2 ] = face.normal.clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new Vector3();
					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( ! ( geometry && geometry.isGeometry ) ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			colors1 = this.colors,
			colors2 = geometry.colors;

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// colors

		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

			colors1.push( colors2[ i ].clone() );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( var i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs2 = geometry.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];

			for ( var j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {

				var uvs2 = faceVertexUvs2[ j ], uvsCopy = [];

				for ( var k = 0, kl = uvs2.length; k < kl; k ++ ) {

					uvsCopy.push( uvs2[ k ].clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

	},

	mergeMesh: function ( mesh ) {

		if ( ! ( mesh && mesh.isMesh ) ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	setFromPoints: function ( points ) {

		this.vertices = [];

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

		}

		return this;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = true;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 ); // isQuad
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );
			faces.push( face.materialIndex );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new Geometry().copy( this );

	},

	copy: function ( source ) {

		var i, il, j, jl, k, kl;

		// reset

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
		this.morphTargets = [];
		this.morphNormals = [];
		this.skinWeights = [];
		this.skinIndices = [];
		this.lineDistances = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// name

		this.name = source.name;

		// vertices

		var vertices = source.vertices;

		for ( i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		// colors

		var colors = source.colors;

		for ( i = 0, il = colors.length; i < il; i ++ ) {

			this.colors.push( colors[ i ].clone() );

		}

		// faces

		var faces = source.faces;

		for ( i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		// face vertex uvs

		for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		// morph targets

		var morphTargets = source.morphTargets;

		for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = {};
			morphTarget.name = morphTargets[ i ].name;

			// vertices

			if ( morphTargets[ i ].vertices !== undefined ) {

				morphTarget.vertices = [];

				for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

				}

			}

			// normals

			if ( morphTargets[ i ].normals !== undefined ) {

				morphTarget.normals = [];

				for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

				}

			}

			this.morphTargets.push( morphTarget );

		}

		// morph normals

		var morphNormals = source.morphNormals;

		for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

			var morphNormal = {};

			// vertex normals

			if ( morphNormals[ i ].vertexNormals !== undefined ) {

				morphNormal.vertexNormals = [];

				for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

					var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
					var destVertexNormal = {};

					destVertexNormal.a = srcVertexNormal.a.clone();
					destVertexNormal.b = srcVertexNormal.b.clone();
					destVertexNormal.c = srcVertexNormal.c.clone();

					morphNormal.vertexNormals.push( destVertexNormal );

				}

			}

			// face normals

			if ( morphNormals[ i ].faceNormals !== undefined ) {

				morphNormal.faceNormals = [];

				for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

				}

			}

			this.morphNormals.push( morphNormal );

		}

		// skin weights

		var skinWeights = source.skinWeights;

		for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

			this.skinWeights.push( skinWeights[ i ].clone() );

		}

		// skin indices

		var skinIndices = source.skinIndices;

		for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

			this.skinIndices.push( skinIndices[ i ].clone() );

		}

		// line distances

		var lineDistances = source.lineDistances;

		for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

			this.lineDistances.push( lineDistances[ i ] );

		}

		// bounding box

		var boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		var boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// update flags

		this.elementsNeedUpdate = source.elementsNeedUpdate;
		this.verticesNeedUpdate = source.verticesNeedUpdate;
		this.uvsNeedUpdate = source.uvsNeedUpdate;
		this.normalsNeedUpdate = source.normalsNeedUpdate;
		this.colorsNeedUpdate = source.colorsNeedUpdate;
		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
		this.groupsNeedUpdate = source.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// BoxGeometry

class BoxGeometry extends Geometry {

	constructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();

	}

}

// BoxBufferGeometry

class BoxBufferGeometry extends BufferGeometry {

	constructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		super();

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		var scope = this;

		width = width || 1;
		height = height || 1;
		depth = depth || 1;

		// segments

		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var numberOfVertices = 0;
		var groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			var segmentWidth = width / gridX;
			var segmentHeight = height / gridY;

			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var vertexCounter = 0;
			var groupCount = 0;

			var ix, iy;

			var vector = new Vector3();

			// generate vertices, normals and uvs

			for ( iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segmentHeight - heightHalf;

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	var dst = {};

	for ( var u in src ) {

		dst[ u ] = {};

		for ( var p in src[ u ] ) {

			var property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	var merged = {};

	for ( var u = 0; u < uniforms.length; u ++ ) {

		var tmp = cloneUniforms( uniforms[ u ] );

		for ( var p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

// Legacy

var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = default_vertex;
	this.fragmentShader = default_fragment;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;
	this.uniformsNeedUpdate = false;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

}

ShaderMaterial.prototype = Object.create( Material.prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = cloneUniforms( source.uniforms );

	this.defines = Object.assign( {}, source.defines );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = source.extensions;

	return this;

};

ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = Material.prototype.toJSON.call( this, meta );

	data.uniforms = {};

	for ( var name in this.uniforms ) {

		var uniform = this.uniforms[ name ];
		var value = uniform.value;

		if ( value && value.isTexture ) {

			data.uniforms[ name ] = {
				type: 't',
				value: value.toJSON( meta ).uuid
			};

		} else if ( value && value.isColor ) {

			data.uniforms[ name ] = {
				type: 'c',
				value: value.getHex()
			};

		} else if ( value && value.isVector2 ) {

			data.uniforms[ name ] = {
				type: 'v2',
				value: value.toArray()
			};

		} else if ( value && value.isVector3 ) {

			data.uniforms[ name ] = {
				type: 'v3',
				value: value.toArray()
			};

		} else if ( value && value.isVector4 ) {

			data.uniforms[ name ] = {
				type: 'v4',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix3 ) {

			data.uniforms[ name ] = {
				type: 'm3',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix4 ) {

			data.uniforms[ name ] = {
				type: 'm4',
				value: value.toArray()
			};

		} else {

			data.uniforms[ name ] = {
				value: value
			};

			// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

		}

	}

	if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	var extensions = {};

	for ( var key in this.extensions ) {

		if ( this.extensions[ key ] === true ) extensions[ key ] = true;

	}

	if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

	return data;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

function Camera() {

	Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new Matrix4();

	this.projectionMatrix = new Matrix4();
	this.projectionMatrixInverse = new Matrix4();

}

Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Camera,

	isCamera: true,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
			target = new Vector3();

		}

		this.updateMatrixWorld( true );

		var e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	},

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		this.matrixWorldInverse.getInverse( this.matrixWorld );

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

		this.matrixWorldInverse.getInverse( this.matrixWorld );

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera( fov, aspect, near, far ) {

	Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov !== undefined ? fov : 50;
	this.zoom = 1;

	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;
	this.focus = 10;

	this.aspect = aspect !== undefined ? aspect : 1;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

}

PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: PerspectiveCamera,

	isPerspectiveCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		// see http://www.bobatkins.com/photography/technical/field_of_view.html
		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		var vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return MathUtils.RAD2DEG * 2 * Math.atan(
			Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var near = this.near,
			top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom,
			height = 2 * top,
			width = this.aspect * height,
			left = - 0.5 * width,
			view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			var fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		var skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.getInverse( this.projectionMatrix );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

var fov = 90, aspect = 1;

function CubeCamera( near, far, cubeResolution, options ) {

	Object3D.call( this );

	this.type = 'CubeCamera';

	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

	this.renderTarget = new WebGLCubeRenderTarget( cubeResolution, options );
	this.renderTarget.texture.name = "CubeCamera";

	this.update = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		var currentRenderTarget = renderer.getRenderTarget();

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0 );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1 );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2 );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3 );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4 );
		renderer.render( scene, cameraPZ );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5 );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget );

	};

	this.clear = function ( renderer, color, depth, stencil ) {

		var currentRenderTarget = renderer.getRenderTarget();

		var renderTarget = this.renderTarget;

		for ( var i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( renderTarget, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	};

}

CubeCamera.prototype = Object.create( Object3D.prototype );
CubeCamera.prototype.constructor = CubeCamera;

/**
 * @author alteredq / http://alteredqualia.com
 * @author WestLangley / http://github.com/WestLangley
 */

function WebGLCubeRenderTarget( size, options, dummy ) {

	if ( Number.isInteger( options ) ) {

		console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

		options = dummy;

	}

	WebGLRenderTarget.call( this, size, size, options );

}

WebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype );
WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;

WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( renderer, texture ) {

	this.texture.type = texture.type;
	this.texture.format = texture.format;
	this.texture.encoding = texture.encoding;

	var scene = new Scene();

	var shader = {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: [

			"varying vec3 vWorldDirection;",

			"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",

			"	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",

			"}",

			"void main() {",

			"	vWorldDirection = transformDirection( position, modelMatrix );",

			"	#include <begin_vertex>",
			"	#include <project_vertex>",

			"}"

		].join( '\n' ),

		fragmentShader: [

			"uniform sampler2D tEquirect;",

			"varying vec3 vWorldDirection;",

			"#define RECIPROCAL_PI 0.31830988618",
			"#define RECIPROCAL_PI2 0.15915494",

			"void main() {",

			"	vec3 direction = normalize( vWorldDirection );",

			"	vec2 sampleUV;",

			"	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;",

			"	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",

			"	gl_FragColor = texture2D( tEquirect, sampleUV );",

			"}"

		].join( '\n' ),
	};

	var material = new ShaderMaterial( {

		type: 'CubemapFromEquirect',

		uniforms: cloneUniforms( shader.uniforms ),
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader,
		side: BackSide,
		blending: NoBlending

	} );

	material.uniforms.tEquirect.value = texture;

	var mesh = new Mesh( new BoxBufferGeometry( 5, 5, 5 ), material );

	scene.add( mesh );

	var camera = new CubeCamera( 1, 10, 1 );

	camera.renderTarget = this;
	camera.renderTarget.texture.name = 'CubeCameraTexture';

	camera.update( renderer, scene );

	mesh.geometry.dispose();
	mesh.material.dispose();

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { data: data || null, width: width || 1, height: height || 1 };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.generateMipmaps = false;
	this.flipY = false;
	this.unpackAlignment = 1;

	this.needsUpdate = true;

}

DataTexture.prototype = Object.create( Texture.prototype );
DataTexture.prototype.constructor = DataTexture;

DataTexture.prototype.isDataTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

var _sphere$1 = new Sphere();
var _vector$5 = new Vector3();

function Frustum( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new Plane(),
		( p1 !== undefined ) ? p1 : new Plane(),
		( p2 !== undefined ) ? p2 : new Plane(),
		( p3 !== undefined ) ? p3 : new Plane(),
		( p4 !== undefined ) ? p4 : new Plane(),
		( p5 !== undefined ) ? p5 : new Plane()

	];

}

Object.assign( Frustum.prototype, {

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromProjectionMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function ( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$1 );

	},

	intersectsSprite: function ( sprite ) {

		_sphere$1.center.set( 0, 0, 0 );
		_sphere$1.radius = 0.7071067811865476;
		_sphere$1.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$1 );

	},

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function ( box ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			var plane = planes[ i ];

			// corner at max distance

			_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$5 ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

} );

/**
 * Uniforms library for shared webgl shaders
 */

var UniformsLib = {

	common: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: new Matrix3() },
		uv2Transform: { value: new Matrix3() },

		alphaMap: { value: null },

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 },
		maxMipLevel: { value: 0 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} }

	},

	points: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new Matrix3() }

	},

	sprite: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		center: { value: new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new Matrix3() }

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAnimation() {

	var context = null;
	var isAnimating = false;
	var animationLoop = null;

	function onAnimationFrame( time, frame ) {

		if ( isAnimating === false ) return;

		animationLoop( time, frame );

		context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAttributes( gl, capabilities ) {

	var isWebGL2 = capabilities.isWebGL2;

	var buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		var array = attribute.array;
		var usage = attribute.usage;

		var buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		var type = 5126;

		if ( array instanceof Float32Array ) {

			type = 5126;

		} else if ( array instanceof Float64Array ) {

			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		} else if ( array instanceof Uint16Array ) {

			type = 5123;

		} else if ( array instanceof Int16Array ) {

			type = 5122;

		} else if ( array instanceof Uint32Array ) {

			type = 5125;

		} else if ( array instanceof Int32Array ) {

			type = 5124;

		} else if ( array instanceof Int8Array ) {

			type = 5120;

		} else if ( array instanceof Uint8Array ) {

			type = 5121;

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		var array = attribute.array;
		var updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			if ( isWebGL2 ) {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array, updateRange.offset, updateRange.count );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			}

			updateRange.count = - 1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		var data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		var data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// PlaneGeometry

function PlaneGeometry( width, height, widthSegments, heightSegments ) {

	Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	this.mergeVertices();

}

PlaneGeometry.prototype = Object.create( Geometry.prototype );
PlaneGeometry.prototype.constructor = PlaneGeometry;

// PlaneBufferGeometry

function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

	BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	width = width || 1;
	height = height || 1;

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var ix, iy;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// generate vertices, normals and uvs

	for ( iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices.push( x, - y, 0 );

			normals.push( 0, 0, 1 );

			uvs.push( ix / gridX );
			uvs.push( 1 - ( iy / gridY ) );

		}

	}

	// indices

	for ( iy = 0; iy < gridY; iy ++ ) {

		for ( ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_frag: background_frag,
	background_vert: background_vert,
	cube_frag: cube_frag,
	cube_vert: cube_vert,
	depth_frag: depth_frag,
	depth_vert: depth_vert,
	distanceRGBA_frag: distanceRGBA_frag,
	distanceRGBA_vert: distanceRGBA_vert,
	equirect_frag: equirect_frag,
	equirect_vert: equirect_vert,
	linedashed_frag: linedashed_frag,
	linedashed_vert: linedashed_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshlambert_frag: meshlambert_frag,
	meshlambert_vert: meshlambert_vert,
	meshmatcap_frag: meshmatcap_frag,
	meshmatcap_vert: meshmatcap_vert,
	meshtoon_frag: meshtoon_frag,
	meshtoon_vert: meshtoon_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert,
	meshphysical_frag: meshphysical_frag,
	meshphysical_vert: meshphysical_vert,
	normal_frag: normal_frag,
	normal_vert: normal_vert,
	points_frag: points_frag,
	points_vert: points_vert,
	shadow_frag: shadow_frag,
	shadow_vert: shadow_vert,
	sprite_frag: sprite_frag,
	sprite_vert: sprite_vert
};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

var ShaderLib = {

	basic: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 0.5 },
				metalness: { value: 0.5 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.normal_vert,
		fragmentShader: ShaderChunk.normal_frag

	},

	sprite: {

		uniforms: mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new Matrix3() },
			t2D: { value: null },
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: mergeUniforms( [
			UniformsLib.envmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			sheen: { value: new Color( 0x000000 ) },
			transparency: { value: 0 },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

	var clearColor = new Color( 0x000000 );
	var clearAlpha = 0;

	var planeMesh;
	var boxMesh;

	var currentBackground = null;
	var currentBackgroundVersion = 0;
	var currentTonemapping = null;

	function render( renderList, scene, camera, forceClear ) {

		var background = scene.background;

		// Ignore background in AR
		// TODO: Reconsider this.

		var xr = renderer.xr;
		var session = xr.getSession && xr.getSession();

		if ( session && session.environmentBlendMode === 'additive' ) {

			background = null;

		}

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxBufferGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						type: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// enable code injection for non-built-in material
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			var texture = background.isWebGLCubeRenderTarget ? background.texture : background;

			boxMesh.material.uniforms.envMap.value = texture;
			boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? - 1 : 1;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== texture.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = texture.version;
				currentTonemapping = renderer.toneMapping;

			}

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneBufferGeometry( 2, 2 ),
					new ShaderMaterial( {
						type: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// enable code injection for non-built-in material
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}


			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha ) {

			clearColor.set( color );
			clearAlpha = alpha !== undefined ? alpha : 1;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	var isWebGL2 = capabilities.isWebGL2;

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode );

	}

	function renderInstances( geometry, start, count, primcount ) {

		if ( primcount === 0 ) return;

		var extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawArraysInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawArraysInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLCapabilities( gl, extensions, parameters ) {

	var maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension !== null ) {

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	/* eslint-disable no-undef */
	var isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
	/* eslint-enable no-undef */

	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	var maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	var maxTextures = gl.getParameter( 34930 );
	var maxVertexTextures = gl.getParameter( 35660 );
	var maxTextureSize = gl.getParameter( 3379 );
	var maxCubemapSize = gl.getParameter( 34076 );

	var maxAttributes = gl.getParameter( 34921 );
	var maxVertexUniforms = gl.getParameter( 36347 );
	var maxVaryings = gl.getParameter( 36348 );
	var maxFragmentUniforms = gl.getParameter( 36349 );

	var vertexTextures = maxVertexTextures > 0;
	var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
	var floatVertexTextures = vertexTextures && floatFragmentTextures;

	var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	return {

		isWebGL2: isWebGL2,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}

/**
 * @author tschw
 */

function WebGLClipping() {

	var scope = this,

		globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false,

		plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping, camera ) {

		var enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4,

				dstArray = cache.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

			for ( var i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			cache.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		var nPlanes = planes !== null ? planes.length : 0,
			dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				var flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLExtensions( gl ) {

	var extensions = {};

	return {

		get: function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLGeometries( gl, attributes, info ) {

	var geometries = new WeakMap();
	var wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries.get( geometry );

		if ( buffergeometry.index !== null ) {

			attributes.remove( buffergeometry.index );

		}

		for ( var name in buffergeometry.attributes ) {

			attributes.remove( buffergeometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		geometries.delete( geometry );

		var attribute = wireframeAttributes.get( buffergeometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( buffergeometry );

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		var buffergeometry = geometries.get( geometry );

		if ( buffergeometry ) return buffergeometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		if ( geometry.isBufferGeometry ) {

			buffergeometry = geometry;

		} else if ( geometry.isGeometry ) {

			if ( geometry._bufferGeometry === undefined ) {

				geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

			}

			buffergeometry = geometry._bufferGeometry;

		}

		geometries.set( geometry, buffergeometry );

		info.memory.geometries ++;

		return buffergeometry;

	}

	function update( geometry ) {

		var index = geometry.index;
		var geometryAttributes = geometry.attributes;

		if ( index !== null ) {

			attributes.update( index, 34963 );

		}

		for ( var name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], 34962 );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], 34962 );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		var indices = [];

		var geometryIndex = geometry.index;
		var geometryPosition = geometry.attributes.position;
		var version = 0;

		if ( geometryIndex !== null ) {

			var array = geometryIndex.array;
			version = geometryIndex.version;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			var array = geometryPosition.array;
			version = geometryPosition.version;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		var attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		attributes.update( attribute, 34963 );

		//

		var previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		var currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			var geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	var isWebGL2 = capabilities.isWebGL2;

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode );

	}

	function renderInstances( geometry, start, count, primcount ) {

		if ( primcount === 0 ) return;

		var extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawElementsInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawElementsInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function WebGLInfo( gl ) {

	var memory = {
		geometries: 0,
		textures: 0
	};

	var render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		instanceCount = instanceCount || 1;

		render.calls ++;

		switch ( mode ) {

			case 4:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case 1:
				render.lines += instanceCount * ( count / 2 );
				break;

			case 3:
				render.lines += instanceCount * ( count - 1 );
				break;

			case 2:
				render.lines += instanceCount * count;
				break;

			case 0:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function WebGLMorphtargets( gl ) {

	var influencesList = {};
	var morphInfluences = new Float32Array( 8 );

	function update( object, geometry, material, program ) {

		var objectInfluences = object.morphTargetInfluences;

		// When object doesn't have morph target influences defined, we treat it as a 0-length array
		// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

		var length = objectInfluences === undefined ? 0 : objectInfluences.length;

		var influences = influencesList[ geometry.id ];

		if ( influences === undefined ) {

			// initialise list

			influences = [];

			for ( var i = 0; i < length; i ++ ) {

				influences[ i ] = [ i, 0 ];

			}

			influencesList[ geometry.id ] = influences;

		}

		var morphTargets = material.morphTargets && geometry.morphAttributes.position;
		var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		// Remove current morphAttributes

		for ( var i = 0; i < length; i ++ ) {

			var influence = influences[ i ];

			if ( influence[ 1 ] !== 0 ) {

				if ( morphTargets ) geometry.deleteAttribute( 'morphTarget' + i );
				if ( morphNormals ) geometry.deleteAttribute( 'morphNormal' + i );

			}

		}

		// Collect influences

		for ( var i = 0; i < length; i ++ ) {

			var influence = influences[ i ];

			influence[ 0 ] = i;
			influence[ 1 ] = objectInfluences[ i ];

		}

		influences.sort( absNumericalSort );

		// Add morphAttributes

		var morphInfluencesSum = 0;

		for ( var i = 0; i < 8; i ++ ) {

			var influence = influences[ i ];

			if ( influence ) {

				var index = influence[ 0 ];
				var value = influence[ 1 ];

				if ( value ) {

					if ( morphTargets ) geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );
					if ( morphNormals ) geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

					morphInfluences[ i ] = value;
					morphInfluencesSum += value;
					continue;

				}

			}

			morphInfluences[ i ] = 0;

		}

		// GLSL shader uses formula baseinfluence * base + sum(target * influence)
		// This allows us to switch between absolute morphs and relative morphs without changing shader code
		// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
		var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

	}

	return {

		update: update

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLObjects( gl, geometries, attributes, info ) {

	var updateMap = new WeakMap();

	function update( object ) {

		var frame = info.render.frame;

		var geometry = object.geometry;
		var buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			if ( geometry.isGeometry ) {

				buffergeometry.updateFromObject( object );

			}

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			attributes.update( object.instanceMatrix, 34962 );

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	return {

		update: update,
		dispose: dispose

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
	format = format !== undefined ? format : RGBFormat;

	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.flipY = false;

}

CubeTexture.prototype = Object.create( Texture.prototype );
CubeTexture.prototype.constructor = CubeTexture;

CubeTexture.prototype.isCubeTexture = true;

Object.defineProperty( CubeTexture.prototype, 'images', {

	get: function () {

		return this.image;

	},

	set: function ( value ) {

		this.image = value;

	}

} );

/**
 * @author Takahiro https://github.com/takahirox
 */

function DataTexture2DArray( data, width, height, depth ) {

	Texture.call( this, null );

	this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };

	this.magFilter = NearestFilter;
	this.minFilter = NearestFilter;

	this.wrapR = ClampToEdgeWrapping;

	this.generateMipmaps = false;
	this.flipY = false;

	this.needsUpdate = true;

}

DataTexture2DArray.prototype = Object.create( Texture.prototype );
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;

/**
 * @author Artur Trzesiok
 */

function DataTexture3D( data, width, height, depth ) {

	// We're going to add .setXXX() methods for setting properties later.
	// Users can still set in DataTexture3D directly.
	//
	//	var texture = new THREE.DataTexture3D( data, width, height, depth );
	// 	texture.anisotropy = 16;
	//
	// See #14839

	Texture.call( this, null );

	this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };

	this.magFilter = NearestFilter;
	this.minFilter = NearestFilter;

	this.wrapR = ClampToEdgeWrapping;

	this.generateMipmaps = false;
	this.flipY = false;

	this.needsUpdate = true;


}

DataTexture3D.prototype = Object.create( Texture.prototype );
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;

/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

var arrayCacheF32 = [];
var arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

var mat4array = new Float32Array( 16 );
var mat3array = new Float32Array( 9 );
var mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	var firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	var n = nBlocks * blockSize,
		r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( var i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( var i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	var r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( var i = 0; i !== n; ++ i )
		r[ i ] = textures.allocateTextureUnit();

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	var cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	var cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	var cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	var cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or MatrixN)

function setValueM2( gl, v ) {

	var cache = this.cache;
	var elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	var cache = this.cache;
	var elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	var cache = this.cache;
	var elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTexture2D( v || emptyTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyTexture2dArray, unit );

}

function setValueT3D1( gl, v, textures ) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || emptyTexture3d, unit );

}

function setValueT6( gl, v, textures ) {

	var cache = this.cache;
	var unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTextureCube( v || emptyCubeTexture, unit );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)

function setValueV1i( gl, v ) {

	var cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

function setValueV2i( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3i( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4i( gl, v ) {

	var cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4iv( this.addr, v );

	copyArray( cache, v );

}

// uint

function setValueV1ui( gl, v ) {

	var cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}

// Array of scalars
function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}


// Array of vectors (flat or from THREE classes)

function setValueV2fArray( gl, v ) {

	var data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	var data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	var data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (flat or from THREE clases)

function setValueM2Array( gl, v ) {

	var data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	var data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	var data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of textures (2D / Cube)

function setValueT1Array( gl, v, textures ) {

	var n = v.length;

	var units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( var i = 0; i !== n; ++ i ) {

		textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	var n = v.length;

	var units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( var i = 0; i !== n; ++ i ) {

		textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

PureArrayUniform.prototype.updateCache = function ( data ) {

	var cache = this.cache;

	if ( data instanceof Float32Array && cache.length !== data.length ) {

		this.cache = new Float32Array( data.length );

	}

	copyArray( cache, data );

};

function StructuredUniform( id ) {

	this.id = id;

	this.seq = [];
	this.map = {};

}

StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

	var seq = this.seq;

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		u.setValue( gl, value[ u.id ], textures );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	var path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		var match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex,

			id = match[ 1 ],
			idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			var map = container.map, next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program ) {

	this.seq = [];
	this.map = {};

	var n = gl.getProgramParameter( program, 35718 );

	for ( var i = 0; i < n; ++ i ) {

		var info = gl.getActiveUniform( program, i ),
			addr = gl.getUniformLocation( program, info.name );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

	var u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, textures );

};

WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	var v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function ( gl, seq, values, textures ) {

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {

			// note: always updating when .needsUpdate is undefined
			u.setValue( gl, v.value, textures );

		}

	}

};

WebGLUniforms.seqWithValue = function ( seq, values ) {

	var r = [];

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShader( gl, type, string ) {

	var shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

var programIdCount = 0;

function addLineNumbers( string ) {

	var lines = string.split( '\n' );

	for ( var i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		case RGBEEncoding:
			return [ 'RGBE', '( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM', '( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM', '( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD', '( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		case LogLuvEncoding:
			return [ 'LogLuv', '( value )' ];
		default:
			throw new Error( 'unsupported encoding: ' + encoding );

	}

}

function getShaderErrors( gl, shader, type ) {

	var status = gl.getShaderParameter( shader, 35713 );
	var log = gl.getShaderInfoLog( shader ).trim();

	if ( status && log === '' ) return '';

	// --enable-privileged-webgl-extension
	// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	var source = gl.getShaderSource( shader );

	return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

}

function getTexelDecodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

}

function getTexelEncodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	var toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case Uncharted2ToneMapping:
			toneMappingName = 'Uncharted2';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		default:
			throw new Error( 'unsupported toneMapping: ' + toneMapping );

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( parameters ) {

	var chunks = [
		( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	var chunks = [];

	for ( var name in defines ) {

		var value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	var attributes = {};

	var n = gl.getProgramParameter( program, 35721 );

	for ( var i = 0; i < n; i ++ ) {

		var info = gl.getActiveAttrib( program, i );
		var name = info.name;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = gl.getAttribLocation( program, name );

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

function includeReplacer( match, include ) {

	var string = ShaderChunk[ include ];

	if ( string === undefined ) {

		throw new Error( 'Can not resolve #include <' + include + '>' );

	}

	return resolveIncludes( string );

}

// Unroll Loops

var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string
		.replace( unrollLoopPattern, loopReplacer )
		.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

}

function deprecatedLoopReplacer( match, start, end, snippet ) {

	console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	return loopReplacer( match, start, end, snippet );

}

function loopReplacer( match, start, end, snippet ) {

	var string = '';

	for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[ i \]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";

	if ( parameters.precision === "highp" ) {

		precisionstring += "\n#define HIGH_PRECISION";

	} else if ( parameters.precision === "mediump" ) {

		precisionstring += "\n#define MEDIUM_PRECISION";

	} else if ( parameters.precision === "lowp" ) {

		precisionstring += "\n#define LOW_PRECISION";

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

			case EquirectangularReflectionMapping:
			case EquirectangularRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
				break;

			case SphericalReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:
			case EquirectangularRefractionMapping:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function WebGLProgram( renderer, cacheKey, parameters ) {

	var gl = renderer.getContext();

	var defines = parameters.defines;

	var vertexShader = parameters.vertexShader;
	var fragmentShader = parameters.fragmentShader;
	var shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	var envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	var envMapModeDefine = generateEnvMapModeDefine( parameters );
	var envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	var customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	var customDefines = generateDefines( defines );

	var program = gl.createProgram();

	var prefixVertex, prefixFragment;

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			' attribute mat4 instanceMatrix;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#ifdef USE_COLOR',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_MORPHTARGETS',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',

			( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding ) ?
				ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.lightMapEncoding ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
			parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

			parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isWebGL2 && ! parameters.isRawShaderMaterial ) {

		var isGLSL3ShaderMaterial = false;

		var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

		if ( parameters.isShaderMaterial &&
			vertexShader.match( versionRegex ) !== null &&
			fragmentShader.match( versionRegex ) !== null ) {

			isGLSL3ShaderMaterial = true;

			vertexShader = vertexShader.replace( versionRegex, '' );
			fragmentShader = fragmentShader.replace( versionRegex, '' );

		}

		// GLSL 3.0 conversion

		prefixVertex = [
			'#version 300 es\n',
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#version 300 es\n',
			'#define varying in',
			isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
			isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	var vertexGlsl = prefixVertex + vertexShader;
	var fragmentGlsl = prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	var glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
	var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	// check for link errors
	if ( renderer.debug.checkShaderErrors ) {

		var programLog = gl.getProgramInfoLog( program ).trim();
		var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		var runnable = true;
		var haveDiagnostics = true;

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			var vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			var fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

	}

	// clean up

	gl.detachShader( program, glVertexShader );
	gl.detachShader( program, glFragmentShader );

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	var cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new WebGLUniforms( gl, program );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	var cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLPrograms( renderer, extensions, capabilities ) {

	var programs = [];

	var isWebGL2 = capabilities.isWebGL2;
	var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	var floatVertexTextures = capabilities.floatVertexTextures;
	var precision = capabilities.precision;
	var maxVertexUniforms = capabilities.maxVertexUniforms;
	var vertexTextures = capabilities.vertexTextures;

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	var parameterNames = [
		"precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing",
		"map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV",
		"lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap",
		"roughnessMap", "metalnessMap", "gradientMap",
		"alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
		"numDirLightShadows", "numPointLightShadows", "numSpotLightShadows",
		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering",
		"sheen"
	];

	function getShaderObject( material, shaderID ) {

		var shaderobject;

		if ( shaderID ) {

			var shader = ShaderLib[ shaderID ];

			shaderobject = {
				name: material.type,
				uniforms: UniformsUtils.clone( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			};

		} else {

			shaderobject = {
				name: material.type,
				uniforms: material.uniforms,
				vertexShader: material.vertexShader,
				fragmentShader: material.fragmentShader
			};

		}

		return shaderobject;

	}

	function allocateBones( object ) {

		var skeleton = object.skeleton;
		var bones = skeleton.bones;

		if ( floatVertexTextures ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = Math.min( nVertexMatrices, bones.length );

			if ( maxBones < bones.length ) {

				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map ) {

		var encoding;

		if ( ! map ) {

			encoding = LinearEncoding;

		} else if ( map.isTexture ) {

			encoding = map.encoding;

		} else if ( map.isWebGLRenderTarget ) {

			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
			encoding = map.texture.encoding;

		}

		return encoding;

	}

	this.getParameters = function ( material, lights, shadows, scene, nClipPlanes, nClipIntersection, object ) {

		var fog = scene.fog;
		var environment = material.isMeshStandardMaterial ? scene.environment : null;

		var envMap = material.envMap || environment;

		var shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var shaderobject = getShaderObject( material, shaderID );
		material.onBeforeCompile( shaderobject, renderer );

		var currentRenderTarget = renderer.getRenderTarget();

		var parameters = {

			isWebGL2: isWebGL2,

			shaderID: shaderID,
			shaderName: shaderobject.name,

			uniforms: shaderobject.uniforms,
			vertexShader: shaderobject.vertexShader,
			fragmentShader: shaderobject.fragmentShader,
			defines: material.defines,

			isRawShaderMaterial: material.isRawShaderMaterial,
			isShaderMaterial: material.isShaderMaterial,

			precision: precision,

			instancing: object.isInstancedMesh === true,

			supportsVertexTextures: vertexTextures,
			outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map ),
			matcap: !! material.matcap,
			matcapEncoding: getTextureEncodingFromMap( material.matcap ),
			envMap: !! envMap,
			envMapMode: envMap && envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( envMap ),
			envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
			clearcoatMap: !! material.clearcoatMap,
			clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
			clearcoatNormalMap: !! material.clearcoatNormalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			gradientMap: !! material.gradientMap,

			sheen: !! material.sheen,

			combine: material.combine,

			vertexTangents: ( material.normalMap && material.vertexTangents ),
			vertexColors: material.vertexColors,
			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap,
			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap ) && !! material.displacementMap,

			fog: !! fog,
			useFog: material.fog,
			fogExp2: ( fog && fog.isFogExp2 ),

			flatShading: material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: material.skinning && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: floatVertexTextures,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,

			numClippingPlanes: nClipPlanes,
			numClipIntersection: nClipIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

			index0AttributeName: material.index0AttributeName,

			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			rendererExtensionFragDepth: isWebGL2 || extensions.get( 'EXT_frag_depth' ) !== null,
			rendererExtensionDrawBuffers: isWebGL2 || extensions.get( 'WEBGL_draw_buffers' ) !== null,
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) !== null,

			onBeforeCompile: material.onBeforeCompile

		};

		return parameters;

	};

	this.getProgramCacheKey = function ( parameters ) {

		var array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.fragmentShader );
			array.push( parameters.vertexShader );

		}

		if ( parameters.defines !== undefined ) {

			for ( var name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === undefined ) {

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( renderer.outputEncoding );
			array.push( renderer.gammaFactor );

		}

		array.push( parameters.onBeforeCompile.toString() );

		return array.join();

	};

	this.acquireProgram = function ( parameters, cacheKey ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function ( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

}

/**
 * @author fordacious / fordacious.github.io
 */

function WebGLProperties() {

	var properties = new WeakMap();

	function get( object ) {

		var map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.program !== b.program ) {

		return a.program.id - b.program.id;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList() {

	var renderItems = [];
	var renderItemsIndex = 0;

	var opaque = [];
	var transparent = [];

	var defaultProgram = { id: - 1 };

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		var renderItem = renderItems[ renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: material.program || defaultProgram,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = material.program || defaultProgram;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).push( renderItem );

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).unshift( renderItem );

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( var i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			var renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.program = null;
			renderItem.group = null;

		}

	}

	return {
		opaque: opaque,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists() {

	var lists = new WeakMap();

	function onSceneDispose( event ) {

		var scene = event.target;

		scene.removeEventListener( 'dispose', onSceneDispose );

		lists.delete( scene );

	}

	function get( scene, camera ) {

		var cameras = lists.get( scene );
		var list;
		if ( cameras === undefined ) {

			list = new WebGLRenderList();
			lists.set( scene, new WeakMap() );
			lists.get( scene ).set( camera, list );

			scene.addEventListener( 'dispose', onSceneDispose );

		} else {

			list = cameras.get( camera );
			if ( list === undefined ) {

				list = new WebGLRenderList();
				cameras.set( camera, list );

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function UniformsCache() {

	var lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			var uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	var lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			var uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



var nextVersion = 0;

function shadowCastingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

}

function WebGLLights() {

	var cache = new UniformsCache();

	var shadowCache = ShadowUniformsCache();

	var state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadow: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []

	};

	for ( var i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	var vector3 = new Vector3();
	var matrix4 = new Matrix4();
	var matrix42 = new Matrix4();

	function setup( lights, shadows, camera ) {

		var r = 0, g = 0, b = 0;

		for ( var i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		var directionalLength = 0;
		var pointLength = 0;
		var spotLength = 0;
		var rectAreaLength = 0;
		var hemiLength = 0;

		var numDirectionalShadows = 0;
		var numPointShadows = 0;
		var numSpotShadows = 0;

		var viewMatrix = camera.matrixWorldInverse;

		lights.sort( shadowCastingLightsFirst );

		for ( var i = 0, l = lights.length; i < l; i ++ ) {

			var light = lights[ i ];

			var color = light.color;
			var intensity = light.intensity;
			var distance = light.distance;

			var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isLightProbe ) {

				for ( var j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

			} else if ( light.isDirectionalLight ) {

				var uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				if ( light.castShadow ) {

					var shadow = light.shadow;

					var shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				var uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					var shadow = light.shadow;

					var shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					numSpotShadows ++;

				}

				state.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				var uniforms = cache.get( light );

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				// TODO (abelnation): RectAreaLight distance?
				// uniforms.distance = distance;

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				var uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					var shadow = light.shadow;

					var shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				var uniforms = cache.get( light );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		var hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotShadowMatrix.length = numSpotShadows;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;

			state.version = nextVersion ++;

		}

	}

	return {
		setup: setup,
		state: state
	};

}

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function WebGLRenderState() {

	var lights = new WebGLLights();

	var lightsArray = [];
	var shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights( camera ) {

		lights.setup( lightsArray, shadowsArray, camera );

	}

	var state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates() {

	var renderStates = new WeakMap();

	function onSceneDispose( event ) {

		var scene = event.target;

		scene.removeEventListener( 'dispose', onSceneDispose );

		renderStates.delete( scene );

	}

	function get( scene, camera ) {

		var renderState;

		if ( renderStates.has( scene ) === false ) {

			renderState = new WebGLRenderState();
			renderStates.set( scene, new WeakMap() );
			renderStates.get( scene ).set( camera, renderState );

			scene.addEventListener( 'dispose', onSceneDispose );

		} else {

			if ( renderStates.get( scene ).has( camera ) === false ) {

				renderState = new WebGLRenderState();
				renderStates.get( scene ).set( camera, renderState );

			} else {

				renderState = renderStates.get( scene ).get( camera );

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

function MeshDepthMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.depthPacking = BasicDepthPacking;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;

	this.setValues( parameters );

}

MeshDepthMaterial.prototype = Object.create( Material.prototype );
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.depthPacking = source.depthPacking;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

function MeshDistanceMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDistanceMaterial';

	this.referencePosition = new Vector3();
	this.nearDistance = 1;
	this.farDistance = 1000;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.fog = false;

	this.setValues( parameters );

}

MeshDistanceMaterial.prototype = Object.create( Material.prototype );
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

MeshDistanceMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.referencePosition.copy( source.referencePosition );
	this.nearDistance = source.nearDistance;
	this.farDistance = source.farDistance;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	return this;

};

var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

	var _frustum = new Frustum(),

		_shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterials = [],
		_distanceMaterials = [],

		_materialCache = {};

	var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	var shadowMaterialVertical = new ShaderMaterial( {

		defines: {
			SAMPLE_RATE: 2.0 / 8.0,
			HALF_SAMPLE_RATE: 1.0 / 8.0
		},

		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vsm_vert,

		fragmentShader: vsm_frag

	} );

	var shadowMaterialHorizonal = shadowMaterialVertical.clone();
	shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;

	var fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		"position",
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	var fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		var currentRenderTarget = _renderer.getRenderTarget();
		var activeCubeFace = _renderer.getActiveCubeFace();
		var activeMipmapLevel = _renderer.getActiveMipmapLevel();

		var _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		for ( var i = 0, il = lights.length; i < il; i ++ ) {

			var light = lights[ i ];
			var shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			_shadowMapSize.copy( shadow.mapSize );

			var shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has shadow exceeding max texture size, reducing' );

				if ( _shadowMapSize.x > maxTextureSize ) {

					_viewportSize.x = Math.floor( maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > maxTextureSize ) {

					_viewportSize.y = Math.floor( maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + ".shadowMap";

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadow.camera.updateProjectionMatrix();

			}

			if ( shadow.map === null ) {

				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + ".shadowMap";

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();

			var viewportCount = shadow.getViewportCount();

			for ( var vp = 0; vp < viewportCount; vp ++ ) {

				var viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

		}

		scope.needsUpdate = false;

		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		var geometry = _objects.update( fullScreenMesh );

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.mapPass );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizonal pass

		shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.map );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null );

	}

	function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		var material = _depthMaterials[ index ];

		if ( material === undefined ) {

			material = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ index ] = material;

		}

		return material;

	}

	function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		var material = _distanceMaterials[ index ];

		if ( material === undefined ) {

			material = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ index ] = material;

		}

		return material;

	}

	function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {

		var geometry = object.geometry;

		var result = null;

		var getMaterialVariant = getDepthMaterialVariant;
		var customMaterial = object.customDepthMaterial;

		if ( light.isPointLight === true ) {

			getMaterialVariant = getDistanceMaterialVariant;
			customMaterial = object.customDistanceMaterial;

		}

		if ( customMaterial === undefined ) {

			var useMorphing = false;

			if ( material.morphTargets === true ) {

				if ( geometry.isBufferGeometry === true ) {

					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

				} else if ( geometry.isGeometry === true ) {

					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

				}

			}

			var useSkinning = false;

			if ( object.isSkinnedMesh === true ) {

				if ( material.skinning === true ) {

					useSkinning = true;

				} else {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

			}

			var useInstancing = object.isInstancedMesh === true;

			result = getMaterialVariant( useMorphing, useSkinning, useInstancing );

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			var keyA = result.uuid, keyB = material.uuid;

			var materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			var cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		var visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				var geometry = _objects.update( object );
				var material = object.material;

				if ( Array.isArray( material ) ) {

					var groups = geometry.groups;

					for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

						var group = groups[ k ];
						var groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							var depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					var depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );

					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLState( gl, extensions, capabilities ) {

	var isWebGL2 = capabilities.isWebGL2;

	function ColorBuffer() {

		var locked = false;

		var color = new Vector4();
		var currentColorMask = null;
		var currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		var locked = false;

		var currentDepthMask = null;
		var currentDepthFunc = null;
		var currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( 2929 );

				} else {

					disable( 2929 );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( 512 );
								break;

							case AlwaysDepth:

								gl.depthFunc( 519 );
								break;

							case LessDepth:

								gl.depthFunc( 513 );
								break;

							case LessEqualDepth:

								gl.depthFunc( 515 );
								break;

							case EqualDepth:

								gl.depthFunc( 514 );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( 518 );
								break;

							case GreaterDepth:

								gl.depthFunc( 516 );
								break;

							case NotEqualDepth:

								gl.depthFunc( 517 );
								break;

							default:

								gl.depthFunc( 515 );

						}

					} else {

						gl.depthFunc( 515 );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		var locked = false;

		var currentStencilMask = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilFuncMask = null;
		var currentStencilFail = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
		var currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef 	!== stencilRef 	||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail	 !== stencilFail 	||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	var colorBuffer = new ColorBuffer();
	var depthBuffer = new DepthBuffer();
	var stencilBuffer = new StencilBuffer();

	var maxVertexAttributes = gl.getParameter( 34921 );
	var newAttributes = new Uint8Array( maxVertexAttributes );
	var enabledAttributes = new Uint8Array( maxVertexAttributes );
	var attributeDivisors = new Uint8Array( maxVertexAttributes );

	var enabledCapabilities = {};

	var currentProgram = null;

	var currentBlendingEnabled = null;
	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;
	var currentPremultipledAlpha = false;

	var currentFlipSided = null;
	var currentCullFace = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var maxTextures = gl.getParameter( 35661 );

	var lineWidthAvailable = false;
	var version = 0;
	var glVersion = gl.getParameter( 7938 );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	var currentTextureSlot = null;
	var currentBoundTextures = {};

	var currentScissor = new Vector4();
	var currentViewport = new Vector4();

	function createTexture( type, target, count ) {

		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		var texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, 10241, 9728 );
		gl.texParameteri( type, 10240, 9728 );

		for ( var i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		}

		return texture;

	}

	var emptyTextures = {};
	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( 2929 );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( 2884 );

	setBlending( NoBlending );

	//

	function initAttributes() {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			var extension = isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	var equationToGL = {
		[ AddEquation ]: 32774,
		[ SubtractEquation ]: 32778,
		[ ReverseSubtractEquation ]: 32779
	};

	if ( isWebGL2 ) {

		equationToGL[ MinEquation ] = 32775;
		equationToGL[ MaxEquation ] = 32776;

	} else {

		var extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			equationToGL[ MinEquation ] = extension.MIN_EXT;
			equationToGL[ MaxEquation ] = extension.MAX_EXT;

		}

	}

	var factorToGL = {
		[ ZeroFactor ]: 0,
		[ OneFactor ]: 1,
		[ SrcColorFactor ]: 768,
		[ SrcAlphaFactor ]: 770,
		[ SrcAlphaSaturateFactor ]: 776,
		[ DstColorFactor ]: 774,
		[ DstAlphaFactor ]: 772,
		[ OneMinusSrcColorFactor ]: 769,
		[ OneMinusSrcAlphaFactor ]: 771,
		[ OneMinusDstColorFactor ]: 775,
		[ OneMinusDstAlphaFactor ]: 773
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled ) {

				disable( 3042 );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( ! currentBlendingEnabled ) {

			enable( 3042 );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( 32774 );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 1, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 1, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 0, 769, 771 );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( 0, 768, 0, 770 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 770, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 770, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFunc( 0, 769 );
							break;

						case MultiplyBlending:
							gl.blendFunc( 0, 768 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = null;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( 2884 )
			: enable( 2884 );

		var flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		var stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( 2304 );

			} else {

				gl.frontFace( 2305 );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( 2884 );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( 1029 );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( 1028 );

				} else {

					gl.cullFace( 1032 );

				}

			}

		} else {

			disable( 2884 );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( 32823 );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( 32823 );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( 3089 );

		} else {

			disable( 3089 );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentProgram = null;

		currentBlending = null;

		currentFlipSided = null;
		currentCullFace = null;

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		enableAttributeAndDivisor: enableAttributeAndDivisor,
		disableUnusedAttributes: disableUnusedAttributes,
		enable: enable,
		disable: disable,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	var isWebGL2 = capabilities.isWebGL2;
	var maxTextures = capabilities.maxTextures;
	var maxCubemapSize = capabilities.maxCubemapSize;
	var maxTextureSize = capabilities.maxTextureSize;
	var maxSamples = capabilities.maxSamples;

	var _videoTextures = new WeakMap();
	var _canvas;

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	var useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			&& ( new OffscreenCanvas( 1, 1 ).getContext( "2d" ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			new OffscreenCanvas( width, height ) :
			document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

	}

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		var scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

				var width = floor( scale * image.width );
				var height = floor( scale * image.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				var canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( isWebGL2 ) return false;

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target, texture, width, height ) {

		_gl.generateMipmap( target );

		var textureProperties = properties.get( texture );

		// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
		textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

	}

	function getInternalFormat( internalFormatName, glFormat, glType ) {

		if ( isWebGL2 === false ) return glFormat;

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		var internalFormat = glFormat;

		if ( glFormat === 6403 ) {

			if ( glType === 5126 ) internalFormat = 33326;
			if ( glType === 5131 ) internalFormat = 33325;
			if ( glType === 5121 ) internalFormat = 33321;

		}

		if ( glFormat === 6407 ) {

			if ( glType === 5126 ) internalFormat = 34837;
			if ( glType === 5131 ) internalFormat = 34843;
			if ( glType === 5121 ) internalFormat = 32849;

		}

		if ( glFormat === 6408 ) {

			if ( glType === 5126 ) internalFormat = 34836;
			if ( glType === 5131 ) internalFormat = 34842;
			if ( glType === 5121 ) internalFormat = 32856;

		}

		if ( internalFormat === 33325 || internalFormat === 33326 ||
			internalFormat === 34842 || internalFormat === 34836 ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return 9728;

		}

		return 9729;

	}

	//

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

		info.memory.textures --;

	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		info.memory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		_gl.deleteTexture( textureProperties.__webglTexture );

		properties.remove( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
			if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		properties.remove( renderTarget.texture );
		properties.remove( renderTarget );

	}

	//

	var textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		var textureUnit = textureUnits;

		if ( textureUnit >= maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	//

	function setTexture2D( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 3553, textureProperties.__webglTexture );

	}

	function setTexture2DArray( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 35866, textureProperties.__webglTexture );

	}

	function setTexture3D( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 32879, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			initTexture( textureProperties, texture );

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, textureProperties.__webglTexture );

			_gl.pixelStorei( 37440, texture.flipY );

			var isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
			var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			var cubeImage = [];

			for ( var i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

			}

			var image = cubeImage[ 0 ],
				supportsMips = isPowerOfTwo( image ) || isWebGL2,
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			setTextureParameters( 34067, texture, supportsMips );

			var mipmaps;

			if ( isCompressed ) {

				for ( var i = 0; i < 6; i ++ ) {

					mipmaps = cubeImage[ i ].mipmaps;

					for ( var j = 0; j < mipmaps.length; j ++ ) {

						var mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

							if ( glFormat !== null ) {

								state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				mipmaps = texture.mipmaps;

				for ( var i = 0; i < 6; i ++ ) {

					if ( isDataTexture ) {

						state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						for ( var j = 0; j < mipmaps.length; j ++ ) {

							var mipmap = mipmaps[ j ];
							var mipmapImage = mipmap.image[ i ].image;

							state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

						}

					} else {

						state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						for ( var j = 0; j < mipmaps.length; j ++ ) {

							var mipmap = mipmaps[ j ];

							state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length;

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( 34067, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		} else {

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, textureProperties.__webglTexture );

		}

	}

	function setTextureCubeDynamic( texture, slot ) {

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, properties.get( texture ).__webglTexture );

	}

	var wrappingToGL = {
		[ RepeatWrapping ]: 10497,
		[ ClampToEdgeWrapping ]: 33071,
		[ MirroredRepeatWrapping ]: 33648
	};

	var filterToGL = {
		[ NearestFilter ]: 9728,
		[ NearestMipmapNearestFilter ]: 9984,
		[ NearestMipmapLinearFilter ]: 9986,

		[ LinearFilter ]: 9729,
		[ LinearMipmapNearestFilter ]: 9985,
		[ LinearMipmapLinearFilter ]: 9987
	};

	function setTextureParameters( textureType, texture, supportsMips ) {

		if ( supportsMips ) {

			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		} else {

			_gl.texParameteri( textureType, 10242, 33071 );
			_gl.texParameteri( textureType, 10243, 33071 );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, 33071 );

			}

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === HalfFloatType && ( isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		var textureType = 3553;

		if ( texture.isDataTexture2DArray ) textureType = 35866;
		if ( texture.isDataTexture3D ) textureType = 32879;

		initTexture( textureProperties, texture );

		state.activeTexture( 33984 + slot );
		state.bindTexture( textureType, textureProperties.__webglTexture );

		_gl.pixelStorei( 37440, texture.flipY );
		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
		_gl.pixelStorei( 3317, texture.unpackAlignment );

		var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
		var image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

		var supportsMips = isPowerOfTwo( image ) || isWebGL2,
			glFormat = utils.convert( texture.format ),
			glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		setTextureParameters( textureType, texture, supportsMips );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			glInternalFormat = 6402;

			if ( isWebGL2 ) {

				if ( texture.type === FloatType ) {

					glInternalFormat = 36012;

				} else if ( texture.type === UnsignedIntType ) {

					glInternalFormat = 33190;

				} else if ( texture.type === UnsignedInt248Type ) {

					glInternalFormat = 35056;

				} else {

					glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

				}

			} else {

				if ( texture.type === FloatType ) {

					console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

				}

			}

			// validation checks for WebGL 1

			if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = UnsignedShortType;
					glType = utils.convert( texture.type );

				}

			}

			if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				glInternalFormat = 34041;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedInt248Type ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = UnsignedInt248Type;
					glType = utils.convert( texture.type );

				}

			}

			//

			state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			}

		} else if ( texture.isCompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					if ( glFormat !== null ) {

						state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

					}

				} else {

					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else if ( texture.isDataTexture2DArray ) {

			state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else if ( texture.isDataTexture3D ) {

			state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
				textureProperties.__maxMipLevel = 0;

			}

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			generateMipmap( textureType, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

		var glFormat = utils.convert( renderTarget.texture.format );
		var glType = utils.convert( renderTarget.texture.type );
		var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
		state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
		_gl.bindFramebuffer( 36160, framebuffer );
		_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( 36160, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( 36161, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			var glInternalFormat = 33189;

			if ( isMultisample ) {

				var depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					}

				}

				var samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			if ( isMultisample ) {

				var samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		} else {

			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );

			if ( isMultisample ) {

				var samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

		}

		_gl.bindRenderbuffer( 36161, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		var isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		_gl.bindFramebuffer( 36160, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );

		var isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		_gl.bindFramebuffer( 36160, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();

		info.memory.textures ++;

		var isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
		var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		// Handles WebGL2 RGBFormat fallback - #18858

		if ( isWebGL2 && renderTarget.texture.format === RGBFormat && ( renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType ) ) {

			renderTarget.texture.format = RGBAFormat;

			console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

		}

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( var i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultisample ) {

				if ( isWebGL2 ) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

					var glFormat = utils.convert( renderTarget.texture.format );
					var glType = utils.convert( renderTarget.texture.type );
					var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
					var samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
					_gl.bindRenderbuffer( 36161, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					_gl.bindFramebuffer( 36160, null );


				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( 34067, textureProperties.__webglTexture );
			setTextureParameters( 34067, renderTarget.texture, supportsMips );

			for ( var i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );

			}

			if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

				generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( 34067, null );

		} else {

			state.bindTexture( 3553, textureProperties.__webglTexture );
			setTextureParameters( 3553, renderTarget.texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );

			if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

				generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( 3553, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		var texture = renderTarget.texture;
		var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
			var webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			generateMipmap( target, texture, renderTarget.width, renderTarget.height );
			state.bindTexture( target, null );

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.isWebGLMultisampleRenderTarget ) {

			if ( isWebGL2 ) {

				var renderTargetProperties = properties.get( renderTarget );

				_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
				_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

				var width = renderTarget.width;
				var height = renderTarget.height;
				var mask = 16384;

				if ( renderTarget.depthBuffer ) mask |= 256;
				if ( renderTarget.stencilBuffer ) mask |= 1024;

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905

			} else {

				console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
			Math.min( maxSamples, renderTarget.samples ) : 0;

	}

	function updateVideoTexture( texture ) {

		var frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	// backwards compatibility

	var warnedTexture2D = false;
	var warnedTextureCube = false;

	function safeSetTexture2D( texture, slot ) {

		if ( texture && texture.isWebGLRenderTarget ) {

			if ( warnedTexture2D === false ) {

				console.warn( "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead." );
				warnedTexture2D = true;

			}

			texture = texture.texture;

		}

		setTexture2D( texture, slot );

	}

	function safeSetTextureCube( texture, slot ) {

		if ( texture && texture.isWebGLCubeRenderTarget ) {

			if ( warnedTextureCube === false ) {

				console.warn( "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
				warnedTextureCube = true;

			}

			texture = texture.texture;

		}

		// currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
		// TODO: unify these code paths
		if ( ( texture && texture.isCubeTexture ) ||
			( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

			// CompressedTexture can have Array in image :/

			// this function alone should take care of cube textures
			setTextureCube( texture, slot );

		} else {

			// assumed: texture property of THREE.WebGLCubeRenderTarget
			setTextureCubeDynamic( texture, slot );

		}

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.setTextureCubeDynamic = setTextureCubeDynamic;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

	this.safeSetTexture2D = safeSetTexture2D;
	this.safeSetTextureCube = safeSetTextureCube;

}

/**
 * @author thespite / http://www.twitter.com/thespite
 */

function WebGLUtils( gl, extensions, capabilities ) {

	var isWebGL2 = capabilities.isWebGL2;

	function convert( p ) {

		var extension;

		if ( p === UnsignedByteType ) return 5121;
		if ( p === UnsignedShort4444Type ) return 32819;
		if ( p === UnsignedShort5551Type ) return 32820;
		if ( p === UnsignedShort565Type ) return 33635;

		if ( p === ByteType ) return 5120;
		if ( p === ShortType ) return 5122;
		if ( p === UnsignedShortType ) return 5123;
		if ( p === IntType ) return 5124;
		if ( p === UnsignedIntType ) return 5125;
		if ( p === FloatType ) return 5126;

		if ( p === HalfFloatType ) {

			if ( isWebGL2 ) return 5131;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				return extension.HALF_FLOAT_OES;

			} else {

				return null;

			}

		}

		if ( p === AlphaFormat ) return 6406;
		if ( p === RGBFormat ) return 6407;
		if ( p === RGBAFormat ) return 6408;
		if ( p === LuminanceFormat ) return 6409;
		if ( p === LuminanceAlphaFormat ) return 6410;
		if ( p === DepthFormat ) return 6402;
		if ( p === DepthStencilFormat ) return 34041;
		if ( p === RedFormat ) return 6403;

		// WebGL2 formats.

		if ( p === RedIntegerFormat ) return 36244;
		if ( p === RGFormat ) return 33319;
		if ( p === RGIntegerFormat ) return 33320;
		if ( p === RGBIntegerFormat ) return 36248;
		if ( p === RGBAIntegerFormat ) return 36249;

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			} else {

				return null;

			}

		}

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) {

				return extension.COMPRESSED_RGB_ETC1_WEBGL;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

			}

		}

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
			p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
			p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
			p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
			p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
			p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === UnsignedInt248Type ) {

			if ( isWebGL2 ) return 34042;

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) {

				return extension.UNSIGNED_INT_24_8_WEBGL;

			} else {

				return null;

			}

		}

	}

	return { convert: convert };

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ArrayCamera( array ) {

	PerspectiveCamera.call( this );

	this.cameras = array || [];

}

ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

	constructor: ArrayCamera,

	isArrayCamera: true

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Group() {

	Object3D.call( this );

	this.type = 'Group';

}

Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Group,

	isGroup: true

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebXRManager( renderer, gl ) {

	var scope = this;

	var session = null;

	var framebufferScaleFactor = 1.0;

	var referenceSpace = null;
	var referenceSpaceType = 'local-floor';

	var pose = null;

	var controllers = [];
	var inputSourcesMap = new Map();

	//

	var cameraL = new PerspectiveCamera();
	cameraL.layers.enable( 1 );
	cameraL.viewport = new Vector4();

	var cameraR = new PerspectiveCamera();
	cameraR.layers.enable( 2 );
	cameraR.viewport = new Vector4();

	var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
	cameraVR.layers.enable( 1 );
	cameraVR.layers.enable( 2 );

	var _currentDepthNear = null;
	var _currentDepthFar = null;

	//

	this.enabled = false;

	this.isPresenting = false;

	this.getController = function ( id ) {

		var controller = controllers[ id ];

		if ( controller === undefined ) {

			controller = {};
			controllers[ id ] = controller;

		}

		if ( controller.targetRay === undefined ) {

			controller.targetRay = new Group();
			controller.targetRay.matrixAutoUpdate = false;
			controller.targetRay.visible = false;

		}

		return controller.targetRay;

	};

	this.getControllerGrip = function ( id ) {

		var controller = controllers[ id ];

		if ( controller === undefined ) {

			controller = {};
			controllers[ id ] = controller;

		}

		if ( controller.grip === undefined ) {

			controller.grip = new Group();
			controller.grip.matrixAutoUpdate = false;
			controller.grip.visible = false;

		}

		return controller.grip;

	};

	//

	function onSessionEvent( event ) {

		var controller = inputSourcesMap.get( event.inputSource );

		if ( controller ) {

			if ( controller.targetRay ) {

				controller.targetRay.dispatchEvent( { type: event.type } );

			}

			if ( controller.grip ) {

				controller.grip.dispatchEvent( { type: event.type } );

			}

		}

	}

	function onSessionEnd() {

		inputSourcesMap.forEach( function ( controller, inputSource ) {

			if ( controller.targetRay ) {

				controller.targetRay.dispatchEvent( { type: 'disconnected', data: inputSource } );
				controller.targetRay.visible = false;

			}

			if ( controller.grip ) {

				controller.grip.dispatchEvent( { type: 'disconnected', data: inputSource } );
				controller.grip.visible = false;

			}

		} );

		inputSourcesMap.clear();

		//

		renderer.setFramebuffer( null );
		renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
		animation.stop();

		scope.isPresenting = false;

		scope.dispatchEvent( { type: 'sessionend' } );

	}

	function onRequestReferenceSpace( value ) {

		referenceSpace = value;

		animation.setContext( session );
		animation.start();

		scope.isPresenting = true;

		scope.dispatchEvent( { type: 'sessionstart' } );

	}

	this.setFramebufferScaleFactor = function ( value ) {

		framebufferScaleFactor = value;

		// Warn if function is used while presenting
		if ( scope.isPresenting == true ) {

			console.warn( "WebXRManager: Cannot change framebuffer scale while presenting VR content" );

		}

	};

	this.setReferenceSpaceType = function ( value ) {

		referenceSpaceType = value;

	};

	this.getReferenceSpace = function () {

		return referenceSpace;

	};

	this.getSession = function () {

		return session;

	};

	this.setSession = function ( value ) {

		session = value;

		if ( session !== null ) {

			session.addEventListener( 'select', onSessionEvent );
			session.addEventListener( 'selectstart', onSessionEvent );
			session.addEventListener( 'selectend', onSessionEvent );
			session.addEventListener( 'squeeze', onSessionEvent );
			session.addEventListener( 'squeezestart', onSessionEvent );
			session.addEventListener( 'squeezeend', onSessionEvent );
			session.addEventListener( 'end', onSessionEnd );

			var attributes = gl.getContextAttributes();

			var layerInit = {
				antialias: attributes.antialias,
				alpha: attributes.alpha,
				depth: attributes.depth,
				stencil: attributes.stencil,
				framebufferScaleFactor: framebufferScaleFactor
			};

			// eslint-disable-next-line no-undef
			var baseLayer = new XRWebGLLayer( session, gl, layerInit );

			session.updateRenderState( { baseLayer: baseLayer } );

			session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );

			//

			session.addEventListener( 'inputsourceschange', updateInputSources );

		}

	};

	function updateInputSources( event ) {

		var inputSources = session.inputSources;

		// Assign inputSources to available controllers

		for ( var i = 0; i < controllers.length; i ++ ) {

			inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

		}

		// Notify disconnected

		for ( var i = 0; i < event.removed.length; i ++ ) {

			var inputSource = event.removed[ i ];
			var controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				if ( controller.targetRay ) {

					controller.targetRay.dispatchEvent( { type: 'disconnected', data: inputSource } );

				}

				if ( controller.grip ) {

					controller.grip.dispatchEvent( { type: 'disconnected', data: inputSource } );

				}

				inputSourcesMap.delete( inputSource );

			}

		}

		// Notify connected

		for ( var i = 0; i < event.added.length; i ++ ) {

			var inputSource = event.added[ i ];
			var controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				if ( controller.targetRay ) {

					controller.targetRay.dispatchEvent( { type: 'connected', data: inputSource } );

				}

				if ( controller.grip ) {

					controller.grip.dispatchEvent( { type: 'connected', data: inputSource } );

				}

			}

		}

	}

	//

	var cameraLPos = new Vector3();
	var cameraRPos = new Vector3();

	/**
	 * @author jsantell / https://www.jsantell.com/
	 *
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion( camera, cameraL, cameraR ) {

		cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
		cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

		var ipd = cameraLPos.distanceTo( cameraRPos );

		var projL = cameraL.projectionMatrix.elements;
		var projR = cameraR.projectionMatrix.elements;

		// VR systems will have identical far and near planes, and
		// most likely identical top and bottom frustum extents.
		// Use the left camera for these values.
		var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
		var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
		var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
		var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

		var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
		var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
		var left = near * leftFov;
		var right = near * rightFov;

		// Calculate the new camera's position offset from the
		// left camera. xOffset should be roughly half `ipd`.
		var zOffset = ipd / ( - leftFov + rightFov );
		var xOffset = zOffset * - leftFov;

		// TODO: Better way to apply this offset?
		cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
		camera.translateX( xOffset );
		camera.translateZ( zOffset );
		camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		// Find the union of the frustum values of the cameras and scale
		// the values so that the near plane's position does not change in world space,
		// although must now be relative to the new union camera.
		var near2 = near + zOffset;
		var far2 = far + zOffset;
		var left2 = left - xOffset;
		var right2 = right + ( ipd - xOffset );
		var top2 = topFov * far / far2 * near2;
		var bottom2 = bottomFov * far / far2 * near2;

		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

	}

	function updateCamera( camera, parent ) {

		if ( parent === null ) {

			camera.matrixWorld.copy( camera.matrix );

		} else {

			camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

		}

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

	}

	this.getCamera = function ( camera ) {

		cameraVR.near = cameraR.near = cameraL.near = camera.near;
		cameraVR.far = cameraR.far = cameraL.far = camera.far;

		if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

			// Note that the new renderState won't apply until the next frame. See #18320

			session.updateRenderState( {
				depthNear: cameraVR.near,
				depthFar: cameraVR.far
			} );

			_currentDepthNear = cameraVR.near;
			_currentDepthFar = cameraVR.far;

		}

		var parent = camera.parent;
		var cameras = cameraVR.cameras;

		updateCamera( cameraVR, parent );

		for ( var i = 0; i < cameras.length; i ++ ) {

			updateCamera( cameras[ i ], parent );

		}

		// update camera and its children

		camera.matrixWorld.copy( cameraVR.matrixWorld );

		var children = camera.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( true );

		}

		setProjectionFromUnion( cameraVR, cameraL, cameraR );

		return cameraVR;

	};

	// Animation Loop

	var onAnimationFrameCallback = null;

	function onAnimationFrame( time, frame ) {

		pose = frame.getViewerPose( referenceSpace );

		if ( pose !== null ) {

			var views = pose.views;
			var baseLayer = session.renderState.baseLayer;

			renderer.setFramebuffer( baseLayer.framebuffer );

			for ( var i = 0; i < views.length; i ++ ) {

				var view = views[ i ];
				var viewport = baseLayer.getViewport( view );

				var camera = cameraVR.cameras[ i ];
				camera.matrix.fromArray( view.transform.matrix );
				camera.projectionMatrix.fromArray( view.projectionMatrix );
				camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

				if ( i === 0 ) {

					cameraVR.matrix.copy( camera.matrix );

				}

			}

		}

		//

		var inputSources = session.inputSources;

		for ( var i = 0; i < controllers.length; i ++ ) {

			var controller = controllers[ i ];

			var inputSource = inputSources[ i ];

			var inputPose = null;
			var gripPose = null;

			if ( inputSource ) {

				if ( controller.targetRay ) {

					inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

					if ( inputPose !== null ) {

						controller.targetRay.matrix.fromArray( inputPose.transform.matrix );
						controller.targetRay.matrix.decompose( controller.targetRay.position, controller.targetRay.rotation, controller.targetRay.scale );

					}

				}

				if ( controller.grip && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						controller.grip.matrix.fromArray( gripPose.transform.matrix );
						controller.grip.matrix.decompose( controller.grip.position, controller.grip.rotation, controller.grip.scale );

					}

				}

			}

			if ( controller.targetRay ) {

				controller.targetRay.visible = inputPose !== null;

			}

			if ( controller.grip ) {

				controller.grip.visible = gripPose !== null;

			}

		}

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

	}

	var animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;

	};

	this.dispose = function () {};

}

Object.assign( WebXRManager.prototype, EventDispatcher.prototype );

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

function WebGLRenderer( parameters ) {

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	var currentRenderList = null;
	var currentRenderState = null;

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {

		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.outputEncoding = LinearEncoding;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = LinearToneMapping;
	this.toneMappingExposure = 1.0;
	this.toneMappingWhitePoint = 1.0;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// internal properties

	var _this = this,

		_isContextLost = false,

		// internal state cache

		_framebuffer = null,

		_currentActiveCubeFace = 0,
		_currentActiveMipmapLevel = 0,
		_currentRenderTarget = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,

		// geometry and program caching

		_currentGeometryProgram = {
			geometry: null,
			program: null,
			wireframe: false
		},

		_currentCamera = null,
		_currentArrayCamera = null,

		_currentViewport = new Vector4(),
		_currentScissor = new Vector4(),
		_currentScissorTest = null,

		//

		_width = _canvas.width,
		_height = _canvas.height,

		_pixelRatio = 1,
		_opaqueSort = null,
		_transparentSort = null,

		_viewport = new Vector4( 0, 0, _width, _height ),
		_scissor = new Vector4( 0, 0, _width, _height ),
		_scissorTest = false,

		// frustum

		_frustum = new Frustum(),

		// clipping

		_clipping = new WebGLClipping(),
		_clippingEnabled = false,
		_localClippingEnabled = false,

		// camera matrices cache

		_projScreenMatrix = new Matrix4(),

		_vector3 = new Vector3();

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	var _gl;

	try {

		var contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
			xrCompatible: true
		};

		// event listeners must be registered before WebGL context is created, see #12753

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw new Error( 'Error creating WebGL context with your selected attributes.' );

			} else {

				throw new Error( 'Error creating WebGL context.' );

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );
		throw error;

	}

	var extensions, capabilities, state, info;
	var properties, textures, attributes, geometries, objects;
	var programCache, renderLists, renderStates;

	var background, morphtargets, bufferRenderer, indexedBufferRenderer;

	var utils;

	function initGLContext() {

		extensions = new WebGLExtensions( _gl );

		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		if ( capabilities.isWebGL2 === false ) {

			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'OES_element_index_uint' );
			extensions.get( 'ANGLE_instanced_arrays' );

		}

		extensions.get( 'OES_texture_float_linear' );

		utils = new WebGLUtils( _gl, extensions, capabilities );

		state = new WebGLState( _gl, extensions, capabilities );
		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

		info = new WebGLInfo( _gl );
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		attributes = new WebGLAttributes( _gl, capabilities );
		geometries = new WebGLGeometries( _gl, attributes, info );
		objects = new WebGLObjects( _gl, geometries, attributes, info );
		morphtargets = new WebGLMorphtargets( _gl );
		programCache = new WebGLPrograms( _this, extensions, capabilities );
		renderLists = new WebGLRenderLists();
		renderStates = new WebGLRenderStates();

		background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// xr

	var xr = new WebXRManager( _this, _gl );

	this.xr = xr;

	// shadow map

	var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

	this.shadowMap = shadowMap;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		var extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.forceContextRestore = function () {

		var extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

			target = new Vector2();

		}

		return target.set( _width, _height );

	};

	this.setSize = function ( width, height, updateStyle ) {

		if ( xr.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = Math.floor( width * _pixelRatio );
		_canvas.height = Math.floor( height * _pixelRatio );

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

			target = new Vector2();

		}

		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = Math.floor( width * pixelRatio );
		_canvas.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

			target = new Vector4();

		}

		return target.copy( _currentViewport );

	};

	this.getViewport = function ( target ) {

		return target.copy( _viewport );

	};

	this.setViewport = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_viewport.set( x.x, x.y, x.z, x.w );

		} else {

			_viewport.set( x, y, width, height );

		}

		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissor = function ( target ) {

		return target.copy( _scissor );

	};

	this.setScissor = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_scissor.set( x.x, x.y, x.z, x.w );

		} else {

			_scissor.set( x, y, width, height );

		}

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissorTest = function () {

		return _scissorTest;

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	this.setOpaqueSort = function ( method ) {

		_opaqueSort = method;

	};

	this.setTransparentSort = function ( method ) {

		_transparentSort = method;

	};

	// Clearing

	this.getClearColor = function () {

		return background.getClearColor();

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= 16384;
		if ( depth === undefined || depth ) bits |= 256;
		if ( stencil === undefined || stencil ) bits |= 1024;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		objects.dispose();

		xr.dispose();

		animation.stop();

		this.forceContextLoss();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		initGLContext();

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	function renderObjectImmediate( object, program ) {

		object.render( function ( object ) {

			_this.renderBufferImmediate( object, program );

		} );

	}

	this.renderBufferImmediate = function ( object, program ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		var programAttributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( 34962, buffers.position );
			_gl.bufferData( 34962, object.positionArray, 35048 );

			state.enableAttribute( programAttributes.position );
			_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( 34962, buffers.normal );
			_gl.bufferData( 34962, object.normalArray, 35048 );

			state.enableAttribute( programAttributes.normal );
			_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

		}

		if ( object.hasUvs ) {

			_gl.bindBuffer( 34962, buffers.uv );
			_gl.bufferData( 34962, object.uvArray, 35048 );

			state.enableAttribute( programAttributes.uv );
			_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

		}

		if ( object.hasColors ) {

			_gl.bindBuffer( 34962, buffers.color );
			_gl.bufferData( 34962, object.colorArray, 35048 );

			state.enableAttribute( programAttributes.color );
			_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( 4, 0, object.count );

		object.count = 0;

	};

	var tempScene = new Scene();

	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		if ( scene === null ) scene = tempScene; // renderBufferDirect second parameter used to be fog (could be null)

		var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		var program = setProgram( camera, scene, material, object );

		state.setMaterial( material, frontFaceCW );

		var updateBuffers = false;

		if ( _currentGeometryProgram.geometry !== geometry.id ||
			_currentGeometryProgram.program !== program.id ||
			_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {

			_currentGeometryProgram.geometry = geometry.id;
			_currentGeometryProgram.program = program.id;
			_currentGeometryProgram.wireframe = material.wireframe === true;
			updateBuffers = true;

		}

		if ( material.morphTargets || material.morphNormals ) {

			morphtargets.update( object, geometry, material, program );

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;

		//

		if ( index === null ) {

			if ( position === undefined || position.count === 0 ) return;

		} else if ( index.count === 0 ) {

			return;

		}

		//

		var rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		var attribute;
		var renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		if ( updateBuffers ) {

			setupVertexAttributes( object, geometry, material, program );

			if ( index !== null ) {

				_gl.bindBuffer( 34963, attribute.buffer );

			}

		}

		//

		var dataCount = ( index !== null ) ? index.count : position.count;

		var rangeStart = geometry.drawRange.start * rangeFactor;
		var rangeCount = geometry.drawRange.count * rangeFactor;

		var groupStart = group !== null ? group.start * rangeFactor : 0;
		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

		var drawStart = Math.max( rangeStart, groupStart );
		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( 1 );

			} else {

				renderer.setMode( 4 );

			}

		} else if ( object.isLine ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( 1 );

			} else if ( object.isLineLoop ) {

				renderer.setMode( 2 );

			} else {

				renderer.setMode( 3 );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( 0 );

		} else if ( object.isSprite ) {

			renderer.setMode( 4 );

		}

		if ( object.isInstancedMesh ) {

			renderer.renderInstances( geometry, drawStart, drawCount, object.count );

		} else if ( geometry.isInstancedBufferGeometry ) {

			renderer.renderInstances( geometry, drawStart, drawCount, geometry.maxInstancedCount );

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( object, geometry, material, program ) {

		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		}

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var normalized = geometryAttribute.normalized;
					var size = geometryAttribute.itemSize;

					var attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					var buffer = attribute.buffer;
					var type = attribute.type;
					var bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( 34962, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( 34962, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

					}

				} else if ( name === 'instanceMatrix' ) {

					var attribute = attributes.get( object.instanceMatrix );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					var buffer = attribute.buffer;
					var type = attribute.type;

					state.enableAttributeAndDivisor( programAttribute + 0, 1 );
					state.enableAttributeAndDivisor( programAttribute + 1, 1 );
					state.enableAttributeAndDivisor( programAttribute + 2, 1 );
					state.enableAttributeAndDivisor( programAttribute + 3, 1 );

					_gl.bindBuffer( 34962, buffer );

					_gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
					_gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
					_gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
					_gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Compile

	this.compile = function ( scene, camera ) {

		currentRenderState = renderStates.get( scene, camera );
		currentRenderState.init();

		scene.traverse( function ( object ) {

			if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights( camera );

		var compiled = {};

		scene.traverse( function ( object ) {

			if ( object.material ) {

				if ( Array.isArray( object.material ) ) {

					for ( var i = 0; i < object.material.length; i ++ ) {

						if ( object.material[ i ].uuid in compiled === false ) {

							initMaterial( object.material[ i ], scene, object );
							compiled[ object.material[ i ].uuid ] = true;

						}

					}

				} else if ( object.material.uuid in compiled === false ) {

					initMaterial( object.material, scene, object );
					compiled[ object.material.uuid ] = true;

				}

			}

		} );

	};

	// Animation Loop

	var onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( xr.isPresenting ) return;
		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	}

	var animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof window !== 'undefined' ) animation.setContext( window );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		xr.setAnimationLoop( callback );

		animation.start();

	};

	// Rendering

	this.render = function ( scene, camera ) {

		var renderTarget, forceClear;

		if ( arguments[ 2 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
			renderTarget = arguments[ 2 ];

		}

		if ( arguments[ 3 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
			forceClear = arguments[ 3 ];

		}

		if ( ! ( camera && camera.isCamera ) ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost ) return;

		// reset caching for this frame

		_currentGeometryProgram.geometry = null;
		_currentGeometryProgram.program = null;
		_currentGeometryProgram.wireframe = false;
		_currentMaterialId = - 1;
		_currentCamera = null;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( xr.enabled && xr.isPresenting ) {

			camera = xr.getCamera( camera );

		}

		//

		currentRenderState = renderStates.get( scene, camera );
		currentRenderState.init();

		scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, camera );
		currentRenderList.init();

		projectObject( scene, camera, 0, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort( _opaqueSort, _transparentSort );

		}

		//

		if ( _clippingEnabled ) _clipping.beginShadows();

		var shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		currentRenderState.setupLights( camera );

		if ( _clippingEnabled ) _clipping.endShadows();

		//

		if ( this.info.autoReset ) this.info.reset();

		if ( renderTarget !== undefined ) {

			this.setRenderTarget( renderTarget );

		}

		//

		background.render( currentRenderList, scene, camera, forceClear );

		// render scene

		var opaqueObjects = currentRenderList.opaque;
		var transparentObjects = currentRenderList.transparent;

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
			if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

			// transparent pass (back-to-front order)

			if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

		}

		//

		scene.onAfterRender( _this, scene, camera );

		//

		if ( _currentRenderTarget !== null ) {

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( _currentRenderTarget );

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( _currentRenderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

		// _gl.finish();

		currentRenderList = null;
		currentRenderState = null;

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) return;

		var visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					var geometry = objects.update( object );
					var material = object.material;

					if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			} else if ( object.isImmediateRenderObject ) {

				if ( sortObjects ) {

					_vector3.setFromMatrixPosition( object.matrixWorld )
						.applyMatrix4( _projScreenMatrix );

				}

				currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					// update skeleton only once in a frame

					if ( object.skeleton.frame !== info.render.frame ) {

						object.skeleton.update();
						object.skeleton.frame = info.render.frame;

					}

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					var geometry = objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var i = 0, l = groups.length; i < l; i ++ ) {

							var group = groups[ i ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderObjects( renderList, scene, camera, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			if ( camera.isArrayCamera ) {

				_currentArrayCamera = camera;

				var cameras = camera.cameras;

				for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

					var camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						state.viewport( _currentViewport.copy( camera2.viewport ) );

						currentRenderState.setupLights( camera2 );

						renderObject( object, scene, camera2, geometry, material, group );

					}

				}

			} else {

				_currentArrayCamera = null;

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );
		currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		if ( object.isImmediateRenderObject ) {

			var program = setProgram( camera, scene, material, object );

			state.setMaterial( material );

			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;

			renderObjectImmediate( object, program );

		} else {

			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );
		currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

	}

	function initMaterial( material, scene, object ) {

		var materialProperties = properties.get( material );

		var lights = currentRenderState.state.lights;
		var shadowsArray = currentRenderState.state.shadowsArray;

		var lightsStateVersion = lights.state.version;

		var parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object );
		var programCacheKey = programCache.getProgramCacheKey( parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.cacheKey !== programCacheKey ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {

			materialProperties.lightsStateVersion = lightsStateVersion;

			programChange = false;

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			program = programCache.acquireProgram( parameters, programCacheKey );

			materialProperties.program = program;
			materialProperties.uniforms = parameters.uniforms;
			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.outputEncoding = _this.outputEncoding;
			material.program = program;

		}

		var programAttributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		var uniforms = materialProperties.uniforms;

		if ( ! material.isShaderMaterial &&
			! material.isRawShaderMaterial ||
			material.clipping === true ) {

			materialProperties.numClippingPlanes = _clipping.numPlanes;
			materialProperties.numIntersection = _clipping.numIntersection;
			uniforms.clippingPlanes = _clipping.uniform;

		}

		materialProperties.fog = scene.fog;

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights( material );
		materialProperties.lightsStateVersion = lightsStateVersion;

		if ( materialProperties.needsLights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		var progUniforms = materialProperties.program.getUniforms(),
			uniformsList =
				WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.uniformsList = uniformsList;

	}

	function setProgram( camera, scene, material, object ) {

		textures.resetTextureUnits();

		var fog = scene.fog;
		var environment = material.isMeshStandardMaterial ? scene.environment : null;

		var materialProperties = properties.get( material );
		var lights = currentRenderState.state.lights;

		if ( _clippingEnabled ) {

			if ( _localClippingEnabled || camera !== _currentCamera ) {

				var useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				_clipping.setState(
					material.clippingPlanes, material.clipIntersection, material.clipShadows,
					camera, materialProperties, useCache );

			}

		}

		if ( material.version === materialProperties.__version ) {

			if ( materialProperties.program === undefined ) {

				initMaterial( material, scene, object );

			} else if ( material.fog && materialProperties.fog !== fog ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.environment !== environment ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
				materialProperties.numIntersection !== _clipping.numIntersection ) ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.outputEncoding !== _this.outputEncoding ) {

				initMaterial( material, scene, object );

			}

		} else {

			initMaterial( material, scene, object );
			materialProperties.__version = material.version;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				var uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ) {

				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// otherwise textures used for skinning can take over texture units reserved for other material textures

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			var skeleton = object.skeleton;

			if ( skeleton ) {

				var bones = skeleton.bones;

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === undefined ) {

						// layout (1 matrix = 4 pixels)
						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


						var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
						size = MathUtils.ceilPowerOfTwo( size );
						size = Math.max( size, 4 );

						var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
						boneMatrices.set( skeleton.boneMatrices ); // copy current values

						var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

						skeleton.boneMatrices = boneMatrices;
						skeleton.boneTexture = boneTexture;
						skeleton.boneTextureSize = size;

					}

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
			p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

			if ( materialProperties.needsLights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material.isMeshBasicMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsLambert( m_uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsToon( m_uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsPhong( m_uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsCommon( m_uniforms, material, environment );

				if ( material.isMeshPhysicalMaterial ) {

					refreshUniformsPhysical( m_uniforms, material, environment );

				} else {

					refreshUniformsStandard( m_uniforms, material, environment );

				}

			} else if ( material.isMeshMatcapMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsMatcap( m_uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsDepth( m_uniforms, material );

			} else if ( material.isMeshDistanceMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsDistance( m_uniforms, material );

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsNormal( m_uniforms, material );

			} else if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

				if ( material.isLineDashedMaterial ) {

					refreshUniformsDash( m_uniforms, material );

				}

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( m_uniforms, material );

			} else if ( material.isSpriteMaterial ) {

				refreshUniformsSprites( m_uniforms, material );

			} else if ( material.isShadowMaterial ) {

				m_uniforms.color.value.copy( material.color );
				m_uniforms.opacity.value = material.opacity;

			}

			// RectAreaLight Texture
			// TODO (mrdoob): Find a nicer implementation

			if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
			if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

			if ( material.isShaderMaterial ) {

				material.uniformsNeedUpdate = false; // #15581

			}

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon( uniforms, material, environment ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		var envMap = material.envMap || environment;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			uniforms.flipEnvMap.value = envMap.isCubeTexture ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

			uniforms.maxMipLevel.value = properties.get( envMap ).__maxMipLevel;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		var uv2ScaleMap;

		if ( material.aoMap ) {

			uv2ScaleMap = material.aoMap;

		} else if ( material.lightMap ) {

			uv2ScaleMap = material.lightMap;

		}

		if ( uv2ScaleMap !== undefined ) {

			// backwards compatibility
			if ( uv2ScaleMap.isWebGLRenderTarget ) {

				uv2ScaleMap = uv2ScaleMap.texture;

			}

			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				uv2ScaleMap.updateMatrix();

			}

			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * _pixelRatio;
		uniforms.scale.value = _height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsFog( uniforms, fog ) {

		uniforms.fogColor.value.copy( fog.color );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsStandard( uniforms, material, environment ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.envMap || environment ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material, environment ) {

		refreshUniformsStandard( uniforms, material, environment );

		uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

		uniforms.clearcoat.value = material.clearcoat;
		uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
		if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

		if ( material.clearcoatMap ) {

			uniforms.clearcoatMap.value = material.clearcoatMap;

		}

		if ( material.clearcoatRoughnessMap ) {

			uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

		}

		if ( material.clearcoatNormalMap ) {

			uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
			uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

			if ( material.side === BackSide ) {

				uniforms.clearcoatNormalScale.value.negate();

			}

		}

		uniforms.transparency.value = material.transparency;

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDepth( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	function materialNeedsLights( material ) {

		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			material.isMeshStandardMaterial || material.isShadowMaterial ||
			( material.isShaderMaterial && material.lights === true );

	}

	//
	this.setFramebuffer = function ( value ) {

		if ( _framebuffer !== value && _currentRenderTarget === null ) _gl.bindFramebuffer( 36160, value );

		_framebuffer = value;

	};

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;

	};

	this.getActiveMipmapLevel = function () {

		return _currentActiveMipmapLevel;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipmapLevel ) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		var framebuffer = _framebuffer;
		var isCube = false;

		if ( renderTarget ) {

			var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				framebuffer = __webglFramebuffer[ activeCubeFace || 0 ];
				isCube = true;

			} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			_currentScissorTest = _scissorTest;

		}

		if ( _currentFramebuffer !== framebuffer ) {

			_gl.bindFramebuffer( 36160, framebuffer );
			_currentFramebuffer = framebuffer;

		}

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( 36160, 36064, 34069 + ( activeCubeFace || 0 ), textureProperties.__webglTexture, activeMipmapLevel || 0 );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			framebuffer = framebuffer[ activeCubeFaceIndex ];

		}

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( 36160, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;
				var textureFormat = texture.format;
				var textureType = texture.type;

				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( 36160, _currentFramebuffer );

				}

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level ) {

		if ( level === undefined ) level = 0;

		var levelScale = Math.pow( 2, - level );
		var width = Math.floor( texture.image.width * levelScale );
		var height = Math.floor( texture.image.height * levelScale );
		var glFormat = utils.convert( texture.format );

		textures.setTexture2D( texture, 0 );

		_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

		state.unbindTexture();

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

		var width = srcTexture.image.width;
		var height = srcTexture.image.height;
		var glFormat = utils.convert( dstTexture.format );
		var glType = utils.convert( dstTexture.type );

		textures.setTexture2D( dstTexture, 0 );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( 3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			_gl.texSubImage2D( 3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );

		}

		state.unbindTexture();

	};

	this.initTexture = function ( texture ) {

		textures.setTexture2D( texture, 0 );

		state.unbindTexture();

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function FogExp2( color, density ) {

	this.name = '';

	this.color = new Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

}

Object.assign( FogExp2.prototype, {

	isFogExp2: true,

	clone: function () {

		return new FogExp2( this.color, this.density );

	},

	toJSON: function ( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Fog( color, near, far ) {

	this.name = '';

	this.color = new Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

}

Object.assign( Fog.prototype, {

	isFog: true,

	clone: function () {

		return new Fog( this.color, this.near, this.far );

	},

	toJSON: function ( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBuffer( array, stride ) {

	this.array = array;
	this.stride = stride;
	this.count = array !== undefined ? array.length / stride : 0;

	this.usage = StaticDrawUsage;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

}

Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( InterleavedBuffer.prototype, {

	isInterleavedBuffer: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( var i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

var _vector$6 = new Vector3();

function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

	this.normalized = normalized === true;

}

Object.defineProperties( InterleavedBufferAttribute.prototype, {

	count: {

		get: function () {

			return this.data.count;

		}

	},

	array: {

		get: function () {

			return this.data.array;

		}

	}

} );

Object.assign( InterleavedBufferAttribute.prototype, {

	isInterleavedBufferAttribute: true,

	applyMatrix4: function ( m ) {

		for ( var i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.x = this.getX( i );
			_vector$6.y = this.getY( i );
			_vector$6.z = this.getZ( i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function SpriteMaterial( parameters ) {

	Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;

	this.alphaMap = null;

	this.rotation = 0;

	this.sizeAttenuation = true;

	this.transparent = true;

	this.setValues( parameters );

}

SpriteMaterial.prototype = Object.create( Material.prototype );
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;

SpriteMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.rotation = source.rotation;

	this.sizeAttenuation = source.sizeAttenuation;

	return this;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

var _geometry;

var _intersectPoint = new Vector3();
var _worldScale = new Vector3();
var _mvPosition = new Vector3();

var _alignedPosition = new Vector2();
var _rotatedPosition = new Vector2();
var _viewWorldMatrix = new Matrix4();

var _vA$1 = new Vector3();
var _vB$1 = new Vector3();
var _vC$1 = new Vector3();

var _uvA$1 = new Vector2();
var _uvB$1 = new Vector2();
var _uvC$1 = new Vector2();

function Sprite( material ) {

	Object3D.call( this );

	this.type = 'Sprite';

	if ( _geometry === undefined ) {

		_geometry = new BufferGeometry();

		var float32Array = new Float32Array( [
			- 0.5, - 0.5, 0, 0, 0,
			0.5, - 0.5, 0, 1, 0,
			0.5, 0.5, 0, 1, 1,
			- 0.5, 0.5, 0, 0, 1
		] );

		var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

		_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
		_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
		_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

	}

	this.geometry = _geometry;
	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

	this.center = new Vector2( 0.5, 0.5 );

}

Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Sprite,

	isSprite: true,

	raycast: function ( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		var rotation = this.material.rotation;
		var sin, cos;
		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		var center = this.center;

		transformVertex( _vA$1.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB$1.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC$1.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA$1.set( 0, 0 );
		_uvB$1.set( 1, 0 );
		_uvC$1.set( 1, 1 );

		// check first triangle
		var intersect = raycaster.ray.intersectTriangle( _vA$1, _vB$1, _vC$1, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB$1.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB$1.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA$1, _vC$1, _vB$1, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		var distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getUV( _intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() ),
			face: null,
			object: this

		} );

	},

	clone: function () {

		return new this.constructor( this.material ).copy( this );

	},

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		if ( source.center !== undefined ) this.center.copy( source.center );

		return this;

	}


} );

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _v1$4 = new Vector3();
var _v2$2 = new Vector3();

function LOD() {

	Object3D.call( this );

	this._currentLevel = 0;

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		}
	} );

	this.autoUpdate = true;

}

LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: LOD,

	isLOD: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source, false );

		var levels = source.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	},

	addLevel: function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		var levels = this.levels;

		for ( var l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

		return this;

	},

	getCurrentLevel: function () {

		return this._currentLevel;

	},

	getObjectForDistance: function ( distance ) {

		var levels = this.levels;

		if ( levels.length > 0 ) {

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	},

	raycast: function ( raycaster, intersects ) {

		var levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$4.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( _v1$4 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	},

	update: function ( camera ) {

		var levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$4.setFromMatrixPosition( camera.matrixWorld );
			_v2$2.setFromMatrixPosition( this.matrixWorld );

			var distance = _v1$4.distanceTo( _v2$2 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		var levels = this.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function SkinnedMesh( geometry, material ) {

	if ( geometry && geometry.isGeometry ) {

		console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

	}

	Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = 'attached';
	this.bindMatrix = new Matrix4();
	this.bindMatrixInverse = new Matrix4();

}

SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: SkinnedMesh,

	isSkinnedMesh: true,

	bind: function ( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		var vector = new Vector4();

		var skinWeight = this.geometry.attributes.skinWeight;

		for ( var i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.x = skinWeight.getX( i );
			vector.y = skinWeight.getY( i );
			vector.z = skinWeight.getZ( i );
			vector.w = skinWeight.getW( i );

			var scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	},

	updateMatrixWorld: function ( force ) {

		Mesh.prototype.updateMatrixWorld.call( this, force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	},

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

var _offsetMatrix = new Matrix4();
var _identityMatrix = new Matrix4();

function Skeleton( bones, boneInverses ) {

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );
	this.boneMatrices = new Float32Array( this.bones.length * 16 );

	this.frame = - 1;

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				this.boneInverses.push( new Matrix4() );

			}

		}

	}

}

Object.assign( Skeleton.prototype, {

	calculateInverses: function () {

		this.boneInverses = [];

		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

			var inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.getInverse( this.bones[ i ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	},

	pose: function () {

		var bone, i, il;

		// recover the bind-time world matrices

		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

			bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ i ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

			bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	},

	update: function () {

		var bones = this.bones;
		var boneInverses = this.boneInverses;
		var boneMatrices = this.boneMatrices;
		var boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( var i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			var matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== undefined ) {

			boneTexture.needsUpdate = true;

		}

	},

	clone: function () {

		return new Skeleton( this.bones, this.boneInverses );

	},

	getBoneByName: function ( name ) {

		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	},

	dispose: function ( ) {

		if ( this.boneTexture ) {

			this.boneTexture.dispose();

			this.boneTexture = undefined;

		}

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function Bone() {

	Object3D.call( this );

	this.type = 'Bone';

}

Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Bone,

	isBone: true

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();

var _instanceIntersects = [];

var _mesh = new Mesh();

function InstancedMesh( geometry, material, count ) {

	Mesh.call( this, geometry, material );

	this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );

	this.count = count;

	this.frustumCulled = false;

}

InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: InstancedMesh,

	isInstancedMesh: true,

	getMatrixAt: function ( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	},

	raycast: function ( raycaster, intersects ) {

		var matrixWorld = this.matrixWorld;
		var raycastTimes = this.count;

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined ) return;

		for ( var instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			if ( _instanceIntersects.length > 0 ) {

				_instanceIntersects[ 0 ].instanceId = instanceId;
				_instanceIntersects[ 0 ].object = this;

				intersects.push( _instanceIntersects[ 0 ] );

				_instanceIntersects.length = 0;

			}

		}

	},

	setMatrixAt: function ( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	},

	updateMorphTargets: function () {

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.setValues( parameters );

}

LineBasicMaterial.prototype = Object.create( Material.prototype );
LineBasicMaterial.prototype.constructor = LineBasicMaterial;

LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _start = new Vector3();
var _end = new Vector3();
var _inverseMatrix$1 = new Matrix4();
var _ray$1 = new Ray();
var _sphere$2 = new Sphere();

function Line( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );

	}

	Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new LineBasicMaterial();

}

Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Line,

	isLine: true,

	computeLineDistances: function () {

		var geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				var positionAttribute = geometry.attributes.position;
				var lineDistances = [ 0 ];

				for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

					_start.fromBufferAttribute( positionAttribute, i - 1 );
					_end.fromBufferAttribute( positionAttribute, i );

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			var vertices = geometry.vertices;
			var lineDistances = geometry.lineDistances;

			lineDistances[ 0 ] = 0;

			for ( var i = 1, l = vertices.length; i < l; i ++ ) {

				lineDistances[ i ] = lineDistances[ i - 1 ];
				lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

			}

		}

		return this;

	},

	raycast: function ( raycaster, intersects ) {

		var geometry = this.geometry;
		var matrixWorld = this.matrixWorld;
		var threshold = raycaster.params.Line.threshold;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$2.copy( geometry.boundingSphere );
		_sphere$2.applyMatrix4( matrixWorld );
		_sphere$2.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;

		//

		_inverseMatrix$1.getInverse( matrixWorld );
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var localThresholdSq = localThreshold * localThreshold;

		var vStart = new Vector3();
		var vEnd = new Vector3();
		var interSegment = new Vector3();
		var interRay = new Vector3();
		var step = ( this && this.isLineSegments ) ? 2 : 1;

		if ( geometry.isBufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

					var a = indices[ i ];
					var b = indices[ i + 1 ];

					vStart.fromArray( positions, a * 3 );
					vEnd.fromArray( positions, b * 3 );

					var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

					vStart.fromArray( positions, 3 * i );
					vEnd.fromArray( positions, 3 * i + 3 );

					var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry.isGeometry ) {

			var vertices = geometry.vertices;
			var nbVertices = vertices.length;

			for ( var i = 0; i < nbVertices - 1; i += step ) {

				var distSq = _ray$1.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > localThresholdSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				var distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	},

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _start$1 = new Vector3();
var _end$1 = new Vector3();

function LineSegments( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineSegments';

}

LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineSegments,

	isLineSegments: true,

	computeLineDistances: function () {

		var geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				var positionAttribute = geometry.attributes.position;
				var lineDistances = [];

				for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					_start$1.fromBufferAttribute( positionAttribute, i );
					_end$1.fromBufferAttribute( positionAttribute, i + 1 );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			var vertices = geometry.vertices;
			var lineDistances = geometry.lineDistances;

			for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

				_start$1.copy( vertices[ i ] );
				_end$1.copy( vertices[ i + 1 ] );

				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
				lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

			}

		}

		return this;

	}

} );

/**
 * @author mgreter / http://github.com/mgreter
 */

function LineLoop( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineLoop';

}

LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineLoop,

	isLineLoop: true,

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial( parameters ) {

	Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;

	this.alphaMap = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.morphTargets = false;

	this.setValues( parameters );

}

PointsMaterial.prototype = Object.create( Material.prototype );
PointsMaterial.prototype.constructor = PointsMaterial;

PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	this.morphTargets = source.morphTargets;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

var _inverseMatrix$2 = new Matrix4();
var _ray$2 = new Ray();
var _sphere$3 = new Sphere();
var _position$1 = new Vector3();

function Points( geometry, material ) {

	Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new PointsMaterial();

	this.updateMorphTargets();

}

Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Points,

	isPoints: true,

	raycast: function ( raycaster, intersects ) {

		var geometry = this.geometry;
		var matrixWorld = this.matrixWorld;
		var threshold = raycaster.params.Points.threshold;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );
		_sphere$3.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		//

		_inverseMatrix$2.getInverse( matrixWorld );
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var localThresholdSq = localThreshold * localThreshold;

		if ( geometry.isBufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, il = indices.length; i < il; i ++ ) {

					var a = indices[ i ];

					_position$1.fromArray( positions, a * 3 );

					testPoint( _position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			} else {

				for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

					_position$1.fromArray( positions, i * 3 );

					testPoint( _position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		} else {

			var vertices = geometry.vertices;

			for ( var i = 0, l = vertices.length; i < l; i ++ ) {

				testPoint( vertices[ i ], i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	},

	updateMorphTargets: function () {

		var geometry = this.geometry;
		var m, ml, name;

		if ( geometry.isBufferGeometry ) {

			var morphAttributes = geometry.morphAttributes;
			var keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				var morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			var morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	},

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	var rayPointDistanceSq = _ray$2.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		var intersectPoint = new Vector3();

		_ray$2.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.format = format !== undefined ? format : RGBFormat;

	this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

	this.generateMipmaps = false;

}

VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

	constructor: VideoTexture,

	isVideoTexture: true,

	update: function () {

		var video = this.image;

		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

}

CompressedTexture.prototype = Object.create( Texture.prototype );
CompressedTexture.prototype.constructor = CompressedTexture;

CompressedTexture.prototype.isCompressedTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

}

CanvasTexture.prototype = Object.create( Texture.prototype );
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;

/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */

function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

	format = format !== undefined ? format : DepthFormat;

	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

	}

	if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
	if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.flipY = false;
	this.generateMipmaps	= false;

}

DepthTexture.prototype = Object.create( Texture.prototype );
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function WireframeGeometry( geometry ) {

	BufferGeometry.call( this );

	this.type = 'WireframeGeometry';

	// buffer

	var vertices = [];

	// helper variables

	var i, j, l, o, ol;
	var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
	var key, keys = [ 'a', 'b', 'c' ];
	var vertex;

	// different logic for Geometry and BufferGeometry

	if ( geometry && geometry.isGeometry ) {

		// create a data structure that contains all edges without duplicates

		var faces = geometry.faces;

		for ( i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( j = 0; j < 3; j ++ ) {

				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
				edge[ 1 ] = Math.max( edge1, edge2 );

				key = edge[ 0 ] + ',' + edge[ 1 ];

				if ( edges[ key ] === undefined ) {

					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

				}

			}

		}

		// generate vertices

		for ( key in edges ) {

			e = edges[ key ];

			vertex = geometry.vertices[ e.index1 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

			vertex = geometry.vertices[ e.index2 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	} else if ( geometry && geometry.isBufferGeometry ) {

		var position, indices, groups;
		var group, start, count;
		var index1, index2;

		vertex = new Vector3();

		if ( geometry.index !== null ) {

			// indexed BufferGeometry

			position = geometry.attributes.position;
			indices = geometry.index;
			groups = geometry.groups;

			if ( groups.length === 0 ) {

				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

			}

			// create a data structure that contains all eges without duplicates

			for ( o = 0, ol = groups.length; o < ol; ++ o ) {

				group = groups[ o ];

				start = group.start;
				count = group.count;

				for ( i = start, l = ( start + count ); i < l; i += 3 ) {

					for ( j = 0; j < 3; j ++ ) {

						edge1 = indices.getX( i + j );
						edge2 = indices.getX( i + ( j + 1 ) % 3 );
						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
						edge[ 1 ] = Math.max( edge1, edge2 );

						key = edge[ 0 ] + ',' + edge[ 1 ];

						if ( edges[ key ] === undefined ) {

							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

						}

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				e = edges[ key ];

				vertex.fromBufferAttribute( position, e.index1 );
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex.fromBufferAttribute( position, e.index2 );
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else {

			// non-indexed BufferGeometry

			position = geometry.attributes.position;

			for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

				for ( j = 0; j < 3; j ++ ) {

					// three edges per triangle, an edge is represented as (index1, index2)
					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

					index1 = 3 * i + j;
					vertex.fromBufferAttribute( position, index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					index2 = 3 * i + ( ( j + 1 ) % 3 );
					vertex.fromBufferAttribute( position, index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

		}

	}

	// build geometry

	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

}

WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
WireframeGeometry.prototype.constructor = WireframeGeometry;

/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */

// ParametricGeometry

function ParametricGeometry( func, slices, stacks ) {

	Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
	this.mergeVertices();

}

ParametricGeometry.prototype = Object.create( Geometry.prototype );
ParametricGeometry.prototype.constructor = ParametricGeometry;

// ParametricBufferGeometry

function ParametricBufferGeometry( func, slices, stacks ) {

	BufferGeometry.call( this );

	this.type = 'ParametricBufferGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	var EPS = 0.00001;

	var normal = new Vector3();

	var p0 = new Vector3(), p1 = new Vector3();
	var pu = new Vector3(), pv = new Vector3();

	var i, j;

	if ( func.length < 3 ) {

		console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

	}

	// generate vertices, normals and uvs

	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		var v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			var u = j / slices;

			// vertex

			func( u, v, p0 );
			vertices.push( p0.x, p0.y, p0.z );

			// normal

			// approximate tangent vectors via finite differences

			if ( u - EPS >= 0 ) {

				func( u - EPS, v, p1 );
				pu.subVectors( p0, p1 );

			} else {

				func( u + EPS, v, p1 );
				pu.subVectors( p1, p0 );

			}

			if ( v - EPS >= 0 ) {

				func( u, v - EPS, p1 );
				pv.subVectors( p0, p1 );

			} else {

				func( u, v + EPS, p1 );
				pv.subVectors( p1, p0 );

			}

			// cross product of tangent vectors returns surface normal

			normal.crossVectors( pu, pv ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u, v );

		}

	}

	// generate indices

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			var a = i * sliceCount + j;
			var b = i * sliceCount + j + 1;
			var c = ( i + 1 ) * sliceCount + j + 1;
			var d = ( i + 1 ) * sliceCount + j;

			// faces one and two

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */

// PolyhedronGeometry

function PolyhedronGeometry( vertices, indices, radius, detail ) {

	Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
	this.mergeVertices();

}

PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

// PolyhedronBufferGeometry

function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

	BufferGeometry.call( this );

	this.type = 'PolyhedronBufferGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	// default buffer data

	var vertexBuffer = [];
	var uvBuffer = [];

	// the subdivision creates the vertex buffer data

	subdivide( detail );

	// all vertices should lie on a conceptual sphere with a given radius

	applyRadius( radius );

	// finally, create the uv data

	generateUVs();

	// build non-indexed geometry

	this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

	if ( detail === 0 ) {

		this.computeVertexNormals(); // flat normals

	} else {

		this.normalizeNormals(); // smooth normals

	}

	// helper functions

	function subdivide( detail ) {

		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();

		// iterate over all faces and apply a subdivison with the given detail value

		for ( var i = 0; i < indices.length; i += 3 ) {

			// get the vertices of the face

			getVertexByIndex( indices[ i + 0 ], a );
			getVertexByIndex( indices[ i + 1 ], b );
			getVertexByIndex( indices[ i + 2 ], c );

			// perform subdivision

			subdivideFace( a, b, c, detail );

		}

	}

	function subdivideFace( a, b, c, detail ) {

		var cols = Math.pow( 2, detail );

		// we use this multidimensional array as a data structure for creating the subdivision

		var v = [];

		var i, j;

		// construct all of the vertices for this subdivision

		for ( i = 0; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = a.clone().lerp( c, i / cols );
			var bj = b.clone().lerp( c, i / cols );

			var rows = cols - i;

			for ( j = 0; j <= rows; j ++ ) {

				if ( j === 0 && i === cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

				}

			}

		}

		// construct all of the faces

		for ( i = 0; i < cols; i ++ ) {

			for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 === 0 ) {

					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );
					pushVertex( v[ i ][ k ] );

				} else {

					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );

				}

			}

		}

	}

	function applyRadius( radius ) {

		var vertex = new Vector3();

		// iterate over the entire buffer and apply the radius to each vertex

		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];

			vertex.normalize().multiplyScalar( radius );

			vertexBuffer[ i + 0 ] = vertex.x;
			vertexBuffer[ i + 1 ] = vertex.y;
			vertexBuffer[ i + 2 ] = vertex.z;

		}

	}

	function generateUVs() {

		var vertex = new Vector3();

		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];

			var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
			var v = inclination( vertex ) / Math.PI + 0.5;
			uvBuffer.push( u, 1 - v );

		}

		correctUVs();

		correctSeam();

	}

	function correctSeam() {

		// handle case when face straddles the seam, see #3269

		for ( var i = 0; i < uvBuffer.length; i += 6 ) {

			// uv data of a single face

			var x0 = uvBuffer[ i + 0 ];
			var x1 = uvBuffer[ i + 2 ];
			var x2 = uvBuffer[ i + 4 ];

			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );

			// 0.9 is somewhat arbitrary

			if ( max > 0.9 && min < 0.1 ) {

				if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
				if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
				if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

			}

		}

	}

	function pushVertex( vertex ) {

		vertexBuffer.push( vertex.x, vertex.y, vertex.z );

	}

	function getVertexByIndex( index, vertex ) {

		var stride = index * 3;

		vertex.x = vertices[ stride + 0 ];
		vertex.y = vertices[ stride + 1 ];
		vertex.z = vertices[ stride + 2 ];

	}

	function correctUVs() {

		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();

		var centroid = new Vector3();

		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();

		for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

			a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
			b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
			c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

			uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
			uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
			uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

			centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

			var azi = azimuth( centroid );

			correctUV( uvA, j + 0, a, azi );
			correctUV( uvB, j + 2, b, azi );
			correctUV( uvC, j + 4, c, azi );

		}

	}

	function correctUV( uv, stride, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

			uvBuffer[ stride ] = uv.x - 1;

		}

		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

			uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

		}

	}

	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}

}

PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// TetrahedronGeometry

function TetrahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

// TetrahedronBufferGeometry

function TetrahedronBufferGeometry( radius, detail ) {

	var vertices = [
		1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
	];

	var indices = [
		2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// OctahedronGeometry

function OctahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

OctahedronGeometry.prototype = Object.create( Geometry.prototype );
OctahedronGeometry.prototype.constructor = OctahedronGeometry;

// OctahedronBufferGeometry

function OctahedronBufferGeometry( radius, detail ) {

	var vertices = [
		1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
		0, - 1, 0, 	0, 0, 1,	0, 0, - 1
	];

	var indices = [
		0, 2, 4,	0, 4, 3,	0, 3, 5,
		0, 5, 2,	1, 2, 5,	1, 5, 3,
		1, 3, 4,	1, 4, 2
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// IcosahedronGeometry

function IcosahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

// IcosahedronBufferGeometry

function IcosahedronBufferGeometry( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
		 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
		 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
	];

	var indices = [
		 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
		 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
		 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
		 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */

// DodecahedronGeometry

function DodecahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'DodecahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

// DodecahedronBufferGeometry

function DodecahedronBufferGeometry( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (1, 1, 1)
		- 1, - 1, - 1,	- 1, - 1, 1,
		- 1, 1, - 1, - 1, 1, 1,
		1, - 1, - 1, 1, - 1, 1,
		1, 1, - 1, 1, 1, 1,

		// (0, 1/, )
		 0, - r, - t, 0, - r, t,
		 0, r, - t, 0, r, t,

		// (1/, , 0)
		- r, - t, 0, - r, t, 0,
		 r, - t, 0, r, t, 0,

		// (, 0, 1/)
		- t, 0, - r, t, 0, - r,
		- t, 0, r, t, 0, r
	];

	var indices = [
		3, 11, 7, 	3, 7, 15, 	3, 15, 13,
		7, 19, 17, 	7, 17, 6, 	7, 6, 15,
		17, 4, 8, 	17, 8, 10, 	17, 10, 6,
		8, 0, 16, 	8, 16, 2, 	8, 2, 10,
		0, 12, 1, 	0, 1, 18, 	0, 18, 16,
		6, 10, 2, 	6, 2, 13, 	6, 13, 15,
		2, 16, 18, 	2, 18, 3, 	2, 3, 13,
		18, 1, 9, 	18, 9, 11, 	18, 11, 3,
		4, 14, 12, 	4, 12, 0, 	4, 0, 8,
		11, 9, 5, 	11, 5, 19, 	11, 19, 7,
		19, 5, 14, 	19, 14, 4, 	19, 4, 17,
		1, 12, 14, 	1, 14, 5, 	1, 5, 9
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'DodecahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */

// TubeGeometry

function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

	Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

	var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

	// expose internals

	this.tangents = bufferGeometry.tangents;
	this.normals = bufferGeometry.normals;
	this.binormals = bufferGeometry.binormals;

	// create geometry

	this.fromBufferGeometry( bufferGeometry );
	this.mergeVertices();

}

TubeGeometry.prototype = Object.create( Geometry.prototype );
TubeGeometry.prototype.constructor = TubeGeometry;

// TubeBufferGeometry

function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

	BufferGeometry.call( this );

	this.type = 'TubeBufferGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	tubularSegments = tubularSegments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;

	var frames = path.computeFrenetFrames( tubularSegments, closed );

	// expose internals

	this.tangents = frames.tangents;
	this.normals = frames.normals;
	this.binormals = frames.binormals;

	// helper variables

	var vertex = new Vector3();
	var normal = new Vector3();
	var uv = new Vector2();
	var P = new Vector3();

	var i, j;

	// buffer

	var vertices = [];
	var normals = [];
	var uvs = [];
	var indices = [];

	// create buffer data

	generateBufferData();

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// functions

	function generateBufferData() {

		for ( i = 0; i < tubularSegments; i ++ ) {

			generateSegment( i );

		}

		// if the geometry is not closed, generate the last row of vertices and normals
		// at the regular position on the given path
		//
		// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

		generateSegment( ( closed === false ) ? tubularSegments : 0 );

		// uvs are generated in a separate function.
		// this makes it easy compute correct values for closed geometries

		generateUVs();

		// finally create faces

		generateIndices();

	}

	function generateSegment( i ) {

		// we use getPointAt to sample evenly distributed points from the given path

		P = path.getPointAt( i / tubularSegments, P );

		// retrieve corresponding normal and binormal

		var N = frames.normals[ i ];
		var B = frames.binormals[ i ];

		// generate normals and vertices for the current segment

		for ( j = 0; j <= radialSegments; j ++ ) {

			var v = j / radialSegments * Math.PI * 2;

			var sin = Math.sin( v );
			var cos = - Math.cos( v );

			// normal

			normal.x = ( cos * N.x + sin * B.x );
			normal.y = ( cos * N.y + sin * B.y );
			normal.z = ( cos * N.z + sin * B.z );
			normal.normalize();

			normals.push( normal.x, normal.y, normal.z );

			// vertex

			vertex.x = P.x + radius * normal.x;
			vertex.y = P.y + radius * normal.y;
			vertex.z = P.z + radius * normal.z;

			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	}

	function generateIndices() {

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

	}

	function generateUVs() {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			for ( j = 0; j <= radialSegments; j ++ ) {

				uv.x = i / tubularSegments;
				uv.y = j / radialSegments;

				uvs.push( uv.x, uv.y );

			}

		}

	}

}

TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

TubeBufferGeometry.prototype.toJSON = function () {

	var data = BufferGeometry.prototype.toJSON.call( this );

	data.path = this.parameters.path.toJSON();

	return data;

};

/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */

// TorusKnotGeometry

function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

	Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
	this.mergeVertices();

}

TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

// TorusKnotBufferGeometry

function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

	BufferGeometry.call( this );

	this.type = 'TorusKnotBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	radius = radius || 1;
	tube = tube || 0.4;
	tubularSegments = Math.floor( tubularSegments ) || 64;
	radialSegments = Math.floor( radialSegments ) || 8;
	p = p || 2;
	q = q || 3;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var i, j;

	var vertex = new Vector3();
	var normal = new Vector3();

	var P1 = new Vector3();
	var P2 = new Vector3();

	var B = new Vector3();
	var T = new Vector3();
	var N = new Vector3();

	// generate vertices, normals and uvs

	for ( i = 0; i <= tubularSegments; ++ i ) {

		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

		var u = i / tubularSegments * p * Math.PI * 2;

		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

		calculatePositionOnCurve( u, p, q, radius, P1 );
		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

		// calculate orthonormal basis

		T.subVectors( P2, P1 );
		N.addVectors( P2, P1 );
		B.crossVectors( T, N );
		N.crossVectors( B, T );

		// normalize B, N. T can be ignored, we don't use it

		B.normalize();
		N.normalize();

		for ( j = 0; j <= radialSegments; ++ j ) {

			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

			var v = j / radialSegments * Math.PI * 2;
			var cx = - tube * Math.cos( v );
			var cy = tube * Math.sin( v );

			// now calculate the final vertex position.
			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

			vertex.x = P1.x + ( cx * N.x + cy * B.x );
			vertex.y = P1.y + ( cx * N.y + cy * B.y );
			vertex.z = P1.z + ( cx * N.z + cy * B.z );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

			normal.subVectors( vertex, P1 ).normalize();

			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( i / tubularSegments );
			uvs.push( j / radialSegments );

		}

	}

	// generate indices

	for ( j = 1; j <= tubularSegments; j ++ ) {

		for ( i = 1; i <= radialSegments; i ++ ) {

			// indices

			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
			var b = ( radialSegments + 1 ) * j + ( i - 1 );
			var c = ( radialSegments + 1 ) * j + i;
			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// this function calculates the current position on the torus curve

	function calculatePositionOnCurve( u, p, q, radius, position ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = q / p * u;
		var cs = Math.cos( quOverP );

		position.x = radius * ( 2 + cs ) * 0.5 * cu;
		position.y = radius * ( 2 + cs ) * su * 0.5;
		position.z = radius * Math.sin( quOverP ) * 0.5;

	}

}

TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// TorusGeometry

function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

	Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
	this.mergeVertices();

}

TorusGeometry.prototype = Object.create( Geometry.prototype );
TorusGeometry.prototype.constructor = TorusGeometry;

// TorusBufferGeometry

function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

	BufferGeometry.call( this );

	this.type = 'TorusBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 1;
	tube = tube || 0.4;
	radialSegments = Math.floor( radialSegments ) || 8;
	tubularSegments = Math.floor( tubularSegments ) || 6;
	arc = arc || Math.PI * 2;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var center = new Vector3();
	var vertex = new Vector3();
	var normal = new Vector3();

	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= radialSegments; j ++ ) {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			// vertex

			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );
			normal.subVectors( vertex, center ).normalize();

			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( i / tubularSegments );
			uvs.push( j / radialSegments );

		}

	}

	// generate indices

	for ( j = 1; j <= radialSegments; j ++ ) {

		for ( i = 1; i <= tubularSegments; i ++ ) {

			// indices

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 * Port from https://github.com/mapbox/earcut (v2.1.5)
 */

var Earcut = {

	triangulate: function ( data, holeIndices, dim ) {

		dim = dim || 2;

		var hasHoles = holeIndices && holeIndices.length,
			outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
			outerNode = linkedList( data, 0, outerLen, dim, true ),
			triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		var minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( var i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 1 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	var i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	var p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	var stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim );
			triangles.push( ear.i / dim );
			triangles.push( next.i / dim );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( ear, triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	var a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	var p = ear.next.next;

	while ( p !== ear.prev ) {

		if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	var a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// triangle bbox; min & max are calculated like this for speed
	var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
		minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
		maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
		maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

	// z-order range for the current triangle bbox;
	var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
		maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

	var p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	var p = start;
	do {

		var a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim );
			triangles.push( p.i / dim );
			triangles.push( b.i / dim );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return p;

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	var a = start;
	do {

		var b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				var c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize );
				earcutLinked( c, triangles, dim, minX, minY, invSize );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	var queue = [],
		i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		eliminateHole( queue[ i ], outerNode );
		outerNode = filterPoints( outerNode, outerNode.next );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole( hole, outerNode ) {

	outerNode = findHoleBridge( hole, outerNode );
	if ( outerNode ) {

		var b = splitPolygon( outerNode, hole );
		filterPoints( b, b.next );

	}

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	var p = outerNode,
		hx = hole.x,
		hy = hole.y,
		qx = - Infinity,
		m;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				if ( x === hx ) {

					if ( hy === p.y ) return p;
					if ( hy === p.next.y ) return p.next;

				}

				m = p.x < p.next.x ? p : p.next;

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	var stop = m,
		mx = m.x,
		my = m.y,
		tanMin = Infinity,
		tan;

	p = m.next;

	while ( p !== stop ) {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	}

	return m;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	var p = start;
	do {

		if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	var i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = 32767 * ( x - minX ) * invSize;
	y = 32767 * ( y - minY ) * invSize;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	var p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
		   ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
		   ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
		   locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	if ( ( equals( p1, p2 ) && equals( q1, q2 ) ) ||
		( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;
	return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
		   area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	var p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	var p = a,
		inside = false,
		px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	var a2 = new Node( a.i, a.x, a.y ),
		b2 = new Node( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	var p = new Node( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = null;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	var sum = 0;
	for ( var i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

var ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	isClockWise: function ( pts ) {

		return ShapeUtils.area( pts ) < 0;

	},

	triangulateShape: function ( contour, holes ) {

		var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		var holeIndices = []; // array of hole indices
		var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		var holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( var i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		var triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( var i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

};

function removeDupEndPts( points ) {

	var l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( var i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

// ExtrudeGeometry

function ExtrudeGeometry( shapes, options ) {

	Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	this.parameters = {
		shapes: shapes,
		options: options
	};

	this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
	this.mergeVertices();

}

ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

ExtrudeGeometry.prototype.toJSON = function () {

	var data = Geometry.prototype.toJSON.call( this );

	var shapes = this.parameters.shapes;
	var options = this.parameters.options;

	return toJSON( shapes, options, data );

};

// ExtrudeBufferGeometry

function ExtrudeBufferGeometry( shapes, options ) {

	BufferGeometry.call( this );

	this.type = 'ExtrudeBufferGeometry';

	this.parameters = {
		shapes: shapes,
		options: options
	};

	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

	var scope = this;

	var verticesArray = [];
	var uvArray = [];

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		var shape = shapes[ i ];
		addShape( shape );

	}

	// build geometry

	this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

	this.computeVertexNormals();

	// functions

	function addShape( shape ) {

		var placeholder = [];

		// options

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
		var steps = options.steps !== undefined ? options.steps : 1;
		var depth = options.depth !== undefined ? options.depth : 100;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
		var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var extrudePath = options.extrudePath;

		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

		// deprecated options

		if ( options.amount !== undefined ) {

			console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
			depth = options.amount;

		}

		//

		var extrudePts, extrudeByPath = false;
		var splineTube, binormal, normal, position2;

		if ( extrudePath ) {

			extrudePts = extrudePath.getSpacedPoints( steps );

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// TODO1 - have a .isClosed in spline?

			splineTube = extrudePath.computeFrenetFrames( steps, false );

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new Vector3();
			normal = new Vector3();
			position2 = new Vector3();

		}

		// Safeguards if bevels are not enabled

		if ( ! bevelEnabled ) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;
			bevelOffset = 0;

		}

		// Variables initialization

		var ahole, h, hl; // looping of holes

		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! ShapeUtils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				if ( ShapeUtils.isClockWise( ahole ) ) {

					holes[ h ] = ahole.reverse();

				}

			}

		}


		var faces = ShapeUtils.triangulateShape( vertices, holes );

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			vertices = vertices.concat( ahole );

		}


		function scalePt2( pt, vec, size ) {

			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

			return vec.clone().multiplyScalar( size ).add( pt );

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;


		// Find directions for point movement


		function getBevelVec( inPt, inPrev, inNext ) {

			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.

			var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x,
				v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x,
				v_next_y = inNext.y - inPt.y;

			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			if ( Math.abs( collinear0 ) > Number.EPSILON ) {

				// not collinear

				// length of vectors for normalizing

				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

				// shift adjacent points by unit vectors to the left

				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

				// scaling factor for v_prev to intersection point

				var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
					( v_prev_x * v_next_y - v_prev_y * v_next_x );

				// vector from inPt to intersection point

				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {

					return new Vector2( v_trans_x, v_trans_y );

				} else {

					shrink_by = Math.sqrt( v_trans_lensq / 2 );

				}

			} else {

				// handle special case of collinear edges

				var direction_eq = false; // assumes: opposite
				if ( v_prev_x > Number.EPSILON ) {

					if ( v_next_x > Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( v_prev_x < - Number.EPSILON ) {

						if ( v_next_x < - Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

							direction_eq = true;

						}

					}

				}

				if ( direction_eq ) {

					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y = v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );

				} else {

					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );

				}

			}

			return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

		}


		var contourMovements = [];

		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

		}

		var holesMovements = [],
			oneHoleMovements, verticesMovements = contourMovements.concat();

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			oneHoleMovements = [];

			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

			}

			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for ( b = 0; b < bevelSegments; b ++ ) {

			//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * Math.cos( t * Math.PI / 2 );
			bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

				v( vert.x, vert.y, - z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

			}

		}

		bs = bevelSize + bevelOffset;

		// Back facing vertices

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, 0 );

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for ( s = 1; s <= steps; s ++ ) {

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, depth / steps * s );

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * Math.cos( t * Math.PI / 2 );
			bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y, depth + z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth + z );

					} else {

						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			var start = verticesArray.length / 3;

			if ( bevelEnabled ) {

				var layer = 0; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

				}

			} else {

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

				}

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

				}

			}

			scope.addGroup( start, verticesArray.length / 3 - start, 0 );

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var start = verticesArray.length / 3;
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );

				//, true
				layeroffset += ahole.length;

			}


			scope.addGroup( start, verticesArray.length / 3 - start, 1 );


		}

		function sidewalls( contour, layeroffset ) {

			var j, k;
			i = contour.length;

			while ( -- i >= 0 ) {

				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0,
					sl = steps + bevelSegments * 2;

				for ( s = 0; s < sl; s ++ ) {

					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4( a, b, c, d );

				}

			}

		}

		function v( x, y, z ) {

			placeholder.push( x );
			placeholder.push( y );
			placeholder.push( z );

		}


		function f3( a, b, c ) {

			addVertex( a );
			addVertex( b );
			addVertex( c );

			var nextIndex = verticesArray.length / 3;
			var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

			addUV( uvs[ 0 ] );
			addUV( uvs[ 1 ] );
			addUV( uvs[ 2 ] );

		}

		function f4( a, b, c, d ) {

			addVertex( a );
			addVertex( b );
			addVertex( d );

			addVertex( b );
			addVertex( c );
			addVertex( d );


			var nextIndex = verticesArray.length / 3;
			var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

			addUV( uvs[ 0 ] );
			addUV( uvs[ 1 ] );
			addUV( uvs[ 3 ] );

			addUV( uvs[ 1 ] );
			addUV( uvs[ 2 ] );
			addUV( uvs[ 3 ] );

		}

		function addVertex( index ) {

			verticesArray.push( placeholder[ index * 3 + 0 ] );
			verticesArray.push( placeholder[ index * 3 + 1 ] );
			verticesArray.push( placeholder[ index * 3 + 2 ] );

		}


		function addUV( vector2 ) {

			uvArray.push( vector2.x );
			uvArray.push( vector2.y );

		}

	}

}

ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

ExtrudeBufferGeometry.prototype.toJSON = function () {

	var data = BufferGeometry.prototype.toJSON.call( this );

	var shapes = this.parameters.shapes;
	var options = this.parameters.options;

	return toJSON( shapes, options, data );

};

//

var WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		var a_x = vertices[ indexA * 3 ];
		var a_y = vertices[ indexA * 3 + 1 ];
		var b_x = vertices[ indexB * 3 ];
		var b_y = vertices[ indexB * 3 + 1 ];
		var c_x = vertices[ indexC * 3 ];
		var c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		var a_x = vertices[ indexA * 3 ];
		var a_y = vertices[ indexA * 3 + 1 ];
		var a_z = vertices[ indexA * 3 + 2 ];
		var b_x = vertices[ indexB * 3 ];
		var b_y = vertices[ indexB * 3 + 1 ];
		var b_z = vertices[ indexB * 3 + 2 ];
		var c_x = vertices[ indexC * 3 ];
		var c_y = vertices[ indexC * 3 + 1 ];
		var c_z = vertices[ indexC * 3 + 2 ];
		var d_x = vertices[ indexD * 3 ];
		var d_y = vertices[ indexD * 3 + 1 ];
		var d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < 0.01 ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}
};

function toJSON( shapes, options, data ) {

	//

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			var shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	//

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */

// TextGeometry

function TextGeometry( text, parameters ) {

	Geometry.call( this );

	this.type = 'TextGeometry';

	this.parameters = {
		text: text,
		parameters: parameters
	};

	this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
	this.mergeVertices();

}

TextGeometry.prototype = Object.create( Geometry.prototype );
TextGeometry.prototype.constructor = TextGeometry;

// TextBufferGeometry

function TextBufferGeometry( text, parameters ) {

	parameters = parameters || {};

	var font = parameters.font;

	if ( ! ( font && font.isFont ) ) {

		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
		return new Geometry();

	}

	var shapes = font.generateShapes( text, parameters.size );

	// translate parameters to ExtrudeGeometry API

	parameters.depth = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	ExtrudeBufferGeometry.call( this, shapes, parameters );

	this.type = 'TextBufferGeometry';

}

TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
TextBufferGeometry.prototype.constructor = TextBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */

// SphereGeometry

function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	this.mergeVertices();

}

SphereGeometry.prototype = Object.create( Geometry.prototype );
SphereGeometry.prototype.constructor = SphereGeometry;

// SphereBufferGeometry

function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 1;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

	var ix, iy;

	var index = 0;
	var grid = [];

	var vertex = new Vector3();
	var normal = new Vector3();

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// generate vertices, normals and uvs

	for ( iy = 0; iy <= heightSegments; iy ++ ) {

		var verticesRow = [];

		var v = iy / heightSegments;

		// special case for the poles

		var uOffset = 0;

		if ( iy == 0 && thetaStart == 0 ) {

			uOffset = 0.5 / widthSegments;

		} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

			uOffset = - 0.5 / widthSegments;

		}

		for ( ix = 0; ix <= widthSegments; ix ++ ) {

			var u = ix / widthSegments;

			// vertex

			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normal.copy( vertex ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u + uOffset, 1 - v );

			verticesRow.push( index ++ );

		}

		grid.push( verticesRow );

	}

	// indices

	for ( iy = 0; iy < heightSegments; iy ++ ) {

		for ( ix = 0; ix < widthSegments; ix ++ ) {

			var a = grid[ iy ][ ix + 1 ];
			var b = grid[ iy ][ ix ];
			var c = grid[ iy + 1 ][ ix ];
			var d = grid[ iy + 1 ][ ix + 1 ];

			if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
			if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */

// RingGeometry

function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
	this.mergeVertices();

}

RingGeometry.prototype = Object.create( Geometry.prototype );
RingGeometry.prototype.constructor = RingGeometry;

// RingBufferGeometry

function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'RingBufferGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 0.5;
	outerRadius = outerRadius || 1;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// some helper variables

	var segment;
	var radius = innerRadius;
	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	var vertex = new Vector3();
	var uv = new Vector2();
	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= phiSegments; j ++ ) {

		for ( i = 0; i <= thetaSegments; i ++ ) {

			// values are generate from the inside of the ring to the outside

			segment = thetaStart + i / thetaSegments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uv

			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
			uv.y = ( vertex.y / outerRadius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// increase the radius for next row of vertices

		radius += radiusStep;

	}

	// indices

	for ( j = 0; j < phiSegments; j ++ ) {

		var thetaSegmentLevel = j * ( thetaSegments + 1 );

		for ( i = 0; i < thetaSegments; i ++ ) {

			segment = i + thetaSegmentLevel;

			var a = segment;
			var b = segment + thetaSegments + 1;
			var c = segment + thetaSegments + 2;
			var d = segment + 1;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
RingBufferGeometry.prototype.constructor = RingBufferGeometry;

/**
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */

// LatheGeometry

function LatheGeometry( points, segments, phiStart, phiLength ) {

	Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
	this.mergeVertices();

}

LatheGeometry.prototype = Object.create( Geometry.prototype );
LatheGeometry.prototype.constructor = LatheGeometry;

// LatheBufferGeometry

function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

	BufferGeometry.call( this );

	this.type = 'LatheBufferGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = Math.floor( segments ) || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || Math.PI * 2;

	// clamp phiLength so it's in range of [ 0, 2PI ]

	phiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );


	// buffers

	var indices = [];
	var vertices = [];
	var uvs = [];

	// helper variables

	var base;
	var inverseSegments = 1.0 / segments;
	var vertex = new Vector3();
	var uv = new Vector2();
	var i, j;

	// generate vertices and uvs

	for ( i = 0; i <= segments; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var sin = Math.sin( phi );
		var cos = Math.cos( phi );

		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

			// vertex

			vertex.x = points[ j ].x * sin;
			vertex.y = points[ j ].y;
			vertex.z = points[ j ].x * cos;

			vertices.push( vertex.x, vertex.y, vertex.z );

			// uv

			uv.x = i / segments;
			uv.y = j / ( points.length - 1 );

			uvs.push( uv.x, uv.y );


		}

	}

	// indices

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

			base = j + i * points.length;

			var a = base;
			var b = base + points.length;
			var c = base + points.length + 1;
			var d = base + 1;

			// faces

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// generate normals

	this.computeVertexNormals();

	// if the geometry is closed, we need to average the normals along the seam.
	// because the corresponding vertices are identical (but still have different UVs).

	if ( phiLength === Math.PI * 2 ) {

		var normals = this.attributes.normal.array;
		var n1 = new Vector3();
		var n2 = new Vector3();
		var n = new Vector3();

		// this is the buffer offset for the last line of vertices

		base = segments * points.length * 3;

		for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

			// select the normal of the vertex in the first line

			n1.x = normals[ j + 0 ];
			n1.y = normals[ j + 1 ];
			n1.z = normals[ j + 2 ];

			// select the normal of the vertex in the last line

			n2.x = normals[ base + j + 0 ];
			n2.y = normals[ base + j + 1 ];
			n2.z = normals[ base + j + 2 ];

			// average normals

			n.addVectors( n1, n2 ).normalize();

			// assign the new values to both normals

			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

		}

	}

}

LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */

// ShapeGeometry

function ShapeGeometry( shapes, curveSegments ) {

	Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( typeof curveSegments === 'object' ) {

		console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

		curveSegments = curveSegments.curveSegments;

	}

	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};

	this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
	this.mergeVertices();

}

ShapeGeometry.prototype = Object.create( Geometry.prototype );
ShapeGeometry.prototype.constructor = ShapeGeometry;

ShapeGeometry.prototype.toJSON = function () {

	var data = Geometry.prototype.toJSON.call( this );

	var shapes = this.parameters.shapes;

	return toJSON$1( shapes, data );

};

// ShapeBufferGeometry

function ShapeBufferGeometry( shapes, curveSegments ) {

	BufferGeometry.call( this );

	this.type = 'ShapeBufferGeometry';

	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};

	curveSegments = curveSegments || 12;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var groupStart = 0;
	var groupCount = 0;

	// allow single and array values for "shapes" parameter

	if ( Array.isArray( shapes ) === false ) {

		addShape( shapes );

	} else {

		for ( var i = 0; i < shapes.length; i ++ ) {

			addShape( shapes[ i ] );

			this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

			groupStart += groupCount;
			groupCount = 0;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


	// helper functions

	function addShape( shape ) {

		var i, l, shapeHole;

		var indexOffset = vertices.length / 3;
		var points = shape.extractPoints( curveSegments );

		var shapeVertices = points.shape;
		var shapeHoles = points.holes;

		// check direction of vertices

		if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

			shapeVertices = shapeVertices.reverse();

		}

		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

			shapeHole = shapeHoles[ i ];

			if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

				shapeHoles[ i ] = shapeHole.reverse();

			}

		}

		var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

		// join vertices of inner and outer paths to a single array

		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

			shapeHole = shapeHoles[ i ];
			shapeVertices = shapeVertices.concat( shapeHole );

		}

		// vertices, normals, uvs

		for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

			var vertex = shapeVertices[ i ];

			vertices.push( vertex.x, vertex.y, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( vertex.x, vertex.y ); // world uvs

		}

		// incides

		for ( i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var a = face[ 0 ] + indexOffset;
			var b = face[ 1 ] + indexOffset;
			var c = face[ 2 ] + indexOffset;

			indices.push( a, b, c );
			groupCount += 3;

		}

	}

}

ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

ShapeBufferGeometry.prototype.toJSON = function () {

	var data = BufferGeometry.prototype.toJSON.call( this );

	var shapes = this.parameters.shapes;

	return toJSON$1( shapes, data );

};

//

function toJSON$1( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			var shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */

function EdgesGeometry( geometry, thresholdAngle ) {

	BufferGeometry.call( this );

	this.type = 'EdgesGeometry';

	this.parameters = {
		thresholdAngle: thresholdAngle
	};

	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

	// buffer

	var vertices = [];

	// helper variables

	var thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );
	var edge = [ 0, 0 ], edges = {}, edge1, edge2;
	var key, keys = [ 'a', 'b', 'c' ];

	// prepare source geometry

	var geometry2;

	if ( geometry.isBufferGeometry ) {

		geometry2 = new Geometry();
		geometry2.fromBufferGeometry( geometry );

	} else {

		geometry2 = geometry.clone();

	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var sourceVertices = geometry2.vertices;
	var faces = geometry2.faces;

	// now create a data structure where each entry represents an edge with its adjoining faces

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge1 = face[ keys[ j ] ];
			edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
			edge[ 0 ] = Math.min( edge1, edge2 );
			edge[ 1 ] = Math.max( edge1, edge2 );

			key = edge[ 0 ] + ',' + edge[ 1 ];

			if ( edges[ key ] === undefined ) {

				edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

			} else {

				edges[ key ].face2 = i;

			}

		}

	}

	// generate vertices

	for ( key in edges ) {

		var e = edges[ key ];

		// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

		if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

			var vertex = sourceVertices[ e.index1 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

			vertex = sourceVertices[ e.index2 ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	}

	// build geometry

	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

}

EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
EdgesGeometry.prototype.constructor = EdgesGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// CylinderGeometry

function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
	this.mergeVertices();

}

CylinderGeometry.prototype = Object.create( Geometry.prototype );
CylinderGeometry.prototype.constructor = CylinderGeometry;

// CylinderBufferGeometry

function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'CylinderBufferGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	var scope = this;

	radiusTop = radiusTop !== undefined ? radiusTop : 1;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
	height = height || 1;

	radialSegments = Math.floor( radialSegments ) || 8;
	heightSegments = Math.floor( heightSegments ) || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var index = 0;
	var indexArray = [];
	var halfHeight = height / 2;
	var groupStart = 0;

	// generate geometry

	generateTorso();

	if ( openEnded === false ) {

		if ( radiusTop > 0 ) generateCap( true );
		if ( radiusBottom > 0 ) generateCap( false );

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	function generateTorso() {

		var x, y;
		var normal = new Vector3();
		var vertex = new Vector3();

		var groupCount = 0;

		// this will be used to calculate the normal
		var slope = ( radiusBottom - radiusTop ) / height;

		// generate vertices, normals and uvs

		for ( y = 0; y <= heightSegments; y ++ ) {

			var indexRow = [];

			var v = y / heightSegments;

			// calculate the radius of the current row

			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var theta = u * thetaLength + thetaStart;

				var sinTheta = Math.sin( theta );
				var cosTheta = Math.cos( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = - v * height + halfHeight;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.set( sinTheta, slope, cosTheta ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, 1 - v );

				// save index of vertex in respective row

				indexRow.push( index ++ );

			}

			// now save vertices of the row in our index array

			indexArray.push( indexRow );

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			for ( y = 0; y < heightSegments; y ++ ) {

				// we use the index array to access the correct indices

				var a = indexArray[ y ][ x ];
				var b = indexArray[ y + 1 ][ x ];
				var c = indexArray[ y + 1 ][ x + 1 ];
				var d = indexArray[ y ][ x + 1 ];

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

				// update group counter

				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, 0 );

		// calculate new start value for groups

		groupStart += groupCount;

	}

	function generateCap( top ) {

		var x, centerIndexStart, centerIndexEnd;

		var uv = new Vector2();
		var vertex = new Vector3();

		var groupCount = 0;

		var radius = ( top === true ) ? radiusTop : radiusBottom;
		var sign = ( top === true ) ? 1 : - 1;

		// save the index of the first center vertex
		centerIndexStart = index;

		// first we generate the center vertex data of the cap.
		// because the geometry needs one set of uvs per face,
		// we must generate a center vertex per face/segment

		for ( x = 1; x <= radialSegments; x ++ ) {

			// vertex

			vertices.push( 0, halfHeight * sign, 0 );

			// normal

			normals.push( 0, sign, 0 );

			// uv

			uvs.push( 0.5, 0.5 );

			// increase index

			index ++;

		}

		// save the index of the last center vertex

		centerIndexEnd = index;

		// now we generate the surrounding vertices, normals and uvs

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;
			var theta = u * thetaLength + thetaStart;

			var cosTheta = Math.cos( theta );
			var sinTheta = Math.sin( theta );

			// vertex

			vertex.x = radius * sinTheta;
			vertex.y = halfHeight * sign;
			vertex.z = radius * cosTheta;
			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, sign, 0 );

			// uv

			uv.x = ( cosTheta * 0.5 ) + 0.5;
			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
			uvs.push( uv.x, uv.y );

			// increase index

			index ++;

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			var c = centerIndexStart + x;
			var i = centerIndexEnd + x;

			if ( top === true ) {

				// face top

				indices.push( i, i + 1, c );

			} else {

				// face bottom

				indices.push( i + 1, i, c );

			}

			groupCount += 3;

		}

		// add a group to the geometry. this will ensure multi material support

		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

		// calculate new start value for groups

		groupStart += groupCount;

	}

}

CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

/**
 * @author abelnation / http://github.com/abelnation
 */

// ConeGeometry

function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	this.type = 'ConeGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

}

ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
ConeGeometry.prototype.constructor = ConeGeometry;

// ConeBufferGeometry

function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	this.type = 'ConeBufferGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

}

ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */

// CircleGeometry

function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	this.mergeVertices();

}

CircleGeometry.prototype = Object.create( Geometry.prototype );
CircleGeometry.prototype.constructor = CircleGeometry;

// CircleBufferGeometry

function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'CircleBufferGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 1;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// helper variables

	var i, s;
	var vertex = new Vector3();
	var uv = new Vector2();

	// center point

	vertices.push( 0, 0, 0 );
	normals.push( 0, 0, 1 );
	uvs.push( 0.5, 0.5 );

	for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

		var segment = thetaStart + s / segments * thetaLength;

		// vertex

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		vertices.push( vertex.x, vertex.y, vertex.z );

		// normal

		normals.push( 0, 0, 1 );

		// uvs

		uv.x = ( vertices[ i ] / radius + 1 ) / 2;
		uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

		uvs.push( uv.x, uv.y );

	}

	// indices

	for ( i = 1; i <= segments; i ++ ) {

		indices.push( i, i + 1, 0 );

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	WireframeGeometry: WireframeGeometry,
	ParametricGeometry: ParametricGeometry,
	ParametricBufferGeometry: ParametricBufferGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronBufferGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronBufferGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronBufferGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronBufferGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronBufferGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeBufferGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusBufferGeometry,
	TextGeometry: TextGeometry,
	TextBufferGeometry: TextBufferGeometry,
	SphereGeometry: SphereGeometry,
	SphereBufferGeometry: SphereBufferGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingBufferGeometry,
	PlaneGeometry: PlaneGeometry,
	PlaneBufferGeometry: PlaneBufferGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheBufferGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeBufferGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	ExtrudeBufferGeometry: ExtrudeBufferGeometry,
	EdgesGeometry: EdgesGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeBufferGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderBufferGeometry,
	CircleGeometry: CircleGeometry,
	CircleBufferGeometry: CircleBufferGeometry,
	BoxGeometry: BoxGeometry,
	BoxBufferGeometry: BoxBufferGeometry
});

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

function ShadowMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShadowMaterial';

	this.color = new Color( 0x000000 );
	this.transparent = true;

	this.setValues( parameters );

}

ShadowMaterial.prototype = Object.create( Material.prototype );
ShadowMaterial.prototype.constructor = ShadowMaterial;

ShadowMaterial.prototype.isShadowMaterial = true;

ShadowMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function RawShaderMaterial( parameters ) {

	ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

}

RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
RawShaderMaterial.prototype.constructor = RawShaderMaterial;

RawShaderMaterial.prototype.isRawShaderMaterial = true;

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.roughness = 1.0;
	this.metalness = 0.0;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.vertexTangents = false;

	this.setValues( parameters );

}

MeshStandardMaterial.prototype = Object.create( Material.prototype );
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.vertexTangents = source.vertexTangents;

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *
 *  sheen: <Color>,
 *
 *  transparency: <float>
 * }
 */

function MeshPhysicalMaterial( parameters ) {

	MeshStandardMaterial.call( this );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.type = 'MeshPhysicalMaterial';

	this.clearcoat = 0.0;
	this.clearcoatMap = null;
	this.clearcoatRoughness = 0.0;
	this.clearcoatRoughnessMap = null;
	this.clearcoatNormalScale = new Vector2( 1, 1 );
	this.clearcoatNormalMap = null;

	this.reflectivity = 0.5; // maps to F0 = 0.04

	this.sheen = null; // null will disable sheen bsdf

	this.transparency = 0.0;

	this.setValues( parameters );

}

MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function ( source ) {

	MeshStandardMaterial.prototype.copy.call( this, source );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.clearcoat = source.clearcoat;
	this.clearcoatMap = source.clearcoatMap;
	this.clearcoatRoughness = source.clearcoatRoughness;
	this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
	this.clearcoatNormalMap = source.clearcoatNormalMap;
	this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

	this.reflectivity = source.reflectivity;

	if ( source.sheen ) {

		this.sheen = ( this.sheen || new Color() ).copy( source.sheen );

	} else {

		this.sheen = null;

	}

	this.transparency = source.transparency;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshPhongMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.specular = new Color( 0x111111 );
	this.shininess = 30;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshPhongMaterial.prototype = Object.create( Material.prototype );
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshToonMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'TOON': '' };

	this.type = 'MeshToonMaterial';

	this.color = new Color( 0xffffff );
	this.specular = new Color( 0x111111 );
	this.shininess = 30;

	this.map = null;
	this.gradientMap = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshToonMaterial.prototype = Object.create( Material.prototype );
MeshToonMaterial.prototype.constructor = MeshToonMaterial;

MeshToonMaterial.prototype.isMeshToonMaterial = true;

MeshToonMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.map = source.map;
	this.gradientMap = source.gradientMap;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshNormalMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshNormalMaterial';

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshNormalMaterial.prototype = Object.create( Material.prototype );
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

MeshNormalMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshLambertMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new Color( 0xffffff ); // diffuse

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshLambertMaterial.prototype = Object.create( Material.prototype );
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshMatcapMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'MATCAP': '' };

	this.type = 'MeshMatcapMaterial';

	this.color = new Color( 0xffffff ); // diffuse

	this.matcap = null;

	this.map = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.alphaMap = null;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshMatcapMaterial.prototype = Object.create( Material.prototype );
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

MeshMatcapMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'MATCAP': '' };

	this.color.copy( source.color );

	this.matcap = source.matcap;

	this.map = source.map;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.alphaMap = source.alphaMap;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

function LineDashedMaterial( parameters ) {

	LineBasicMaterial.call( this );

	this.type = 'LineDashedMaterial';

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.setValues( parameters );

}

LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
LineDashedMaterial.prototype.constructor = LineDashedMaterial;

LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function ( source ) {

	LineBasicMaterial.prototype.copy.call( this, source );

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	return this;

};



var Materials = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshToonMaterial: MeshToonMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshDistanceMaterial: MeshDistanceMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	MeshMatcapMaterial: MeshMatcapMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});

/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

var AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		var n = times.length;
		var result = new Array( n );
		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		var nValues = values.length;
		var result = new values.constructor( nValues );

		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			var srcOffset = order[ i ] * stride;

			for ( var j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		var i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		var value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	},

	subclip: function ( sourceClip, name, startFrame, endFrame, fps ) {

		fps = fps || 30;

		var clip = sourceClip.clone();

		clip.name = name;

		var tracks = [];

		for ( var i = 0; i < clip.tracks.length; ++ i ) {

			var track = clip.tracks[ i ];
			var valueSize = track.getValueSize();

			var times = [];
			var values = [];

			for ( var j = 0; j < track.times.length; ++ j ) {

				var frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( var k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = AnimationUtils.convertArray( times, track.times.constructor );
			track.values = AnimationUtils.convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		var minStartTime = Infinity;

		for ( var i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( var i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
		resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

}

Object.assign( Interpolant.prototype, {

	evaluate: function ( t ) {

		var pp = this.parameterPositions,
			i1 = this._cachedIndex,

			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				var right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( var giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						var t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( var giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					var mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function () {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function ( index ) {

		// copies a sample value to the result buffer

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function ( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function ( /* i1, t0, t1 */ ) {

		// empty

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( Interpolant.prototype, {

	//( 0, t, t0 ), returns this.resultBuffer
	beforeStart_: Interpolant.prototype.copySampleValue_,

	//( N-1, tN-1, t ), returns this.resultBuffer
	afterEnd_: Interpolant.prototype.copySampleValue_,

} );

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = - 0;
	this._offsetPrev = - 0;
	this._weightNext = - 0;
	this._offsetNext = - 0;

}

CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: CubicInterpolant,

	DefaultSettings_: {

		endingStart: ZeroCurvatureEnding,
		endingEnd: ZeroCurvatureEnding

	},

	intervalChanged_: function ( i1, t0, t1 ) {

		var pp = this.parameterPositions,
			iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		var halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function ( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		var sP = - wP * ppp + 2 * wP * pp - wP * p;
		var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		var sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );

/**
 * @author tschw
 */

function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: LinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: DiscreteInterpolant,

	interpolate_: function ( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );

/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function KeyframeTrack( name, times, values, interpolation ) {

	if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
	if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

	this.name = name;

	this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
	this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

	this.setInterpolation( interpolation || this.DefaultInterpolation );

}

// Static methods

Object.assign( KeyframeTrack, {

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	toJSON: function ( track ) {

		var trackType = track.constructor;

		var json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== undefined ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			var interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

} );

Object.assign( KeyframeTrack.prototype, {

	constructor: KeyframeTrack,

	TimeBufferType: Float32Array,

	ValueBufferType: Float32Array,

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodDiscrete: function ( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodLinear: function ( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: function ( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	setInterpolation: function ( interpolation ) {

		var factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			var message = "unsupported interpolation for " +
				this.ValueTypeName + " keyframe track named " + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	},

	getInterpolation: function () {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	},

	getValueSize: function () {

		return this.values.length / this.times.length;

	},

	// move all keyframes either forwards or backwards in time
	shift: function ( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function ( timeScale ) {

		if ( timeScale !== 1.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim: function ( startTime, endTime ) {

		var times = this.times,
			nKeys = times.length,
			from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			var stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	},

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate: function () {

		var valid = true;

		var valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		var times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		var prevTime = null;

		for ( var i = 0; i !== nKeys; i ++ ) {

			var currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( var i = 0, n = values.length; i !== n; ++ i ) {

					var value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	},

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize: function () {

		// times or values may be shared with other tracks, so overwriting is unsafe
		var times = AnimationUtils.arraySlice( this.times ),
			values = AnimationUtils.arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			writeIndex = 1,
			lastIndex = times.length - 1;

		for ( var i = 1; i < lastIndex; ++ i ) {

			var keep = false;

			var time = times[ i ];
			var timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( var j = 0; j !== stride; ++ j ) {

						var value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					var readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( var j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	},

	clone: function () {

		var times = AnimationUtils.arraySlice( this.times, 0 );
		var values = AnimationUtils.arraySlice( this.values, 0 );

		var TypedKeyframeTrack = this.constructor;
		var track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

} );

/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function BooleanKeyframeTrack( name, times, values ) {

	KeyframeTrack.call( this, name, times, values );

}

BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: BooleanKeyframeTrack,

	ValueTypeName: 'bool',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined

	// Note: Actually this track could have a optimized / compressed
	// representation of a single value and a custom interpolant that
	// computes "firstValue ^ isOdd( index )".

} );

/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function ColorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: ColorKeyframeTrack,

	ValueTypeName: 'color'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

	// Note: Very basic implementation and nothing special yet.
	// However, this is the place for color space parameterization.

} );

/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function NumberKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: NumberKeyframeTrack,

	ValueTypeName: 'number'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: QuaternionLinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset = i1 * stride,

			alpha = ( t - t0 ) / ( t1 - t0 );

		for ( var end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );

/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function QuaternionKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: QuaternionKeyframeTrack,

	ValueTypeName: 'quaternion',

	// ValueBufferType is inherited

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodLinear: function ( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: undefined // not yet implemented

} );

/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function StringKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: StringKeyframeTrack,

	ValueTypeName: 'string',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,

	InterpolantFactoryMethodSmooth: undefined

} );

/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function VectorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrack.call( this, name, times, values, interpolation );

}

VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

	constructor: VectorKeyframeTrack,

	ValueTypeName: 'vector'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

function AnimationClip( name, duration, tracks ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : - 1;

	this.uuid = MathUtils.generateUUID();

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {

		this.resetDuration();

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	var trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		var times = [], values = [];

		AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

Object.assign( AnimationClip, {

	parse: function ( json ) {

		var tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		return new AnimationClip( json.name, json.duration, tracks );

	},

	toJSON: function ( clip ) {

		var tracks = [],
			clipTracks = clip.tracks;

		var json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid

		};

		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	},

	CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];

		for ( var i = 0; i < numMorphTargets; i ++ ) {

			var times = [];
			var values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			var order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new AnimationClip( name, - 1, tracks );

	},

	findByName: function ( objectOrClipArray, name ) {

		var clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			var o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( var i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	},

	CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

		var animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		var pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var name = parts[ 1 ];

				var animationMorphTargets = animationToMorphTargets[ name ];
				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		var clips = [];

		for ( var name in animationToMorphTargets ) {

			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	},

	// parse the animation.hierarchy format
	parseAnimation: function ( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				var times = [];
				var values = [];

				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		var tracks = [];

		var clipName = animation.name || 'default';
		// automatic length determination in AnimationClip.
		var duration = animation.length || - 1;
		var fps = animation.fps || 30;

		var hierarchyTracks = animation.hierarchy || [];

		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

			var animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				var morphTargetNames = {};

				for ( var k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( var morphTargetName in morphTargetNames ) {

					var times = [];
					var values = [];

					for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						var animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				// ...assume skeletal animation

				var boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		var clip = new AnimationClip( clipName, duration, tracks );

		return clip;

	}

} );

Object.assign( AnimationClip.prototype, {

	resetDuration: function () {

		var tracks = this.tracks, duration = 0;

		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

			var track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	},

	trim: function () {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	validate: function () {

		var valid = true;

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	},

	optimize: function () {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	},

	clone: function () {

		var tracks = [];

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new AnimationClip( this.name, this.duration, tracks );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LoadingManager( onLoad, onProgress, onError ) {

	var scope = this;

	var isLoading = false;
	var itemsLoaded = 0;
	var itemsTotal = 0;
	var urlModifier = undefined;
	var handlers = [];

	// Refer to #5689 for the reason why we don't set .onStart
	// in the constructor

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

	this.resolveURL = function ( url ) {

		if ( urlModifier ) {

			return urlModifier( url );

		}

		return url;

	};

	this.setURLModifier = function ( transform ) {

		urlModifier = transform;

		return this;

	};

	this.addHandler = function ( regex, loader ) {

		handlers.push( regex, loader );

		return this;

	};

	this.removeHandler = function ( regex ) {

		var index = handlers.indexOf( regex );

		if ( index !== - 1 ) {

			handlers.splice( index, 2 );

		}

		return this;

	};

	this.getHandler = function ( file ) {

		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

			var regex = handlers[ i ];
			var loader = handlers[ i + 1 ];

			if ( regex.global ) regex.lastIndex = 0; // see #17920

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	};

}

var DefaultLoadingManager = new LoadingManager();

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Loader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	this.crossOrigin = 'anonymous';
	this.path = '';
	this.resourcePath = '';

}

Object.assign( Loader.prototype, {

	load: function ( /* url, onLoad, onProgress, onError */ ) {},

	parse: function ( /* data */ ) {},

	setCrossOrigin: function ( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	},

	setPath: function ( path ) {

		this.path = path;
		return this;

	},

	setResourcePath: function ( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var loading = {};

function FileLoader( manager ) {

	Loader.call( this, manager );

}

FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: FileLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Check for data: URI
		var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		var dataUriRegexResult = url.match( dataUriRegex );

		// Safari can not handle Data URIs through XMLHttpRequest so process manually
		if ( dataUriRegexResult ) {

			var mimeType = dataUriRegexResult[ 1 ];
			var isBase64 = !! dataUriRegexResult[ 2 ];
			var data = dataUriRegexResult[ 3 ];

			data = decodeURIComponent( data );

			if ( isBase64 ) data = atob( data );

			try {

				var response;
				var responseType = ( this.responseType || '' ).toLowerCase();

				switch ( responseType ) {

					case 'arraybuffer':
					case 'blob':

						var view = new Uint8Array( data.length );

						for ( var i = 0; i < data.length; i ++ ) {

							view[ i ] = data.charCodeAt( i );

						}

						if ( responseType === 'blob' ) {

							response = new Blob( [ view.buffer ], { type: mimeType } );

						} else {

							response = view.buffer;

						}

						break;

					case 'document':

						var parser = new DOMParser();
						response = parser.parseFromString( data, mimeType );

						break;

					case 'json':

						response = JSON.parse( data );

						break;

					default: // 'text' or other

						response = data;

						break;

				}

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				}, 0 );

			} catch ( error ) {

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onError ) onError( error );

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, 0 );

			}

		} else {

			// Initialise array for duplicate requests

			loading[ url ] = [];

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			var request = new XMLHttpRequest();

			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				var response = this.response;

				var callbacks = loading[ url ];

				delete loading[ url ];

				if ( this.status === 200 || this.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					// Add to cache only on HTTP success, so that we do not cache
					// error response bodies as proper responses to requests.
					Cache.add( url, response );

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( response );

					}

					scope.manager.itemEnd( url );

				} else {

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}

			}, false );

			request.addEventListener( 'progress', function ( event ) {

				var callbacks = loading[ url ];

				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

					var callback = callbacks[ i ];
					if ( callback.onProgress ) callback.onProgress( event );

				}

			}, false );

			request.addEventListener( 'error', function ( event ) {

				var callbacks = loading[ url ];

				delete loading[ url ];

				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

					var callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			request.addEventListener( 'abort', function ( event ) {

				var callbacks = loading[ url ];

				delete loading[ url ];

				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

					var callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			for ( var header in this.requestHeader ) {

				request.setRequestHeader( header, this.requestHeader[ header ] );

			}

			request.send( null );

		}

		scope.manager.itemStart( url );

		return request;

	},

	setResponseType: function ( value ) {

		this.responseType = value;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setMimeType: function ( value ) {

		this.mimeType = value;
		return this;

	},

	setRequestHeader: function ( value ) {

		this.requestHeader = value;
		return this;

	}

} );

/**
 * @author bhouston / http://clara.io/
 */

function AnimationLoader( manager ) {

	Loader.call( this, manager );

}

AnimationLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: AnimationLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function CompressedTextureLoader( manager ) {

	Loader.call( this, manager );

}

CompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: CompressedTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var images = [];

		var texture = new CompressedTexture();
		texture.image = images;

		var loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				var texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 )
						texture.minFilter = LinearFilter;

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			var loaded = 0;

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

} );

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function DataTextureLoader( manager ) {

	Loader.call( this, manager );

}

DataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: DataTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new DataTexture();

		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.load( url, function ( buffer ) {

			var texData = scope.parse( buffer );

			if ( ! texData ) return;

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}
			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ImageLoader( manager ) {

	Loader.call( this, manager );

}

ImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

		function onImageLoad() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.substr( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */


function CubeTextureLoader( manager ) {

	Loader.call( this, manager );

}

CubeTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: CubeTextureLoader,

	load: function ( urls, onLoad, onProgress, onError ) {

		var texture = new CubeTexture();

		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		var loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( var i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function TextureLoader( manager ) {

	Loader.call( this, manager );

}

TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var texture = new Texture();

		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;

			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			texture.format = isJPEG ? RGBFormat : RGBAFormat;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

function Curve() {

	this.type = 'Curve';

	this.arcLengthDivisions = 200;

}

Object.assign( Curve.prototype, {

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u, optionalTarget ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions ) {

		if ( divisions === undefined ) divisions = 5;

		var points = [];

		for ( var d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions ) {

		if ( divisions === undefined ) divisions = 5;

		var points = [];

		for ( var d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	},

	// Get total curve arc length

	getLength: function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( divisions === undefined ) divisions = this.arcLengthDivisions;

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	},

	updateArcLengths: function () {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function ( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	},

	getTangentAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	},

	computeFrenetFrames: function ( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		var normal = new Vector3();

		var tangents = [];
		var normals = [];
		var binormals = [];

		var vec = new Vector3();
		var mat = new Matrix4();

		var i, u, theta;

		// compute the tangent vectors for each segment on the curve

		for ( i = 0; i <= segments; i ++ ) {

			u = i / segments;

			tangents[ i ] = this.getTangentAt( u );
			tangents[ i ].normalize();

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		var min = Number.MAX_VALUE;
		var tx = Math.abs( tangents[ 0 ].x );
		var ty = Math.abs( tangents[ 0 ].y );
		var tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	},

	fromJSON: function ( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

} );

function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	Curve.call( this );

	this.type = 'EllipseCurve';

	this.aX = aX || 0;
	this.aY = aY || 0;

	this.xRadius = xRadius || 1;
	this.yRadius = yRadius || 1;

	this.aStartAngle = aStartAngle || 0;
	this.aEndAngle = aEndAngle || 2 * Math.PI;

	this.aClockwise = aClockwise || false;

	this.aRotation = aRotation || 0;

}

EllipseCurve.prototype = Object.create( Curve.prototype );
EllipseCurve.prototype.constructor = EllipseCurve;

EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector2();

	var twoPi = Math.PI * 2;
	var deltaAngle = this.aEndAngle - this.aStartAngle;
	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

	// ensures that deltaAngle is 0 .. 2 PI
	while ( deltaAngle < 0 ) deltaAngle += twoPi;
	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

	if ( deltaAngle < Number.EPSILON ) {

		if ( samePoints ) {

			deltaAngle = 0;

		} else {

			deltaAngle = twoPi;

		}

	}

	if ( this.aClockwise === true && ! samePoints ) {

		if ( deltaAngle === twoPi ) {

			deltaAngle = - twoPi;

		} else {

			deltaAngle = deltaAngle - twoPi;

		}

	}

	var angle = this.aStartAngle + t * deltaAngle;
	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );

		var tx = x - this.aX;
		var ty = y - this.aY;

		// Rotate the point about the center of the ellipse.
		x = tx * cos - ty * sin + this.aX;
		y = tx * sin + ty * cos + this.aY;

	}

	return point.set( x, y );

};

EllipseCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.aX = source.aX;
	this.aY = source.aY;

	this.xRadius = source.xRadius;
	this.yRadius = source.yRadius;

	this.aStartAngle = source.aStartAngle;
	this.aEndAngle = source.aEndAngle;

	this.aClockwise = source.aClockwise;

	this.aRotation = source.aRotation;

	return this;

};


EllipseCurve.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.aX = this.aX;
	data.aY = this.aY;

	data.xRadius = this.xRadius;
	data.yRadius = this.yRadius;

	data.aStartAngle = this.aStartAngle;
	data.aEndAngle = this.aEndAngle;

	data.aClockwise = this.aClockwise;

	data.aRotation = this.aRotation;

	return data;

};

EllipseCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.aX = json.aX;
	this.aY = json.aY;

	this.xRadius = json.xRadius;
	this.yRadius = json.yRadius;

	this.aStartAngle = json.aStartAngle;
	this.aEndAngle = json.aEndAngle;

	this.aClockwise = json.aClockwise;

	this.aRotation = json.aRotation;

	return this;

};

function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	this.type = 'ArcCurve';

}

ArcCurve.prototype = Object.create( EllipseCurve.prototype );
ArcCurve.prototype.constructor = ArcCurve;

ArcCurve.prototype.isArcCurve = true;

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			var t2 = t * t;
			var t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

var tmp = new Vector3();
var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

function CatmullRomCurve3( points, closed, curveType, tension ) {

	Curve.call( this );

	this.type = 'CatmullRomCurve3';

	this.points = points || [];
	this.closed = closed || false;
	this.curveType = curveType || 'centripetal';
	this.tension = tension || 0.5;

}

CatmullRomCurve3.prototype = Object.create( Curve.prototype );
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector3();

	var points = this.points;
	var l = points.length;

	var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
	var intPoint = Math.floor( p );
	var weight = p - intPoint;

	if ( this.closed ) {

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

	} else if ( weight === 0 && intPoint === l - 1 ) {

		intPoint = l - 2;
		weight = 1;

	}

	var p0, p1, p2, p3; // 4 points

	if ( this.closed || intPoint > 0 ) {

		p0 = points[ ( intPoint - 1 ) % l ];

	} else {

		// extrapolate first point
		tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
		p0 = tmp;

	}

	p1 = points[ intPoint % l ];
	p2 = points[ ( intPoint + 1 ) % l ];

	if ( this.closed || intPoint + 2 < l ) {

		p3 = points[ ( intPoint + 2 ) % l ];

	} else {

		// extrapolate last point
		tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
		p3 = tmp;

	}

	if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

		// init Centripetal / Chordal Catmull-Rom
		var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
		var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
		var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
		var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

		// safety check for repeated points
		if ( dt1 < 1e-4 ) dt1 = 1.0;
		if ( dt0 < 1e-4 ) dt0 = dt1;
		if ( dt2 < 1e-4 ) dt2 = dt1;

		px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
		py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
		pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

	} else if ( this.curveType === 'catmullrom' ) {

		px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
		py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
		pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

	}

	point.set(
		px.calc( weight ),
		py.calc( weight ),
		pz.calc( weight )
	);

	return point;

};

CatmullRomCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.points = [];

	for ( var i = 0, l = source.points.length; i < l; i ++ ) {

		var point = source.points[ i ];

		this.points.push( point.clone() );

	}

	this.closed = source.closed;
	this.curveType = source.curveType;
	this.tension = source.tension;

	return this;

};

CatmullRomCurve3.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.points = [];

	for ( var i = 0, l = this.points.length; i < l; i ++ ) {

		var point = this.points[ i ];
		data.points.push( point.toArray() );

	}

	data.closed = this.closed;
	data.curveType = this.curveType;
	data.tension = this.tension;

	return data;

};

CatmullRomCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.points = [];

	for ( var i = 0, l = json.points.length; i < l; i ++ ) {

		var point = json.points[ i ];
		this.points.push( new Vector3().fromArray( point ) );

	}

	this.closed = json.closed;
	this.curveType = json.curveType;
	this.tension = json.tension;

	return this;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bzier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	var v0 = ( p2 - p0 ) * 0.5;
	var v1 = ( p3 - p1 ) * 0.5;
	var t2 = t * t;
	var t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	var k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	var k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	var k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

function CubicBezierCurve( v0, v1, v2, v3 ) {

	Curve.call( this );

	this.type = 'CubicBezierCurve';

	this.v0 = v0 || new Vector2();
	this.v1 = v1 || new Vector2();
	this.v2 = v2 || new Vector2();
	this.v3 = v3 || new Vector2();

}

CubicBezierCurve.prototype = Object.create( Curve.prototype );
CubicBezierCurve.prototype.constructor = CubicBezierCurve;

CubicBezierCurve.prototype.isCubicBezierCurve = true;

CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector2();

	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

	point.set(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
	);

	return point;

};

CubicBezierCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	this.v3.copy( source.v3 );

	return this;

};

CubicBezierCurve.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();
	data.v3 = this.v3.toArray();

	return data;

};

CubicBezierCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );
	this.v3.fromArray( json.v3 );

	return this;

};

function CubicBezierCurve3( v0, v1, v2, v3 ) {

	Curve.call( this );

	this.type = 'CubicBezierCurve3';

	this.v0 = v0 || new Vector3();
	this.v1 = v1 || new Vector3();
	this.v2 = v2 || new Vector3();
	this.v3 = v3 || new Vector3();

}

CubicBezierCurve3.prototype = Object.create( Curve.prototype );
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector3();

	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

	point.set(
		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
		CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
		CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
	);

	return point;

};

CubicBezierCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );
	this.v3.copy( source.v3 );

	return this;

};

CubicBezierCurve3.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();
	data.v3 = this.v3.toArray();

	return data;

};

CubicBezierCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );
	this.v3.fromArray( json.v3 );

	return this;

};

function LineCurve( v1, v2 ) {

	Curve.call( this );

	this.type = 'LineCurve';

	this.v1 = v1 || new Vector2();
	this.v2 = v2 || new Vector2();

}

LineCurve.prototype = Object.create( Curve.prototype );
LineCurve.prototype.constructor = LineCurve;

LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector2();

	if ( t === 1 ) {

		point.copy( this.v2 );

	} else {

		point.copy( this.v2 ).sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );

	}

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

	return this.getPoint( u, optionalTarget );

};

LineCurve.prototype.getTangent = function ( /* t */ ) {

	var tangent = this.v2.clone().sub( this.v1 );

	return tangent.normalize();

};

LineCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

LineCurve.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

LineCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function LineCurve3( v1, v2 ) {

	Curve.call( this );

	this.type = 'LineCurve3';

	this.v1 = v1 || new Vector3();
	this.v2 = v2 || new Vector3();

}

LineCurve3.prototype = Object.create( Curve.prototype );
LineCurve3.prototype.constructor = LineCurve3;

LineCurve3.prototype.isLineCurve3 = true;

LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector3();

	if ( t === 1 ) {

		point.copy( this.v2 );

	} else {

		point.copy( this.v2 ).sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );

	}

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

	return this.getPoint( u, optionalTarget );

};

LineCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

LineCurve3.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

LineCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function QuadraticBezierCurve( v0, v1, v2 ) {

	Curve.call( this );

	this.type = 'QuadraticBezierCurve';

	this.v0 = v0 || new Vector2();
	this.v1 = v1 || new Vector2();
	this.v2 = v2 || new Vector2();

}

QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector2();

	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

	point.set(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y )
	);

	return point;

};

QuadraticBezierCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

QuadraticBezierCurve.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function QuadraticBezierCurve3( v0, v1, v2 ) {

	Curve.call( this );

	this.type = 'QuadraticBezierCurve3';

	this.v0 = v0 || new Vector3();
	this.v1 = v1 || new Vector3();
	this.v2 = v2 || new Vector3();

}

QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector3();

	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

	point.set(
		QuadraticBezier( t, v0.x, v1.x, v2.x ),
		QuadraticBezier( t, v0.y, v1.y, v2.y ),
		QuadraticBezier( t, v0.z, v1.z, v2.z )
	);

	return point;

};

QuadraticBezierCurve3.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.v0.copy( source.v0 );
	this.v1.copy( source.v1 );
	this.v2.copy( source.v2 );

	return this;

};

QuadraticBezierCurve3.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.v0 = this.v0.toArray();
	data.v1 = this.v1.toArray();
	data.v2 = this.v2.toArray();

	return data;

};

QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.v0.fromArray( json.v0 );
	this.v1.fromArray( json.v1 );
	this.v2.fromArray( json.v2 );

	return this;

};

function SplineCurve( points /* array of Vector2 */ ) {

	Curve.call( this );

	this.type = 'SplineCurve';

	this.points = points || [];

}

SplineCurve.prototype = Object.create( Curve.prototype );
SplineCurve.prototype.constructor = SplineCurve;

SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

	var point = optionalTarget || new Vector2();

	var points = this.points;
	var p = ( points.length - 1 ) * t;

	var intPoint = Math.floor( p );
	var weight = p - intPoint;

	var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var p1 = points[ intPoint ];
	var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	point.set(
		CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
		CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
	);

	return point;

};

SplineCurve.prototype.copy = function ( source ) {

	Curve.prototype.copy.call( this, source );

	this.points = [];

	for ( var i = 0, l = source.points.length; i < l; i ++ ) {

		var point = source.points[ i ];

		this.points.push( point.clone() );

	}

	return this;

};

SplineCurve.prototype.toJSON = function () {

	var data = Curve.prototype.toJSON.call( this );

	data.points = [];

	for ( var i = 0, l = this.points.length; i < l; i ++ ) {

		var point = this.points[ i ];
		data.points.push( point.toArray() );

	}

	return data;

};

SplineCurve.prototype.fromJSON = function ( json ) {

	Curve.prototype.fromJSON.call( this, json );

	this.points = [];

	for ( var i = 0, l = json.points.length; i < l; i ++ ) {

		var point = json.points[ i ];
		this.points.push( new Vector2().fromArray( point ) );

	}

	return this;

};



var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {

	Curve.call( this );

	this.type = 'CurvePath';

	this.curves = [];
	this.autoClose = false; // Automatically closes the path

}

CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

	constructor: CurvePath,

	add: function ( curve ) {

		this.curves.push( curve );

	},

	closePath: function () {

		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	},

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint: function ( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];

				var segmentLength = curve.getLength();
				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	},

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength: function () {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	},

	// cacheLengths must be recalculated.
	updateArcLengths: function () {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	},

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths: function () {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		var lengths = [], sums = 0;

		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	},

	getSpacedPoints: function ( divisions ) {

		if ( divisions === undefined ) divisions = 40;

		var points = [];

		for ( var i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	getPoints: function ( divisions ) {

		divisions = divisions || 12;

		var points = [], last;

		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

			var curve = curves[ i ];
			var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
				: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
						: divisions;

			var pts = curve.getPoints( resolution );

			for ( var j = 0; j < pts.length; j ++ ) {

				var point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	copy: function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.curves = [];

		for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

			var curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	},

	toJSON: function () {

		var data = Curve.prototype.toJSON.call( this );

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

			var curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	},

	fromJSON: function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

			var curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/

function Path( points ) {

	CurvePath.call( this );

	this.type = 'Path';

	this.currentPoint = new Vector2();

	if ( points ) {

		this.setFromPoints( points );

	}

}

Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

	constructor: Path,

	setFromPoints: function ( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( var i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	},

	moveTo: function ( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	},

	lineTo: function ( x, y ) {

		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		var curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		var curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	},

	splineThru: function ( pts /*Array of Vector*/ ) {

		var npts = [ this.currentPoint.clone() ].concat( pts );

		var curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	},

	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	},

	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	},

	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	},

	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			var firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		var lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	},

	copy: function ( source ) {

		CurvePath.prototype.copy.call( this, source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	},

	toJSON: function () {

		var data = CurvePath.prototype.toJSON.call( this );

		data.currentPoint = this.currentPoint.toArray();

		return data;

	},

	fromJSON: function ( json ) {

		CurvePath.prototype.fromJSON.call( this, json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

function Shape( points ) {

	Path.call( this, points );

	this.uuid = MathUtils.generateUUID();

	this.type = 'Shape';

	this.holes = [];

}

Shape.prototype = Object.assign( Object.create( Path.prototype ), {

	constructor: Shape,

	getPointsHoles: function ( divisions ) {

		var holesPts = [];

		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	},

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints: function ( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	},

	copy: function ( source ) {

		Path.prototype.copy.call( this, source );

		this.holes = [];

		for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

			var hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	},

	toJSON: function () {

		var data = Path.prototype.toJSON.call( this );

		data.uuid = this.uuid;
		data.holes = [];

		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

			var hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	},

	fromJSON: function ( json ) {

		Path.prototype.fromJSON.call( this, json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

			var hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Light( color, intensity ) {

	Object3D.call( this );

	this.type = 'Light';

	this.color = new Color( color );
	this.intensity = intensity !== undefined ? intensity : 1;

	this.receiveShadow = undefined;

}

Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Light,

	isLight: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function HemisphereLight( skyColor, groundColor, intensity ) {

	Light.call( this, skyColor, intensity );

	this.type = 'HemisphereLight';

	this.castShadow = undefined;

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.groundColor = new Color( groundColor );

}

HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: HemisphereLight,

	isHemisphereLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LightShadow( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.radius = 1;

	this.mapSize = new Vector2( 512, 512 );

	this.map = null;
	this.mapPass = null;
	this.matrix = new Matrix4();

	this._frustum = new Frustum();
	this._frameExtents = new Vector2( 1, 1 );

	this._viewportCount = 1;

	this._viewports = [

		new Vector4( 0, 0, 1, 1 )

	];

}

Object.assign( LightShadow.prototype, {

	_projScreenMatrix: new Matrix4(),

	_lightPositionWorld: new Vector3(),

	_lookTarget: new Vector3(),

	getViewportCount: function () {

		return this._viewportCount;

	},

	getFrustum: function () {

		return this._frustum;

	},

	updateMatrices: function ( light ) {

		var shadowCamera = this.camera,
			shadowMatrix = this.matrix,
			projScreenMatrix = this._projScreenMatrix,
			lookTarget = this._lookTarget,
			lightPositionWorld = this._lightPositionWorld;

		lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( lightPositionWorld );

		lookTarget.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( lookTarget );
		shadowCamera.updateMatrixWorld();

		projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( projScreenMatrix );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	},

	getViewport: function ( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	},

	getFrameExtents: function () {

		return this._frameExtents;

	},

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		var object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function SpotLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

}

SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: SpotLightShadow,

	isSpotLightShadow: true,

	updateMatrices: function ( light ) {

		var camera = this.camera;

		var fov = MathUtils.RAD2DEG * 2 * light.angle;
		var aspect = this.mapSize.width / this.mapSize.height;
		var far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		LightShadow.prototype.updateMatrices.call( this, light );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

	Light.call( this, color, intensity );

	this.type = 'SpotLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	Object.defineProperty( this, 'power', {
		get: function () {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * Math.PI;

		},
		set: function ( power ) {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / Math.PI;

		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new SpotLightShadow();

}

SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: SpotLight,

	isSpotLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

function PointLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 90, 1, 0.5, 500 ) );

	this._frameExtents = new Vector2( 4, 2 );

	this._viewportCount = 6;

	this._viewports = [
		// These viewports map a cube-map onto a 2D texture with the
		// following orientation:
		//
		//  xzXZ
		//   y Y
		//
		// X - Positive x direction
		// x - Negative x direction
		// Y - Positive y direction
		// y - Negative y direction
		// Z - Positive z direction
		// z - Negative z direction

		// positive X
		new Vector4( 2, 1, 1, 1 ),
		// negative X
		new Vector4( 0, 1, 1, 1 ),
		// positive Z
		new Vector4( 3, 1, 1, 1 ),
		// negative Z
		new Vector4( 1, 1, 1, 1 ),
		// positive Y
		new Vector4( 3, 0, 1, 1 ),
		// negative Y
		new Vector4( 1, 0, 1, 1 )
	];

	this._cubeDirections = [
		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
	];

	this._cubeUps = [
		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
	];

}

PointLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: PointLightShadow,

	isPointLightShadow: true,

	updateMatrices: function ( light, viewportIndex ) {

		if ( viewportIndex === undefined ) viewportIndex = 0;

		var camera = this.camera,
			shadowMatrix = this.matrix,
			lightPositionWorld = this._lightPositionWorld,
			lookTarget = this._lookTarget,
			projScreenMatrix = this._projScreenMatrix;

		lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( lightPositionWorld );

		lookTarget.copy( camera.position );
		lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - lightPositionWorld.x, - lightPositionWorld.y, - lightPositionWorld.z );

		projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( projScreenMatrix );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */


function PointLight( color, intensity, distance, decay ) {

	Light.call( this, color, intensity );

	this.type = 'PointLight';

	Object.defineProperty( this, 'power', {
		get: function () {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * 4 * Math.PI;

		},
		set: function ( power ) {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / ( 4 * Math.PI );

		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new PointLightShadow();

}

PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: PointLight,

	isPointLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera( left, right, top, bottom, near, far ) {

	Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;
	this.view = null;

	this.left = ( left !== undefined ) ? left : - 1;
	this.right = ( right !== undefined ) ? right : 1;
	this.top = ( top !== undefined ) ? top : 1;
	this.bottom = ( bottom !== undefined ) ? bottom : - 1;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

}

OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: OrthographicCamera,

	isOrthographicCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	},

	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		var left = cx - dx;
		var right = cx + dx;
		var top = cy + dy;
		var bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			var scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			var scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.getInverse( this.projectionMatrix );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectionalLightShadow() {

	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

}

DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: DirectionalLightShadow,

	isDirectionalLightShadow: true,

	updateMatrices: function ( light ) {

		LightShadow.prototype.updateMatrices.call( this, light );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function DirectionalLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'DirectionalLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	this.shadow = new DirectionalLightShadow();

}

DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: DirectionalLight,

	isDirectionalLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AmbientLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'AmbientLight';

	this.castShadow = undefined;

}

AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: AmbientLight,

	isAmbientLight: true

} );

/**
 * @author abelnation / http://github.com/abelnation
 */

function RectAreaLight( color, intensity, width, height ) {

	Light.call( this, color, intensity );

	this.type = 'RectAreaLight';

	this.width = ( width !== undefined ) ? width : 10;
	this.height = ( height !== undefined ) ? height : 10;

}

RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: RectAreaLight,

	isRectAreaLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.width = source.width;
		this.height = source.height;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Light.prototype.toJSON.call( this, meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function MaterialLoader( manager ) {

	Loader.call( this, manager );

	this.textures = {};

}

MaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		var material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
		if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;
		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( var name in json.uniforms ) {

				var uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

		if ( json.extensions !== undefined ) {

			for ( var key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// Deprecated

		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			var normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		return material;

	},

	setTextures: function ( value ) {

		this.textures = value;
		return this;

	}

} );

/**
 * @author Don McCurdy / https://www.donmccurdy.com
 */

var LoaderUtils = {

	decodeText: function ( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		var s = '';

		for ( var i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	},

	extractUrlBase: function ( url ) {

		var index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.substr( 0, index + 1 );

	}

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferGeometry() {

	BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;

}

InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

	constructor: InstancedBufferGeometry,

	isInstancedBufferGeometry: true,

	copy: function ( source ) {

		BufferGeometry.prototype.copy.call( this, source );

		this.maxInstancedCount = source.maxInstancedCount;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		data.maxInstancedCount = this.maxInstancedCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

} );

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

	if ( typeof ( normalized ) === 'number' ) {

		meshPerAttribute = normalized;

		normalized = false;

		console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

	}

	BufferAttribute.call( this, array, itemSize, normalized );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

	constructor: InstancedBufferAttribute,

	isInstancedBufferAttribute: true,

	copy: function ( source ) {

		BufferAttribute.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	},

	toJSON: function ()	{

		var data = BufferAttribute.prototype.toJSON.call( this );

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometryLoader( manager ) {

	Loader.call( this, manager );

}

BufferGeometryLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		var index = json.data.index;

		if ( index !== undefined ) {

			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		var attributes = json.data.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
			var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
			var bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );
			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			geometry.setAttribute( key, bufferAttribute );

		}

		var morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( var key in morphAttributes ) {

				var attributeArray = morphAttributes[ key ];

				var array = [];

				for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

					var attribute = attributeArray[ i ];
					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

					var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		var morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

				var group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		var boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

} );

var TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	// Workaround for IE11 pre KB2929437. See #11440
	Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ObjectLoader( manager ) {

	Loader.call( this, manager );

}

ObjectLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		var loader = new FileLoader( scope.manager );
		loader.setPath( this.path );
		loader.load( url, function ( text ) {

			var json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			var metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	},

	parse: function ( json, onLoad ) {

		var shapes = this.parseShape( json.shapes );
		var geometries = this.parseGeometries( json.geometries, shapes );

		var images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		var textures = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );

		var object = this.parseObject( json.object, geometries, materials );

		if ( json.animations ) {

			object.animations = this.parseAnimations( json.animations );

		}

		if ( json.images === undefined || json.images.length === 0 ) {

			if ( onLoad !== undefined ) onLoad( object );

		}

		return object;

	},

	parseShape: function ( json ) {

		var shapes = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	},

	parseGeometries: function ( json, shapes ) {

		var geometries = {};

		if ( json !== undefined ) {

			var bufferGeometryLoader = new BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':
					case 'DodecahedronBufferGeometry':
					case 'IcosahedronGeometry':
					case 'IcosahedronBufferGeometry':
					case 'OctahedronGeometry':
					case 'OctahedronBufferGeometry':
					case 'TetrahedronGeometry':
					case 'TetrahedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'TubeGeometry':
					case 'TubeBufferGeometry':

						// This only works for built-in curves (e.g. CatmullRomCurve3).
						// User defined curves or instances of CurvePath will not be deserialized.
						geometry = new Geometries[ data.type ](
							new Curves[ data.path.type ]().fromJSON( data.path ),
							data.tubularSegments,
							data.radius,
							data.radialSegments,
							data.closed
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'PolyhedronGeometry':
					case 'PolyhedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.vertices,
							data.indices,
							data.radius,
							data.details
						);

						break;

					case 'ShapeGeometry':
					case 'ShapeBufferGeometry':

						var geometryShapes = [];

						for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							var shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.curveSegments
						);

						break;


					case 'ExtrudeGeometry':
					case 'ExtrudeBufferGeometry':

						var geometryShapes = [];

						for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							var shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						var extrudePath = data.options.extrudePath;

						if ( extrudePath !== undefined ) {

							data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.options
						);

						break;

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json, textures ) {

		var cache = {}; // MultiMaterial
		var materials = {};

		if ( json !== undefined ) {

			var loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.type === 'MultiMaterial' ) {

					// Deprecated

					var array = [];

					for ( var j = 0; j < data.materials.length; j ++ ) {

						var material = data.materials[ j ];

						if ( cache[ material.uuid ] === undefined ) {

							cache[ material.uuid ] = loader.parse( material );

						}

						array.push( cache[ material.uuid ] );

					}

					materials[ data.uuid ] = array;

				} else {

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

				}

			}

		}

		return materials;

	},

	parseAnimations: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var data = json[ i ];

			var clip = AnimationClip.parse( data );

			if ( data.uuid !== undefined ) clip.uuid = data.uuid;

			animations.push( clip );

		}

		return animations;

	},

	parseImages: function ( json, onLoad ) {

		var scope = this;
		var images = {};

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		if ( json !== undefined && json.length > 0 ) {

			var manager = new LoadingManager( onLoad );

			var loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( var i = 0, il = json.length; i < il; i ++ ) {

				var image = json[ i ];
				var url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( var j = 0, jl = url.length; j < jl; j ++ ) {

						var currentUrl = url[ j ];

						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;

						images[ image.uuid ].push( loadImage( path ) );

					}

				} else {

					// load single image

					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;

					images[ image.uuid ] = loadImage( path );

				}

			}

		}

		return images;

	},

	parseTextures: function ( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		var textures = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				var texture;

				if ( Array.isArray( images[ data.image ] ) ) {

					texture = new CubeTexture( images[ data.image ] );

				} else {

					texture = new Texture( images[ data.image ] );

				}

				texture.needsUpdate = true;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	},

	parseObject: function ( data, geometries, materials ) {

		var object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				var array = [];

				for ( var i = 0, l = name.length; i < l; i ++ ) {

					var uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		switch ( data.type ) {

			case 'Scene':

				object = new Scene();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color( data.background );

					}

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

				}

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

				break;

			case 'SkinnedMesh':

				console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

			case 'Mesh':

				var geometry = getGeometry( data.geometry );
				var material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				var geometry = getGeometry( data.geometry );
				var material = getMaterial( data.material );
				var count = data.count;
				var instanceMatrix = data.instanceMatrix;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			var children = data.children;

			for ( var i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials ) );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			var levels = data.levels;

			for ( var l = 0; l < levels.length; l ++ ) {

				var level = levels[ l ];
				var child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance );

				}

			}

		}

		return object;

	}

} );

var TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	SphericalReflectionMapping: SphericalReflectionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};

var TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

var TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

/**
 * @author thespite / http://clicktorelease.com/
 */


function ImageBitmapLoader( manager ) {

	if ( typeof createImageBitmap === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

	}

	if ( typeof fetch === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

	}

	Loader.call( this, manager );

	this.options = undefined;

}

ImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: ImageBitmapLoader,

	setOptions: function setOptions( options ) {

		this.options = options;

		return this;

	},

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		fetch( url ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			if ( scope.options === undefined ) {

				// Workaround for FireFox. It causes an error if you pass options.
				return createImageBitmap( blob );

			} else {

				return createImageBitmap( blob, scope.options );

			}

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/

function ShapePath() {

	this.type = 'ShapePath';

	this.color = new Color();

	this.subPaths = [];
	this.currentPath = null;

}

Object.assign( ShapePath.prototype, {

	moveTo: function ( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	},

	lineTo: function ( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	},

	splineThru: function ( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	},

	toShapes: function ( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				var edgeLowPt = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		var isClockWise = ShapeUtils.isClockWise;

		var subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			var ambiguous = false;
			var toChange = [];

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				var sho = newShapeHoles[ sIdx ];

				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					var ho = sho[ hIdx ];
					var hole_unassigned = true;

					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}
					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		var tmpHoles;

		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */


function Font( data ) {

	this.type = 'Font';

	this.data = data;

}

Object.assign( Font.prototype, {

	isFont: true,

	generateShapes: function ( text, size ) {

		if ( size === undefined ) size = 100;

		var shapes = [];
		var paths = createPaths( text, size, this.data );

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

} );

function createPaths( text, size, data ) {

	var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // workaround for IE11, see #13988
	var scale = size / data.resolution;
	var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

	var paths = [];

	var offsetX = 0, offsetY = 0;

	for ( var i = 0; i < chars.length; i ++ ) {

		var char = chars[ i ];

		if ( char === '\n' ) {

			offsetX = 0;
			offsetY -= line_height;

		} else {

			var ret = createPath( char, scale, offsetX, offsetY, data );
			offsetX += ret.offsetX;
			paths.push( ret.path );

		}

	}

	return paths;

}

function createPath( char, scale, offsetX, offsetY, data ) {

	var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

	if ( ! glyph ) {

		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

		return;

	}

	var path = new ShapePath();

	var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

	if ( glyph.o ) {

		var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

		for ( var i = 0, l = outline.length; i < l; ) {

			var action = outline[ i ++ ];

			switch ( action ) {

				case 'm': // moveTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.moveTo( x, y );

					break;

				case 'l': // lineTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.lineTo( x, y );

					break;

				case 'q': // quadraticCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					break;

				case 'b': // bezierCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;
					cpx2 = outline[ i ++ ] * scale + offsetX;
					cpy2 = outline[ i ++ ] * scale + offsetY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					break;

			}

		}

	}

	return { offsetX: glyph.ha * scale, path: path };

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function FontLoader( manager ) {

	Loader.call( this, manager );

}

FontLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: FontLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.load( url, function ( text ) {

			var json;

			try {

				json = JSON.parse( text );

			} catch ( e ) {

				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );

			}

			var font = scope.parse( json );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		return new Font( json );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _context;

var AudioContext = {

	getContext: function () {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	},

	setContext: function ( value ) {

		_context = value;

	}

};

/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function AudioLoader( manager ) {

	Loader.call( this, manager );

}

AudioLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: AudioLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.load( url, function ( buffer ) {

			// Create a copy of the buffer. The `decodeAudioData` method
			// detaches the buffer when complete, preventing reuse.
			var bufferCopy = buffer.slice( 0 );

			var context = AudioContext.getContext();
			context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

				onLoad( audioBuffer );

			} );

		}, onProgress, onError );

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

function SphericalHarmonics3() {

	this.coefficients = [];

	for ( var i = 0; i < 9; i ++ ) {

		this.coefficients.push( new Vector3() );

	}

}

Object.assign( SphericalHarmonics3.prototype, {

	isSphericalHarmonics3: true,

	set: function ( coefficients ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	},

	zero: function () {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	},

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt: function ( normal, target ) {

		// normal is assumed to be unit length

		var x = normal.x, y = normal.y, z = normal.z;

		var coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	},

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt: function ( normal, target ) {

		// normal is assumed to be unit length

		var x = normal.x, y = normal.y, z = normal.z;

		var coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274

		return target;

	},

	add: function ( sh ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	},

	addScaledSH: function ( sh, s ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	},

	scale: function ( s ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	},

	lerp: function ( sh, alpha ) {

		for ( var i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	},

	equals: function ( sh ) {

		for ( var i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	},

	copy: function ( sh ) {

		return this.set( sh.coefficients );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		var coefficients = this.coefficients;

		for ( var i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var coefficients = this.coefficients;

		for ( var i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

} );

Object.assign( SphericalHarmonics3, {

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	getBasisAt: function ( normal, shBasis ) {

		// normal is assumed to be unit length

		var x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

} );

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * A LightProbe is a source of indirect-diffuse light
 */

function LightProbe( sh, intensity ) {

	Light.call( this, undefined, intensity );

	this.sh = ( sh !== undefined ) ? sh : new SphericalHarmonics3();

}

LightProbe.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: LightProbe,

	isLightProbe: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.sh.copy( source.sh );
		this.intensity = source.intensity;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Light.prototype.toJSON.call( this, meta );

		// data.sh = this.sh.toArray(); // todo

		return data;

	}

} );

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function HemisphereLightProbe( skyColor, groundColor, intensity ) {

	LightProbe.call( this, undefined, intensity );

	var color1 = new Color().set( skyColor );
	var color2 = new Color().set( groundColor );

	var sky = new Vector3( color1.r, color1.g, color1.b );
	var ground = new Vector3( color2.r, color2.g, color2.b );

	// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
	var c0 = Math.sqrt( Math.PI );
	var c1 = c0 * Math.sqrt( 0.75 );

	this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
	this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

}

HemisphereLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

	constructor: HemisphereLightProbe,

	isHemisphereLightProbe: true,

	copy: function ( source ) { // modifying colors not currently supported

		LightProbe.prototype.copy.call( this, source );

		return this;

	},

	toJSON: function ( meta ) {

		var data = LightProbe.prototype.toJSON.call( this, meta );

		// data.sh = this.sh.toArray(); // todo

		return data;

	}

} );

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function AmbientLightProbe( color, intensity ) {

	LightProbe.call( this, undefined, intensity );

	var color1 = new Color().set( color );

	// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
	this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

}

AmbientLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

	constructor: AmbientLightProbe,

	isAmbientLightProbe: true,

	copy: function ( source ) { // modifying color not currently supported

		LightProbe.prototype.copy.call( this, source );

		return this;

	},

	toJSON: function ( meta ) {

		var data = LightProbe.prototype.toJSON.call( this, meta );

		// data.sh = this.sh.toArray(); // todo

		return data;

	}

} );

var _eyeRight = new Matrix4();
var _eyeLeft = new Matrix4();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function StereoCamera() {

	this.type = 'StereoCamera';

	this.aspect = 1;

	this.eyeSep = 0.064;

	this.cameraL = new PerspectiveCamera();
	this.cameraL.layers.enable( 1 );
	this.cameraL.matrixAutoUpdate = false;

	this.cameraR = new PerspectiveCamera();
	this.cameraR.layers.enable( 2 );
	this.cameraR.matrixAutoUpdate = false;

	this._cache = {
		focus: null,
		fov: null,
		aspect: null,
		near: null,
		far: null,
		zoom: null,
		eyeSep: null
	};

}

Object.assign( StereoCamera.prototype, {

	update: function ( camera ) {

		var cache = this._cache;

		var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			var projectionMatrix = camera.projectionMatrix.clone();
			var eyeSepHalf = cache.eyeSep / 2;
			var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			var ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			var xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Clock( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

}

Object.assign( Clock.prototype, {

	start: function () {

		this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _position$2 = new Vector3();
var _quaternion$3 = new Quaternion();
var _scale$1 = new Vector3();
var _orientation = new Vector3();

function AudioListener() {

	Object3D.call( this );

	this.type = 'AudioListener';

	this.context = AudioContext.getContext();

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.filter = null;

	this.timeDelta = 0;

	// private

	this._clock = new Clock();

}

AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: AudioListener,

	getInput: function () {

		return this.gain;

	},

	removeFilter: function ( ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	},

	getFilter: function () {

		return this.filter;

	},

	setFilter: function ( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	},

	getMasterVolume: function () {

		return this.gain.gain.value;

	},

	setMasterVolume: function ( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	},

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		var listener = this.context.listener;
		var up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$2, _quaternion$3, _scale$1 );

		_orientation.set( 0, 0, - 1 ).applyQuaternion( _quaternion$3 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			var endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$2.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$2.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$2.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$2.x, _position$2.y, _position$2.z );
			listener.setOrientation( _orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z );

		}

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function Audio( listener ) {

	Object3D.call( this );

	this.type = 'Audio';

	this.listener = listener;
	this.context = listener.context;

	this.gain = this.context.createGain();
	this.gain.connect( listener.getInput() );

	this.autoplay = false;

	this.buffer = null;
	this.detune = 0;
	this.loop = false;
	this.loopStart = 0;
	this.loopEnd = 0;
	this.offset = 0;
	this.duration = undefined;
	this.playbackRate = 1;
	this.isPlaying = false;
	this.hasPlaybackControl = true;
	this.sourceType = 'empty';

	this._startedAt = 0;
	this._pausedAt = 0;

	this.filters = [];

}

Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Audio,

	getOutput: function () {

		return this.gain;

	},

	setNodeSource: function ( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	},

	setMediaElementSource: function ( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	},

	setMediaStreamSource: function ( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	},

	setBuffer: function ( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	},

	play: function ( delay ) {

		if ( delay === undefined ) delay = 0;

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		var source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._pausedAt + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	},

	pause: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			this._pausedAt += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	},

	stop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._pausedAt = 0;

		this.source.stop();
		this.source.onended = null;
		this.isPlaying = false;

		return this;

	},

	connect: function () {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		return this;

	},

	disconnect: function () {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		return this;

	},

	getFilters: function () {

		return this.filters;

	},

	setFilters: function ( value ) {

		if ( ! value ) value = [];

		if ( this.isPlaying === true ) {

			this.disconnect();
			this.filters = value;
			this.connect();

		} else {

			this.filters = value;

		}

		return this;

	},

	setDetune: function ( value ) {

		this.detune = value;

		if ( this.source.detune === undefined ) return; // only set detune when available

		if ( this.isPlaying === true ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	},

	getDetune: function () {

		return this.detune;

	},

	getFilter: function () {

		return this.getFilters()[ 0 ];

	},

	setFilter: function ( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	},

	setPlaybackRate: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	},

	getPlaybackRate: function () {

		return this.playbackRate;

	},

	onEnded: function () {

		this.isPlaying = false;

	},

	getLoop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	},

	setLoop: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	},

	setLoopStart: function ( value ) {

		this.loopStart = value;

		return this;

	},

	setLoopEnd: function ( value ) {

		this.loopEnd = value;

		return this;

	},

	getVolume: function () {

		return this.gain.gain.value;

	},

	setVolume: function ( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

var _position$3 = new Vector3();
var _quaternion$4 = new Quaternion();
var _scale$2 = new Vector3();
var _orientation$1 = new Vector3();

function PositionalAudio( listener ) {

	Audio.call( this, listener );

	this.panner = this.context.createPanner();
	this.panner.panningModel = 'HRTF';
	this.panner.connect( this.gain );

}

PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

	constructor: PositionalAudio,

	getOutput: function () {

		return this.panner;

	},

	getRefDistance: function () {

		return this.panner.refDistance;

	},

	setRefDistance: function ( value ) {

		this.panner.refDistance = value;

		return this;

	},

	getRolloffFactor: function () {

		return this.panner.rolloffFactor;

	},

	setRolloffFactor: function ( value ) {

		this.panner.rolloffFactor = value;

		return this;

	},

	getDistanceModel: function () {

		return this.panner.distanceModel;

	},

	setDistanceModel: function ( value ) {

		this.panner.distanceModel = value;

		return this;

	},

	getMaxDistance: function () {

		return this.panner.maxDistance;

	},

	setMaxDistance: function ( value ) {

		this.panner.maxDistance = value;

		return this;

	},

	setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	},

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position$3, _quaternion$4, _scale$2 );

		_orientation$1.set( 0, 0, 1 ).applyQuaternion( _quaternion$4 );

		var panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			var endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position$3.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position$3.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position$3.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation$1.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation$1.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation$1.z, endTime );

		} else {

			panner.setPosition( _position$3.x, _position$3.y, _position$3.z );
			panner.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z );

		}

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioAnalyser( audio, fftSize ) {

	this.analyser = audio.context.createAnalyser();
	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

	this.data = new Uint8Array( this.analyser.frequencyBinCount );

	audio.getOutput().connect( this.analyser );

}

Object.assign( AudioAnalyser.prototype, {

	getFrequencyData: function () {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	},

	getAverageFrequency: function () {

		var value = 0, data = this.getFrequencyData();

		for ( var i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

} );

/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyMixer( binding, typeName, valueSize ) {

	this.binding = binding;
	this.valueSize = valueSize;

	var bufferType = Float64Array,
		mixFunction;

	switch ( typeName ) {

		case 'quaternion':
			mixFunction = this._slerp;
			break;

		case 'string':
		case 'bool':
			bufferType = Array;
			mixFunction = this._select;
			break;

		default:
			mixFunction = this._lerp;

	}

	this.buffer = new bufferType( valueSize * 4 );
	// layout: [ incoming | accu0 | accu1 | orig ]
	//
	// interpolators can use .buffer as their .result
	// the data then goes to 'incoming'
	//
	// 'accu0' and 'accu1' are used frame-interleaved for
	// the cumulative result and are compared to detect
	// changes
	//
	// 'orig' stores the original state of the property

	this._mixBufferRegion = mixFunction;

	this.cumulativeWeight = 0;

	this.useCount = 0;
	this.referenceCount = 0;

}

Object.assign( PropertyMixer.prototype, {

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate: function ( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		var buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride,

			currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			var mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	},

	// apply the state of 'accu<i>' to the binding when accus differ
	apply: function ( accuIndex ) {

		var stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,

			binding = this.binding;

		this.cumulativeWeight = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			var originalValueOffset = stride * 3;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	},

	// remember the state of the bound property and copy it to both accus
	saveOriginalState: function () {

		var binding = this.binding;

		var buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * 3;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		this.cumulativeWeight = 0;

	},

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState: function () {

		var originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	},


	// mix functions

	_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	},

	_slerp: function ( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	},

	_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

		var s = 1 - t;

		for ( var i = 0; i !== stride; ++ i ) {

			var j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

} );

/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

// Characters [].:/ are reserved for track binding syntax.
var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
var _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
var _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
var _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

var _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

var _supportedObjectNames = [ 'material', 'materials', 'bones' ];

function Composite( targetGroup, path, optionalParsedPath ) {

	var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

}

Object.assign( Composite.prototype, {

	getValue: function ( array, offset ) {

		this.bind(); // bind all binding

		var firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function ( array, offset ) {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function () {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function () {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

} );


function PropertyBinding( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

}

Object.assign( PropertyBinding, {

	Composite: Composite,

	create: function ( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	},

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	sanitizeNodeName: function ( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	},

	parseTrackName: function ( trackName ) {

		var matches = _trackRe.exec( trackName );

		if ( ! matches ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		var results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			var objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against a whitelist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	},

	findNode: function ( root, nodeName ) {

		if ( ! nodeName || nodeName === "" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			var bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			var searchNodeSubtree = function ( children ) {

				for ( var i = 0; i < children.length; i ++ ) {

					var childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					var result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			var subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

} );

Object.assign( PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function () {},
	_setValue_unavailable: function () {},

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			var source = this.resolvedProperty;

			for ( var i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	],

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function () {

		var targetObject = this.node,
			parsedPath = this.parsedPath,

			objectName = parsedPath.objectName,
			propertyName = parsedPath.propertyName,
			propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			var objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( var i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		var nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			var nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		var versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		var bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === "morphTargetInfluences" ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( targetObject.geometry.isBufferGeometry ) {

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

						if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

							propertyIndex = i;
							break;

						}

					}


				} else {

					if ( ! targetObject.geometry.morphTargets ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
						return;

					}

					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

						if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

							propertyIndex = i;
							break;

						}

					}

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function () {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( PropertyBinding.prototype, {

	// initial state of these methods that calls 'bind'
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,

} );

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */

function AnimationObjectGroup() {

	this.uuid = MathUtils.generateUUID();

	// cached objects followed by the active ones
	this._objects = Array.prototype.slice.call( arguments );

	this.nCachedObjects_ = 0; // threshold
	// note: read by PropertyBinding.Composite

	var indices = {};
	this._indicesByUUID = indices; // for bookkeeping

	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

		indices[ arguments[ i ].uuid ] = i;

	}

	this._paths = []; // inside: string
	this._parsedPaths = []; // inside: { we don't care, here }
	this._bindings = []; // inside: Array< PropertyBinding >
	this._bindingsIndicesByPath = {}; // inside: indices in these arrays

	var scope = this;

	this.stats = {

		objects: {
			get total() {

				return scope._objects.length;

			},
			get inUse() {

				return this.total - scope.nCachedObjects_;

			}
		},
		get bindingsPerObject() {

			return scope._bindings.length;

		}

	};

}

Object.assign( AnimationObjectGroup.prototype, {

	isAnimationObjectGroup: true,

	add: function () {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length,
			knownObject = undefined;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				var firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	remove: function () {

		var objects = this._objects,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				var lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// remove & forget
	uncache: function () {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					var lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					indicesByUUID[ lastObject.uuid ] = index;
					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_: function ( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ],
			bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		var paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			var object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	},

	unsubscribe_: function ( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

} );

/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */

function AnimationAction( mixer, clip, localRoot ) {

	this._mixer = mixer;
	this._clip = clip;
	this._localRoot = localRoot || null;

	var tracks = clip.tracks,
		nTracks = tracks.length,
		interpolants = new Array( nTracks );

	var interpolantSettings = {
		endingStart: ZeroCurvatureEnding,
		endingEnd: ZeroCurvatureEnding
	};

	for ( var i = 0; i !== nTracks; ++ i ) {

		var interpolant = tracks[ i ].createInterpolant( null );
		interpolants[ i ] = interpolant;
		interpolant.settings = interpolantSettings;

	}

	this._interpolantSettings = interpolantSettings;

	this._interpolants = interpolants; // bound by the mixer

	// inside: PropertyMixer (managed by the mixer)
	this._propertyBindings = new Array( nTracks );

	this._cacheIndex = null; // for the memory manager
	this._byClipCacheIndex = null; // for the memory manager

	this._timeScaleInterpolant = null;
	this._weightInterpolant = null;

	this.loop = LoopRepeat;
	this._loopCount = - 1;

	// global mixer time when the action is to be started
	// it's set back to 'null' upon start of the action
	this._startTime = null;

	// scaled local time of the action
	// gets clamped or wrapped to 0..clip.duration according to loop
	this.time = 0;

	this.timeScale = 1;
	this._effectiveTimeScale = 1;

	this.weight = 1;
	this._effectiveWeight = 1;

	this.repetitions = Infinity; // no. of repetitions when looping

	this.paused = false; // true -> zero effective time scale
	this.enabled = true; // false -> zero effective weight

	this.clampWhenFinished = false;// keep feeding the last frame?

	this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
	this.zeroSlopeAtEnd = true;// clips for start, loop and end

}

Object.assign( AnimationAction.prototype, {

	// State & Scheduling

	play: function () {

		this._mixer._activateAction( this );

		return this;

	},

	stop: function () {

		this._mixer._deactivateAction( this );

		return this.reset();

	},

	reset: function () {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	},

	isRunning: function () {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	},

	// return true when play has been called
	isScheduled: function () {

		return this._mixer._isActiveAction( this );

	},

	startAt: function ( time ) {

		this._startTime = time;

		return this;

	},

	setLoop: function ( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	},

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight: function ( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	},

	// return the weight considering fading and .enabled
	getEffectiveWeight: function () {

		return this._effectiveWeight;

	},

	fadeIn: function ( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	},

	fadeOut: function ( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	},

	crossFadeFrom: function ( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			var fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	},

	crossFadeTo: function ( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	},

	stopFading: function () {

		var weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	},

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale: function ( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	},

	// return the time scale considering warping and .paused
	getEffectiveTimeScale: function () {

		return this._effectiveTimeScale;

	},

	setDuration: function ( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	},

	syncWith: function ( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	},

	halt: function ( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	},

	warp: function ( startTimeScale, endTimeScale, duration ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._timeScaleInterpolant,

			timeScale = this.timeScale;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	},

	stopWarping: function () {

		var timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	},

	// Object Accessors

	getMixer: function () {

		return this._mixer;

	},

	getClip: function () {

		return this._clip;

	},

	getRoot: function () {

		return this._localRoot || this._mixer._root;

	},

	// Interna

	_update: function ( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		var startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			var timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		var clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		var weight = this._updateWeight( time );

		if ( weight > 0 ) {

			var interpolants = this._interpolants;
			var propertyMixers = this._propertyBindings;

			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

				interpolants[ j ].evaluate( clipTime );
				propertyMixers[ j ].accumulate( accuIndex, weight );

			}

		}

	},

	_updateWeight: function ( time ) {

		var weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			var interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	},

	_updateTimeScale: function ( time ) {

		var timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			var interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	},

	_updateTime: function ( deltaTime ) {

		var time = this.time + deltaTime;
		var duration = this._clip.duration;
		var loop = this.loop;
		var loopCount = this._loopCount;

		var pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				var loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				var pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						var atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	},

	_setEndings: function ( atStart, atEnd, pingPong ) {

		var settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	},

	_scheduleFading: function ( duration, weightNow, weightThen ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

} );

/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function AnimationMixer( root ) {

	this._root = root;
	this._initMemoryManager();
	this._accuIndex = 0;

	this.time = 0;

	this.timeScale = 1.0;

}

AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: AnimationMixer,

	_bindAction: function ( action, prototypeAction ) {

		var root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( var i = 0; i !== nTracks; ++ i ) {

			var track = tracks[ i ],
				trackName = track.name,
				binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				var path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	},

	_activateAction: function ( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				var rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			var bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	},

	_deactivateAction: function ( action ) {

		if ( this._isActiveAction( action ) ) {

			var bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	},

	// Memory manager

	_initMemoryManager: function () {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		var scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	},

	// Memory management for AnimationAction objects

	_isActiveAction: function ( action ) {

		var index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	},

	_addInactiveAction: function ( action, clipUuid, rootUuid ) {

		var actions = this._actions,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			var knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	},

	_removeInactiveAction: function ( action ) {

		var actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		var clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		var actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	},

	_removeInactiveBindingsForAction: function ( action ) {

		var bindings = action._propertyBindings;
		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

			var binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	},

	_lendAction: function ( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	},

	_takeBackAction: function ( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	},

	// Memory management for PropertyMixer objects

	_addInactiveBinding: function ( binding, rootUuid, trackName ) {

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			bindings = this._bindings;

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	},

	_removeInactiveBinding: function ( binding ) {

		var bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	},

	_lendBinding: function ( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	},

	_takeBackBinding: function ( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	},


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant: function () {

		var interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++,
			interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	},

	_takeBackControlInterpolant: function ( interpolant ) {

		var interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	},

	_controlInterpolantsResultBuffer: new Float32Array( 1 ),

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction: function ( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject !== null ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ],
			prototypeAction = null;

		if ( actionsForClip !== undefined ) {

			var existingAction =
					actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		var newAction = new AnimationAction( this, clipObject, optionalRoot );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	},

	// get an existing action
	existingAction: function ( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	},

	// deactivates all previously scheduled actions
	stopAllAction: function () {

		var actions = this._actions,
			nActions = this._nActiveActions,
			bindings = this._bindings,
			nBindings = this._nActiveBindings;

		this._nActiveActions = 0;
		this._nActiveBindings = 0;

		for ( var i = 0; i !== nActions; ++ i ) {

			actions[ i ].reset();

		}

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].useCount = 0;

		}

		return this;

	},

	// advance the time and update apply the animation
	update: function ( deltaTime ) {

		deltaTime *= this.timeScale;

		var actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( var i = 0; i !== nActions; ++ i ) {

			var action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		var bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	},

	// Allows you to seek to a specific time in an animation.
	setTime: function ( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( var i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	},

	// return this mixer's root target object
	getRoot: function () {

		return this._root;

	},

	// free all resources specific to a particular clip
	uncacheClip: function ( clip ) {

		var actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			var actionsToRemove = actionsForClip.knownActions;

			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				var action = actionsToRemove[ i ];

				this._deactivateAction( action );

				var cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	},

	// free all resources specific to a particular root target object
	uncacheRoot: function ( root ) {

		var rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( var clipUuid in actionsByClip ) {

			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( var trackName in bindingByName ) {

				var binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	},

	// remove a targeted clip from the cache
	uncacheAction: function ( clip, optionalRoot ) {

		var action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Uniform( value ) {

	if ( typeof value === 'string' ) {

		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
		value = arguments[ 1 ];

	}

	this.value = value;

}

Uniform.prototype.clone = function () {

	return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

	InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

	constructor: InstancedInterleavedBuffer,

	isInstancedInterleavedBuffer: true,

	copy: function ( source ) {

		InterleavedBuffer.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster( origin, direction, near, far ) {

	this.ray = new Ray( origin, direction );
	// direction is assumed to be normalized (for accurate distance calculations)

	this.near = near || 0;
	this.far = far || Infinity;
	this.camera = null;
	this.layers = new Layers();

	this.params = {
		Mesh: {},
		Line: { threshold: 1 },
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {

				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;

			}
		}
	} );

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

Object.assign( Raycaster.prototype, {

	set: function ( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	},

	setFromCamera: function ( coords, camera ) {

		if ( ( camera && camera.isPerspectiveCamera ) ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( ( camera && camera.isOrthographicCamera ) ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type.' );

		}

	},

	intersectObject: function ( object, recursive, optionalTarget ) {

		var intersects = optionalTarget || [];

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	},

	intersectObjects: function ( objects, recursive, optionalTarget ) {

		var intersects = optionalTarget || [];

		if ( Array.isArray( objects ) === false ) {

			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
			return intersects;

		}

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

} );

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

function Spherical( radius, phi, theta ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0;
	this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
	this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle

	return this;

}

Object.assign( Spherical.prototype, {

	set: function ( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	},

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe: function () {

		var EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	},

	setFromVector3: function ( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	},

	setFromCartesianCoords: function ( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

} );

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */

function Cylindrical( radius, theta, y ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
	this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
	this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

	return this;

}

Object.assign( Cylindrical.prototype, {

	set: function ( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	},

	setFromVector3: function ( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	},

	setFromCartesianCoords: function ( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

} );

/**
 * @author bhouston / http://clara.io
 */

var _vector$7 = new Vector2();

function Box2( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

}

Object.assign( Box2.prototype, {

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function ( center, size ) {

		var halfSize = _vector$7.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	getCenter: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getCenter() target is now required' );
			target = new Vector2();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getSize() target is now required' );
			target = new Vector2();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	},

	getParameter: function ( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getParameter() target is now required' );
			target = new Vector2();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	intersectsBox: function ( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	},

	clampPoint: function ( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .clampPoint() target is now required' );
			target = new Vector2();

		}

		return target.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function ( point ) {

		var clampedPoint = _vector$7.copy( point ).clamp( this.min, this.max );
		return clampedPoint.sub( point ).length();

	},

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

} );

/**
 * @author bhouston / http://clara.io
 */

var _startP = new Vector3();
var _startEnd = new Vector3();

function Line3( start, end ) {

	this.start = ( start !== undefined ) ? start : new Vector3();
	this.end = ( end !== undefined ) ? end : new Vector3();

}

Object.assign( Line3.prototype, {

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	getCenter: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .getCenter() target is now required' );
			target = new Vector3();

		}

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .delta() target is now required' );
			target = new Vector3();

		}

		return target.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .at() target is now required' );
			target = new Vector3();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function ( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		var startEnd2 = _startEnd.dot( _startEnd );
		var startEnd_startP = _startEnd.dot( _startP );

		var t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = MathUtils.clamp( t, 0, 1 );

		}

		return t;

	},

	closestPointToPoint: function ( point, clampToLine, target ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function ImmediateRenderObject( material ) {

	Object3D.call( this );

	this.material = material;
	this.render = function ( /* renderCallback */ ) {};

}

ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

ImmediateRenderObject.prototype.isImmediateRenderObject = true;

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _vector$8 = new Vector3();

function SpotLightHelper( light, color ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.color = color;

	var geometry = new BufferGeometry();

	var positions = [
		0, 0, 0, 	0, 0, 1,
		0, 0, 0, 	1, 0, 1,
		0, 0, 0,	- 1, 0, 1,
		0, 0, 0, 	0, 1, 1,
		0, 0, 0, 	0, - 1, 1
	];

	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

		var p1 = ( i / l ) * Math.PI * 2;
		var p2 = ( j / l ) * Math.PI * 2;

		positions.push(
			Math.cos( p1 ), Math.sin( p1 ), 1,
			Math.cos( p2 ), Math.sin( p2 ), 1
		);

	}

	geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

	var material = new LineBasicMaterial( { fog: false, toneMapped: false } );

	this.cone = new LineSegments( geometry, material );
	this.add( this.cone );

	this.update();

}

SpotLightHelper.prototype = Object.create( Object3D.prototype );
SpotLightHelper.prototype.constructor = SpotLightHelper;

SpotLightHelper.prototype.dispose = function () {

	this.cone.geometry.dispose();
	this.cone.material.dispose();

};

SpotLightHelper.prototype.update = function () {

	this.light.updateMatrixWorld();

	var coneLength = this.light.distance ? this.light.distance : 1000;
	var coneWidth = coneLength * Math.tan( this.light.angle );

	this.cone.scale.set( coneWidth, coneWidth, coneLength );

	_vector$8.setFromMatrixPosition( this.light.target.matrixWorld );

	this.cone.lookAt( _vector$8 );

	if ( this.color !== undefined ) {

		this.cone.material.color.set( this.color );

	} else {

		this.cone.material.color.copy( this.light.color );

	}

};

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */

var _vector$9 = new Vector3();
var _boneMatrix = new Matrix4();
var _matrixWorldInv = new Matrix4();

function getBoneList( object ) {

	var boneList = [];

	if ( object && object.isBone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

function SkeletonHelper( object ) {

	var bones = getBoneList( object );

	var geometry = new BufferGeometry();

	var vertices = [];
	var colors = [];

	var color1 = new Color( 0, 0, 1 );
	var color2 = new Color( 0, 1, 0 );

	for ( var i = 0; i < bones.length; i ++ ) {

		var bone = bones[ i ];

		if ( bone.parent && bone.parent.isBone ) {

			vertices.push( 0, 0, 0 );
			vertices.push( 0, 0, 0 );
			colors.push( color1.r, color1.g, color1.b );
			colors.push( color2.r, color2.g, color2.b );

		}

	}

	geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

	LineSegments.call( this, geometry, material );

	this.root = object;
	this.bones = bones;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

}

SkeletonHelper.prototype = Object.create( LineSegments.prototype );
SkeletonHelper.prototype.constructor = SkeletonHelper;

SkeletonHelper.prototype.isSkeletonHelper = true;

SkeletonHelper.prototype.updateMatrixWorld = function ( force ) {

	var bones = this.bones;

	var geometry = this.geometry;
	var position = geometry.getAttribute( 'position' );

	_matrixWorldInv.getInverse( this.root.matrixWorld );

	for ( var i = 0, j = 0; i < bones.length; i ++ ) {

		var bone = bones[ i ];

		if ( bone.parent && bone.parent.isBone ) {

			_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
			_vector$9.setFromMatrixPosition( _boneMatrix );
			position.setXYZ( j, _vector$9.x, _vector$9.y, _vector$9.z );

			_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
			_vector$9.setFromMatrixPosition( _boneMatrix );
			position.setXYZ( j + 1, _vector$9.x, _vector$9.y, _vector$9.z );

			j += 2;

		}

	}

	geometry.getAttribute( 'position' ).needsUpdate = true;

	Object3D.prototype.updateMatrixWorld.call( this, force );

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function PointLightHelper( light, sphereSize, color ) {

	this.light = light;
	this.light.updateMatrixWorld();

	this.color = color;

	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
	var material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

	Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();


	/*
	var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

}

PointLightHelper.prototype = Object.create( Mesh.prototype );
PointLightHelper.prototype.constructor = PointLightHelper;

PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();

};

PointLightHelper.prototype.update = function () {

	if ( this.color !== undefined ) {

		this.material.color.set( this.color );

	} else {

		this.material.color.copy( this.light.color );

	}

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

var _vector$a = new Vector3();
var _color1 = new Color();
var _color2 = new Color();

function HemisphereLightHelper( light, size, color ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.color = color;

	var geometry = new OctahedronBufferGeometry( size );
	geometry.rotateY( Math.PI * 0.5 );

	this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
	if ( this.color === undefined ) this.material.vertexColors = true;

	var position = geometry.getAttribute( 'position' );
	var colors = new Float32Array( position.count * 3 );

	geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

	this.add( new Mesh( geometry, this.material ) );

	this.update();

}

HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

HemisphereLightHelper.prototype.dispose = function () {

	this.children[ 0 ].geometry.dispose();
	this.children[ 0 ].material.dispose();

};

HemisphereLightHelper.prototype.update = function () {

	var mesh = this.children[ 0 ];

	if ( this.color !== undefined ) {

		this.material.color.set( this.color );

	} else {

		var colors = mesh.geometry.getAttribute( 'color' );

		_color1.copy( this.light.color );
		_color2.copy( this.light.groundColor );

		for ( var i = 0, l = colors.count; i < l; i ++ ) {

			var color = ( i < ( l / 2 ) ) ? _color1 : _color2;

			colors.setXYZ( i, color.r, color.g, color.b );

		}

		colors.needsUpdate = true;

	}

	mesh.lookAt( _vector$a.setFromMatrixPosition( this.light.matrixWorld ).negate() );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function GridHelper( size, divisions, color1, color2 ) {

	size = size || 10;
	divisions = divisions || 10;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

	var center = divisions / 2;
	var step = size / divisions;
	var halfSize = size / 2;

	var vertices = [], colors = [];

	for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

		vertices.push( - halfSize, 0, k, halfSize, 0, k );
		vertices.push( k, 0, - halfSize, k, 0, halfSize );

		var color = i === center ? color1 : color2;

		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;

	}

	var geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

	LineSegments.call( this, geometry, material );

}

GridHelper.prototype = Object.assign( Object.create( LineSegments.prototype ), {

	constructor: GridHelper,

	copy: function ( source ) {

		LineSegments.prototype.copy.call( this, source );

		this.geometry.copy( source.geometry );
		this.material.copy( source.material );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */

function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

	radius = radius || 10;
	radials = radials || 16;
	circles = circles || 8;
	divisions = divisions || 64;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

	var vertices = [];
	var colors = [];

	var x, z;
	var v, i, j, r, color;

	// create the radials

	for ( i = 0; i <= radials; i ++ ) {

		v = ( i / radials ) * ( Math.PI * 2 );

		x = Math.sin( v ) * radius;
		z = Math.cos( v ) * radius;

		vertices.push( 0, 0, 0 );
		vertices.push( x, 0, z );

		color = ( i & 1 ) ? color1 : color2;

		colors.push( color.r, color.g, color.b );
		colors.push( color.r, color.g, color.b );

	}

	// create the circles

	for ( i = 0; i <= circles; i ++ ) {

		color = ( i & 1 ) ? color1 : color2;

		r = radius - ( radius / circles * i );

		for ( j = 0; j < divisions; j ++ ) {

			// first vertex

			v = ( j / divisions ) * ( Math.PI * 2 );

			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;

			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );

			// second vertex

			v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;

			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );

		}

	}

	var geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

	LineSegments.call( this, geometry, material );

}

PolarGridHelper.prototype = Object.create( LineSegments.prototype );
PolarGridHelper.prototype.constructor = PolarGridHelper;

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _v1$5 = new Vector3();
var _v2$3 = new Vector3();
var _v3$1 = new Vector3();

function DirectionalLightHelper( light, size, color ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.color = color;

	if ( size === undefined ) size = 1;

	var geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( [
		- size, size, 0,
		size, size, 0,
		size, - size, 0,
		- size, - size, 0,
		- size, size, 0
	], 3 ) );

	var material = new LineBasicMaterial( { fog: false, toneMapped: false } );

	this.lightPlane = new Line( geometry, material );
	this.add( this.lightPlane );

	geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

	this.targetLine = new Line( geometry, material );
	this.add( this.targetLine );

	this.update();

}

DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();

};

DirectionalLightHelper.prototype.update = function () {

	_v1$5.setFromMatrixPosition( this.light.matrixWorld );
	_v2$3.setFromMatrixPosition( this.light.target.matrixWorld );
	_v3$1.subVectors( _v2$3, _v1$5 );

	this.lightPlane.lookAt( _v2$3 );

	if ( this.color !== undefined ) {

		this.lightPlane.material.color.set( this.color );
		this.targetLine.material.color.set( this.color );

	} else {

		this.lightPlane.material.color.copy( this.light.color );
		this.targetLine.material.color.copy( this.light.color );

	}

	this.targetLine.lookAt( _v2$3 );
	this.targetLine.scale.z = _v3$1.length();

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

var _vector$b = new Vector3();
var _camera = new Camera();

function CameraHelper( camera ) {

	var geometry = new BufferGeometry();
	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

	var vertices = [];
	var colors = [];

	var pointMap = {};

	// colors

	var colorFrustum = new Color( 0xffaa00 );
	var colorCone = new Color( 0xff0000 );
	var colorUp = new Color( 0x00aaff );
	var colorTarget = new Color( 0xffffff );
	var colorCross = new Color( 0x333333 );

	// near

	addLine( 'n1', 'n2', colorFrustum );
	addLine( 'n2', 'n4', colorFrustum );
	addLine( 'n4', 'n3', colorFrustum );
	addLine( 'n3', 'n1', colorFrustum );

	// far

	addLine( 'f1', 'f2', colorFrustum );
	addLine( 'f2', 'f4', colorFrustum );
	addLine( 'f4', 'f3', colorFrustum );
	addLine( 'f3', 'f1', colorFrustum );

	// sides

	addLine( 'n1', 'f1', colorFrustum );
	addLine( 'n2', 'f2', colorFrustum );
	addLine( 'n3', 'f3', colorFrustum );
	addLine( 'n4', 'f4', colorFrustum );

	// cone

	addLine( 'p', 'n1', colorCone );
	addLine( 'p', 'n2', colorCone );
	addLine( 'p', 'n3', colorCone );
	addLine( 'p', 'n4', colorCone );

	// up

	addLine( 'u1', 'u2', colorUp );
	addLine( 'u2', 'u3', colorUp );
	addLine( 'u3', 'u1', colorUp );

	// target

	addLine( 'c', 't', colorTarget );
	addLine( 'p', 'c', colorCross );

	// cross

	addLine( 'cn1', 'cn2', colorCross );
	addLine( 'cn3', 'cn4', colorCross );

	addLine( 'cf1', 'cf2', colorCross );
	addLine( 'cf3', 'cf4', colorCross );

	function addLine( a, b, color ) {

		addPoint( a, color );
		addPoint( b, color );

	}

	function addPoint( id, color ) {

		vertices.push( 0, 0, 0 );
		colors.push( color.r, color.g, color.b );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

	}

	geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	LineSegments.call( this, geometry, material );

	this.camera = camera;
	if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

}

CameraHelper.prototype = Object.create( LineSegments.prototype );
CameraHelper.prototype.constructor = CameraHelper;

CameraHelper.prototype.update = function () {

	var geometry = this.geometry;
	var pointMap = this.pointMap;

	var w = 1, h = 1;

	// we need just camera projection matrix inverse
	// world matrix must be identity

	_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

	// center / target

	setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
	setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

	// near

	setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
	setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
	setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
	setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

	// far

	setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
	setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
	setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
	setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

	// up

	setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
	setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
	setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

	// cross

	setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
	setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
	setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
	setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

	setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
	setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
	setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
	setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

	geometry.getAttribute( 'position' ).needsUpdate = true;

};

function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector$b.set( x, y, z ).unproject( camera );

	var points = pointMap[ point ];

	if ( points !== undefined ) {

		var position = geometry.getAttribute( 'position' );

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector$b.x, _vector$b.y, _vector$b.z );

		}

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */

var _box$3 = new Box3();

function BoxHelper( object, color ) {

	this.object = object;

	if ( color === undefined ) color = 0xffff00;

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );

	var geometry = new BufferGeometry();
	geometry.setIndex( new BufferAttribute( indices, 1 ) );
	geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

	this.matrixAutoUpdate = false;

	this.update();

}

BoxHelper.prototype = Object.create( LineSegments.prototype );
BoxHelper.prototype.constructor = BoxHelper;

BoxHelper.prototype.update = function ( object ) {

	if ( object !== undefined ) {

		console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

	}

	if ( this.object !== undefined ) {

		_box$3.setFromObject( this.object );

	}

	if ( _box$3.isEmpty() ) return;

	var min = _box$3.min;
	var max = _box$3.max;

	/*
	  5____4
	1/___0/|
	| 6__|_7
	2/___3/

	0: max.x, max.y, max.z
	1: min.x, max.y, max.z
	2: min.x, min.y, max.z
	3: max.x, min.y, max.z
	4: max.x, max.y, min.z
	5: min.x, max.y, min.z
	6: min.x, min.y, min.z
	7: max.x, min.y, min.z
	*/

	var position = this.geometry.attributes.position;
	var array = position.array;

	array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
	array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
	array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
	array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
	array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
	array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
	array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
	array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

	position.needsUpdate = true;

	this.geometry.computeBoundingSphere();


};

BoxHelper.prototype.setFromObject = function ( object ) {

	this.object = object;
	this.update();

	return this;

};

BoxHelper.prototype.copy = function ( source ) {

	LineSegments.prototype.copy.call( this, source );

	this.object = source.object;

	return this;

};

BoxHelper.prototype.clone = function () {

	return new this.constructor().copy( this );

};

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3Helper( box, color ) {

	this.type = 'Box3Helper';

	this.box = box;

	color = color || 0xffff00;

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

	var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

	var geometry = new BufferGeometry();

	geometry.setIndex( new BufferAttribute( indices, 1 ) );

	geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

	this.geometry.computeBoundingSphere();

}

Box3Helper.prototype = Object.create( LineSegments.prototype );
Box3Helper.prototype.constructor = Box3Helper;

Box3Helper.prototype.updateMatrixWorld = function ( force ) {

	var box = this.box;

	if ( box.isEmpty() ) return;

	box.getCenter( this.position );

	box.getSize( this.scale );

	this.scale.multiplyScalar( 0.5 );

	Object3D.prototype.updateMatrixWorld.call( this, force );

};

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function PlaneHelper( plane, size, hex ) {

	this.type = 'PlaneHelper';

	this.plane = plane;

	this.size = ( size === undefined ) ? 1 : size;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

	var geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	geometry.computeBoundingSphere();

	Line.call( this, geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

	//

	var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

	var geometry2 = new BufferGeometry();
	geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
	geometry2.computeBoundingSphere();

	this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

}

PlaneHelper.prototype = Object.create( Line.prototype );
PlaneHelper.prototype.constructor = PlaneHelper;

PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

	var scale = - this.plane.constant;

	if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

	this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

	this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

	this.lookAt( this.plane.normal );

	Object3D.prototype.updateMatrixWorld.call( this, force );

};

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

var _axis = new Vector3();
var _lineGeometry, _coneGeometry;

function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

	// dir is assumed to be normalized

	Object3D.call( this );

	if ( dir === undefined ) dir = new Vector3( 0, 0, 1 );
	if ( origin === undefined ) origin = new Vector3( 0, 0, 0 );
	if ( length === undefined ) length = 1;
	if ( color === undefined ) color = 0xffff00;
	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	if ( _lineGeometry === undefined ) {

		_lineGeometry = new BufferGeometry();
		_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

		_coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
		_coneGeometry.translate( 0, - 0.5, 0 );

	}

	this.position.copy( origin );

	this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
	this.line.matrixAutoUpdate = false;
	this.add( this.line );

	this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
	this.cone.matrixAutoUpdate = false;
	this.add( this.cone );

	this.setDirection( dir );
	this.setLength( length, headLength, headWidth );

}

ArrowHelper.prototype = Object.create( Object3D.prototype );
ArrowHelper.prototype.constructor = ArrowHelper;

ArrowHelper.prototype.setDirection = function ( dir ) {

	// dir is assumed to be normalized

	if ( dir.y > 0.99999 ) {

		this.quaternion.set( 0, 0, 0, 1 );

	} else if ( dir.y < - 0.99999 ) {

		this.quaternion.set( 1, 0, 0, 0 );

	} else {

		_axis.set( dir.z, 0, - dir.x ).normalize();

		var radians = Math.acos( dir.y );

		this.quaternion.setFromAxisAngle( _axis, radians );

	}

};

ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.set( color );
	this.cone.material.color.set( color );

};

ArrowHelper.prototype.copy = function ( source ) {

	Object3D.prototype.copy.call( this, source, false );

	this.line.copy( source.line );
	this.cone.copy( source.cone );

	return this;

};

ArrowHelper.prototype.clone = function () {

	return new this.constructor().copy( this );

};

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

function AxesHelper( size ) {

	size = size || 1;

	var vertices = [
		0, 0, 0,	size, 0, 0,
		0, 0, 0,	0, size, 0,
		0, 0, 0,	0, 0, size
	];

	var colors = [
		1, 0, 0,	1, 0.6, 0,
		0, 1, 0,	0.6, 1, 0,
		0, 0, 1,	0, 0.6, 1
	];

	var geometry = new BufferGeometry();
	geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

	LineSegments.call( this, geometry, material );

}

AxesHelper.prototype = Object.create( LineSegments.prototype );
AxesHelper.prototype.constructor = AxesHelper;

/**
 * @author Emmett Lalish / elalish
 *
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */

var LOD_MIN = 4;
var LOD_MAX = 8;
var SIZE_MAX = Math.pow( 2, LOD_MAX );
// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
var EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];
var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
var MAX_SAMPLES = 20;
var ENCODINGS = {
	[ LinearEncoding ]: 0,
	[ sRGBEncoding ]: 1,
	[ RGBEEncoding ]: 2,
	[ RGBM7Encoding ]: 3,
	[ RGBM16Encoding ]: 4,
	[ RGBDEncoding ]: 5,
	[ GammaEncoding ]: 6
};

var _flatCamera = new OrthographicCamera();
var _blurMaterial = _getBlurShader( MAX_SAMPLES );
var _equirectShader = null;
var _cubemapShader = null;

var { _lodPlanes, _sizeLods, _sigmas } = _createPlanes();
var _pingPongRenderTarget = null;
var _renderer = null;

var _oldTarget = null;

// Golden Ratio
var PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
var INV_PHI = 1 / PHI;
// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
var _axisDirections = [
	new Vector3( 1, 1, 1 ),
	new Vector3( - 1, 1, 1 ),
	new Vector3( 1, 1, - 1 ),
	new Vector3( - 1, 1, - 1 ),
	new Vector3( 0, PHI, INV_PHI ),
	new Vector3( 0, PHI, - INV_PHI ),
	new Vector3( INV_PHI, 0, PHI ),
	new Vector3( - INV_PHI, 0, PHI ),
	new Vector3( PHI, INV_PHI, 0 ),
	new Vector3( - PHI, INV_PHI, 0 ) ];

function PMREMGenerator( renderer ) {

	_renderer = renderer;
	_compileMaterial( _blurMaterial );

}

PMREMGenerator.prototype = {

	constructor: PMREMGenerator,

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene: function ( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = _renderer.getRenderTarget();
		var cubeUVRenderTarget = _allocateTargets();
		_sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
		if ( sigma > 0 ) {

			_blur( cubeUVRenderTarget, 0, 0, sigma );

		}
		_applyPMREM( cubeUVRenderTarget );
		_cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	},

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular: function ( equirectangular ) {

		equirectangular.magFilter = NearestFilter;
		equirectangular.minFilter = NearestFilter;
		equirectangular.generateMipmaps = false;

		return this.fromCubemap( equirectangular );

	},

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap: function ( cubemap ) {

		_oldTarget = _renderer.getRenderTarget();
		var cubeUVRenderTarget = _allocateTargets( cubemap );
		_textureToCubeUV( cubemap, cubeUVRenderTarget );
		_applyPMREM( cubeUVRenderTarget );
		_cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	},

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader: function () {

		if ( _cubemapShader == null ) {

			_cubemapShader = _getCubemapShader();
			_compileMaterial( _cubemapShader );

		}

	},

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader: function () {

		if ( _equirectShader == null ) {

			_equirectShader = _getEquirectShader();
			_compileMaterial( _equirectShader );

		}

	},

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose: function () {

		_blurMaterial.dispose();

		if ( _cubemapShader != null ) _cubemapShader.dispose();
		if ( _equirectShader != null ) _equirectShader.dispose();

		for ( var i = 0; i < _lodPlanes.length; i ++ ) {

			_lodPlanes[ i ].dispose();

		}

	},

};

function _createPlanes() {

	var _lodPlanes = [];
	var _sizeLods = [];
	var _sigmas = [];

	var lod = LOD_MAX;
	for ( var i = 0; i < TOTAL_LODS; i ++ ) {

		var sizeLod = Math.pow( 2, lod );
		_sizeLods.push( sizeLod );
		var sigma = 1.0 / sizeLod;
		if ( i > LOD_MAX - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];

		} else if ( i == 0 ) {

			sigma = 0;

		}
		_sigmas.push( sigma );

		var texelSize = 1.0 / ( sizeLod - 1 );
		var min = - texelSize / 2;
		var max = 1 + texelSize / 2;
		var uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		var cubeFaces = 6;
		var vertices = 6;
		var positionSize = 3;
		var uvSize = 2;
		var faceIndexSize = 1;

		var position = new Float32Array( positionSize * vertices * cubeFaces );
		var uv = new Float32Array( uvSize * vertices * cubeFaces );
		var faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( var face = 0; face < cubeFaces; face ++ ) {

			var x = ( face % 3 ) * 2 / 3 - 1;
			var y = face > 2 ? 0 : - 1;
			var coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			var fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}
		var planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		_lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}
	return { _lodPlanes, _sizeLods, _sigmas };

}

function _allocateTargets( equirectangular ) {

	var params = {
		magFilter: NearestFilter,
		minFilter: NearestFilter,
		generateMipmaps: false,
		type: equirectangular ? equirectangular.type : UnsignedByteType,
		format: equirectangular ? equirectangular.format : RGBEFormat,
		encoding: equirectangular ? equirectangular.encoding : RGBEEncoding,
		depthBuffer: false,
		stencilBuffer: false
	};
	var cubeUVRenderTarget = _createRenderTarget( params );
	cubeUVRenderTarget.depthBuffer = equirectangular ? false : true;
	_pingPongRenderTarget = _createRenderTarget( params );
	return cubeUVRenderTarget;

}

function _cleanup( outputTarget ) {

	_pingPongRenderTarget.dispose();
	_renderer.setRenderTarget( _oldTarget );
	outputTarget.scissorTest = false;
	// reset viewport and scissor
	outputTarget.setSize( outputTarget.width, outputTarget.height );

}

function _sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

	var fov = 90;
	var aspect = 1;
	var cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
	var upSign = [ 1, 1, 1, 1, - 1, 1 ];
	var forwardSign = [ 1, 1, - 1, - 1, - 1, 1 ];

	var outputEncoding = _renderer.outputEncoding;
	var toneMapping = _renderer.toneMapping;
	var toneMappingExposure = _renderer.toneMappingExposure;
	var clearColor = _renderer.getClearColor();
	var clearAlpha = _renderer.getClearAlpha();

	_renderer.toneMapping = LinearToneMapping;
	_renderer.toneMappingExposure = 1.0;
	_renderer.outputEncoding = LinearEncoding;
	scene.scale.z *= - 1;

	var background = scene.background;
	if ( background && background.isColor ) {

		background.convertSRGBToLinear();
		// Convert linear to RGBE
		var maxComponent = Math.max( background.r, background.g, background.b );
		var fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );
		background = background.multiplyScalar( Math.pow( 2.0, - fExp ) );
		var alpha = ( fExp + 128.0 ) / 255.0;
		_renderer.setClearColor( background, alpha );
		scene.background = null;

	}

	for ( var i = 0; i < 6; i ++ ) {

		var col = i % 3;
		if ( col == 0 ) {

			cubeCamera.up.set( 0, upSign[ i ], 0 );
			cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

		} else if ( col == 1 ) {

			cubeCamera.up.set( 0, 0, upSign[ i ] );
			cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

		} else {

			cubeCamera.up.set( 0, upSign[ i ], 0 );
			cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

		}
		_setViewport( cubeUVRenderTarget,
			col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );
		_renderer.setRenderTarget( cubeUVRenderTarget );
		_renderer.render( scene, cubeCamera );

	}

	_renderer.toneMapping = toneMapping;
	_renderer.toneMappingExposure = toneMappingExposure;
	_renderer.outputEncoding = outputEncoding;
	_renderer.setClearColor( clearColor, clearAlpha );
	scene.scale.z *= - 1;

}

function _textureToCubeUV( texture, cubeUVRenderTarget ) {

	var scene = new Scene();
	if ( texture.isCubeTexture ) {

		if ( _cubemapShader == null ) {

			_cubemapShader = _getCubemapShader();

		}

	} else {

		if ( _equirectShader == null ) {

			_equirectShader = _getEquirectShader();

		}

	}
	var material = texture.isCubeTexture ? _cubemapShader : _equirectShader;
	scene.add( new Mesh( _lodPlanes[ 0 ], material ) );
	var uniforms = material.uniforms;

	uniforms[ 'envMap' ].value = texture;
	if ( ! texture.isCubeTexture ) {

		uniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );

	}
	uniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];
	uniforms[ 'outputEncoding' ].value = ENCODINGS[ texture.encoding ];

	_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );
	_renderer.setRenderTarget( cubeUVRenderTarget );
	_renderer.render( scene, _flatCamera );

}

function _compileMaterial( material ) {

	var tmpScene = new Scene();
	tmpScene.add( new Mesh( _lodPlanes[ 0 ], material ) );
	_renderer.compile( tmpScene, _flatCamera );

}

function _createRenderTarget( params ) {

	var cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _applyPMREM( cubeUVRenderTarget ) {

	var autoClear = _renderer.autoClear;
	_renderer.autoClear = false;

	for ( var i = 1; i < TOTAL_LODS; i ++ ) {

		var sigma = Math.sqrt(
			_sigmas[ i ] * _sigmas[ i ] -
		_sigmas[ i - 1 ] * _sigmas[ i - 1 ] );
		var poleAxis =
		_axisDirections[ ( i - 1 ) % _axisDirections.length ];
		_blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

	}

	_renderer.autoClear = autoClear;

}

/**
 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
 * vertically and horizontally, but this breaks down on a cube. Here we apply
 * the blur latitudinally (around the poles), and then longitudinally (towards
 * the poles) to approximate the orthogonally-separable blur. It is least
 * accurate at the poles, but still does a decent job.
 */
function _blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

	_halfBlur(
		cubeUVRenderTarget,
		_pingPongRenderTarget,
		lodIn,
		lodOut,
		sigma,
		'latitudinal',
		poleAxis );

	_halfBlur(
		_pingPongRenderTarget,
		cubeUVRenderTarget,
		lodOut,
		lodOut,
		sigma,
		'longitudinal',
		poleAxis );

}

function _halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

	if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

		console.error(
			'blur direction must be either latitudinal or longitudinal!' );

	}

	// Number of standard deviations at which to cut off the discrete approximation.
	var STANDARD_DEVIATIONS = 3;

	var blurScene = new Scene();
	blurScene.add( new Mesh( _lodPlanes[ lodOut ], _blurMaterial ) );
	var blurUniforms = _blurMaterial.uniforms;

	var pixels = _sizeLods[ lodIn ] - 1;
	var radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
	var sigmaPixels = sigmaRadians / radiansPerPixel;
	var samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

	if ( samples > MAX_SAMPLES ) {

		console.warn( `sigmaRadians, ${
			sigmaRadians}, is too large and will clip, as it requested ${
			samples} samples when the maximum is set to ${MAX_SAMPLES}` );

	}

	var weights = [];
	var sum = 0;

	for ( var i = 0; i < MAX_SAMPLES; ++ i ) {

		var x = i / sigmaPixels;
		var weight = Math.exp( - x * x / 2 );
		weights.push( weight );

		if ( i == 0 ) {

			sum += weight;

		} else if ( i < samples ) {

			sum += 2 * weight;

		}

	}

	for ( var i = 0; i < weights.length; i ++ ) {

		weights[ i ] = weights[ i ] / sum;

	}

	blurUniforms[ 'envMap' ].value = targetIn.texture;
	blurUniforms[ 'samples' ].value = samples;
	blurUniforms[ 'weights' ].value = weights;
	blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';
	if ( poleAxis ) {

		blurUniforms[ 'poleAxis' ].value = poleAxis;

	}
	blurUniforms[ 'dTheta' ].value = radiansPerPixel;
	blurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;
	blurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];
	blurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];

	var outputSize = _sizeLods[ lodOut ];
	var x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );
	var y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) +
	2 * outputSize *
		( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );

	_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
	_renderer.setRenderTarget( targetOut );
	_renderer.render( blurScene, _flatCamera );

}

function _getBlurShader( maxSamples ) {

	var weights = new Float32Array( maxSamples );
	var poleAxis = new Vector3( 0, 1, 0 );
	var shaderMaterial = new RawShaderMaterial( {

		defines: { 'n': maxSamples },

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform int samples;
uniform float weights[n];
uniform bool latitudinal;
uniform float dTheta;
uniform float mipInt;
uniform vec3 poleAxis;

${_getEncodings()}

#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>

vec3 getSample(float theta, vec3 axis) {
	float cosTheta = cos(theta);
	// Rodrigues' axis-angle rotation
	vec3 sampleDirection = vOutputDirection * cosTheta
		+ cross(axis, vOutputDirection) * sin(theta)
		+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);
	return bilinearCubeUV(envMap, sampleDirection, mipInt);
}

void main() {
	vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);
	if (all(equal(axis, vec3(0.0))))
		axis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);
	axis = normalize(axis);
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb += weights[0] * getSample(0.0, axis);
	for (int i = 1; i < n; i++) {
		if (i >= samples)
			break;
		float theta = dTheta * float(i);
		gl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);
		gl_FragColor.rgb += weights[i] * getSample(theta, axis);
	}
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	shaderMaterial.type = 'SphericalGaussianBlur';

	return shaderMaterial;

}

function _getEquirectShader() {

	var texelSize = new Vector2( 1, 1 );
	var shaderMaterial = new RawShaderMaterial( {

		uniforms: {
			'envMap': { value: null },
			'texelSize': { value: texelSize },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform vec2 texelSize;

${_getEncodings()}

#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494

void main() {
	gl_FragColor = vec4(0.0);
	vec3 outputDirection = normalize(vOutputDirection);
	vec2 uv;
	uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;
	uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;
	vec2 f = fract(uv / texelSize - 0.5);
	uv -= f * texelSize;
	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x += texelSize.x;
	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.y += texelSize.y;
	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x -= texelSize.x;
	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	vec3 tm = mix(tl, tr, f.x);
	vec3 bm = mix(bl, br, f.x);
	gl_FragColor.rgb = mix(tm, bm, f.y);
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	shaderMaterial.type = 'EquirectangularToCubeUV';

	return shaderMaterial;

}

function _getCubemapShader() {

	var shaderMaterial = new RawShaderMaterial( {

		uniforms: {
			'envMap': { value: null },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform samplerCube envMap;

${_getEncodings()}

void main() {
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	shaderMaterial.type = 'CubemapToCubeUV';

	return shaderMaterial;

}

function _getCommonVertexShader() {

	return `
precision mediump float;
precision mediump int;
attribute vec3 position;
attribute vec2 uv;
attribute float faceIndex;
varying vec3 vOutputDirection;
vec3 getDirection(vec2 uv, float face) {
	uv = 2.0 * uv - 1.0;
	vec3 direction = vec3(uv, 1.0);
	if (face == 0.0) {
		direction = direction.zyx;
		direction.z *= -1.0;
	} else if (face == 1.0) {
		direction = direction.xzy;
		direction.z *= -1.0;
	} else if (face == 3.0) {
		direction = direction.zyx;
		direction.x *= -1.0;
	} else if (face == 4.0) {
		direction = direction.xzy;
		direction.y *= -1.0;
	} else if (face == 5.0) {
		direction.xz *= -1.0;
	}
	return direction;
}
void main() {
	vOutputDirection = getDirection(uv, faceIndex);
	gl_Position = vec4( position, 1.0 );
}
	`;

}

function _getEncodings() {

	return `
uniform int inputEncoding;
uniform int outputEncoding;

#include <encodings_pars_fragment>

vec4 inputTexelToLinear(vec4 value){
	if(inputEncoding == 0){
		return value;
	}else if(inputEncoding == 1){
		return sRGBToLinear(value);
	}else if(inputEncoding == 2){
		return RGBEToLinear(value);
	}else if(inputEncoding == 3){
		return RGBMToLinear(value, 7.0);
	}else if(inputEncoding == 4){
		return RGBMToLinear(value, 16.0);
	}else if(inputEncoding == 5){
		return RGBDToLinear(value, 256.0);
	}else{
		return GammaToLinear(value, 2.2);
	}
}

vec4 linearToOutputTexel(vec4 value){
	if(outputEncoding == 0){
		return value;
	}else if(outputEncoding == 1){
		return LinearTosRGB(value);
	}else if(outputEncoding == 2){
		return LinearToRGBE(value);
	}else if(outputEncoding == 3){
		return LinearToRGBM(value, 7.0);
	}else if(outputEncoding == 4){
		return LinearToRGBM(value, 16.0);
	}else if(outputEncoding == 5){
		return LinearToRGBD(value, 256.0);
	}else{
		return LinearToGamma(value, 2.2);
	}
}

vec4 envMapTexelToLinear(vec4 color) {
	return inputTexelToLinear(color);
}
	`;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Face4( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
	return new Face3( a, b, c, normal, color, materialIndex );

}

var LineStrip = 0;
var LinePieces = 1;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
	return materials;

}

function MultiMaterial( materials ) {

	if ( materials === undefined ) materials = [];

	console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
	materials.isMultiMaterial = true;
	materials.materials = materials;
	materials.clone = function () {

		return materials.slice();

	};
	return materials;

}

function PointCloud( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function Particle( material ) {

	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
	return new Sprite( material );

}

function ParticleSystem( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function PointCloudMaterial( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleBasicMaterial( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleSystemMaterial( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function Vertex( x, y, z ) {

	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
	return new Vector3( x, y, z );

}

//

function DynamicBufferAttribute( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
	return new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );

}

function Int8Attribute( array, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
	return new Int8BufferAttribute( array, itemSize );

}

function Uint8Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
	return new Uint8BufferAttribute( array, itemSize );

}

function Uint8ClampedAttribute( array, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
	return new Uint8ClampedBufferAttribute( array, itemSize );

}

function Int16Attribute( array, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
	return new Int16BufferAttribute( array, itemSize );

}

function Uint16Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
	return new Uint16BufferAttribute( array, itemSize );

}

function Int32Attribute( array, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
	return new Int32BufferAttribute( array, itemSize );

}

function Uint32Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
	return new Uint32BufferAttribute( array, itemSize );

}

function Float32Attribute( array, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
	return new Float32BufferAttribute( array, itemSize );

}

function Float64Attribute( array, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
	return new Float64BufferAttribute( array, itemSize );

}

//

Curve.create = function ( construct, getPoint ) {

	console.log( 'THREE.Curve.create() has been deprecated' );

	construct.prototype = Object.create( Curve.prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;

	return construct;

};

//

Object.assign( CurvePath.prototype, {

	createPointsGeometry: function ( divisions ) {

		console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

		// generate geometry from path points (for Line or Points objects)

		var pts = this.getPoints( divisions );
		return this.createGeometry( pts );

	},

	createSpacedPointsGeometry: function ( divisions ) {

		console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

		// generate geometry from equidistant sampling along the path

		var pts = this.getSpacedPoints( divisions );
		return this.createGeometry( pts );

	},

	createGeometry: function ( points ) {

		console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

		var geometry = new Geometry();

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

		}

		return geometry;

	}

} );

//

Object.assign( Path.prototype, {

	fromPoints: function ( points ) {

		console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
		return this.setFromPoints( points );

	}

} );

//

function ClosedSplineCurve3( points ) {

	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';
	this.closed = true;

}

ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

//

function SplineCurve3( points ) {

	console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';

}

SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

//

function Spline( points ) {

	console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';

}

Spline.prototype = Object.create( CatmullRomCurve3.prototype );

Object.assign( Spline.prototype, {

	initFromArray: function ( /* a */ ) {

		console.error( 'THREE.Spline: .initFromArray() has been removed.' );

	},
	getControlPointsArray: function ( /* optionalTarget */ ) {

		console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

	},
	reparametrizeByArcLength: function ( /* samplingCoef */ ) {

		console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

	}

} );

//

function AxisHelper( size ) {

	console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
	return new AxesHelper( size );

}

function BoundingBoxHelper( object, color ) {

	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
	return new BoxHelper( object, color );

}

function EdgesHelper( object, hex ) {

	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

SkeletonHelper.prototype.update = function () {

	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

};

function WireframeHelper( object, hex ) {

	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

//

Object.assign( Loader.prototype, {

	extractUrlBase: function ( url ) {

		console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
		return LoaderUtils.extractUrlBase( url );

	}

} );

Loader.Handlers = {

	add: function ( /* regex, loader */ ) {

		console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

	},

	get: function ( /* file */ ) {

		console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

	}

};

function XHRLoader( manager ) {

	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
	return new FileLoader( manager );

}

function BinaryTextureLoader( manager ) {

	console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
	return new DataTextureLoader( manager );

}

Object.assign( ObjectLoader.prototype, {

	setTexturePath: function ( value ) {

		console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
		return this.setResourcePath( value );

	}

} );

//

Object.assign( Box2.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Object.assign( Box3.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Frustum.prototype.setFromMatrix = function ( m ) {

	console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
	return this.setFromProjectionMatrix( m );

};

Line3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Object.assign( MathUtils, {

	random16: function () {

		console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
		return Math.random();

	},

	nearestPowerOfTwo: function ( value ) {

		console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
		return MathUtils.floorPowerOfTwo( value );

	},

	nextPowerOfTwo: function ( value ) {

		console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
		return MathUtils.ceilPowerOfTwo( value );

	}

} );

Object.assign( Matrix3.prototype, {

	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},
	multiplyVector3Array: function ( /* a */ ) {

		console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

	},
	applyToBufferAttribute: function ( attribute ) {

		console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
		return attribute.applyMatrix3( this );

	},
	applyToVector3Array: function ( /* array, offset, length */ ) {

		console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

	}

} );

Object.assign( Matrix4.prototype, {

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},
	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	getPosition: function () {

		console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
		return new Vector3().setFromMatrixColumn( this, 3 );

	},
	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
		return this.makeRotationFromQuaternion( q );

	},
	multiplyToArray: function () {

		console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector3Array: function ( /* a */ ) {

		console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

	},
	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
		v.transformDirection( this );

	},
	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	translate: function () {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	},
	rotateX: function () {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	},
	rotateY: function () {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	},
	rotateZ: function () {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},
	rotateByAxis: function () {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},
	applyToBufferAttribute: function ( attribute ) {

		console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
		return attribute.applyMatrix4( this );

	},
	applyToVector3Array: function ( /* array, offset, length */ ) {

		console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

	},
	makeFrustum: function ( left, right, bottom, top, near, far ) {

		console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
		return this.makePerspective( left, right, top, bottom, near, far );

	}

} );

Plane.prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

Quaternion.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );

};

Object.assign( Ray.prototype, {

	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionPlane: function ( plane ) {

		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
		return this.intersectsPlane( plane );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	}

} );

Object.assign( Triangle.prototype, {

	area: function () {

		console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
		return this.getArea();

	},
	barycoordFromPoint: function ( point, target ) {

		console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
		return this.getBarycoord( point, target );

	},
	midpoint: function ( target ) {

		console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
		return this.getMidpoint( target );

	},
	normal: function ( target ) {

		console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
		return this.getNormal( target );

	},
	plane: function ( target ) {

		console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
		return this.getPlane( target );

	}

} );

Object.assign( Triangle, {

	barycoordFromPoint: function ( point, a, b, c, target ) {

		console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
		return Triangle.getBarycoord( point, a, b, c, target );

	},
	normal: function ( a, b, c, target ) {

		console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
		return Triangle.getNormal( a, b, c, target );

	}

} );

Object.assign( Shape.prototype, {

	extractAllPoints: function ( divisions ) {

		console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
		return this.extractPoints( divisions );

	},
	extrude: function ( options ) {

		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
		return new ExtrudeGeometry( this, options );

	},
	makeGeometry: function ( options ) {

		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
		return new ShapeGeometry( this, options );

	}

} );

Object.assign( Vector2.prototype, {

	fromAttribute: function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	},
	distanceToManhattan: function ( v ) {

		console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );

	},
	lengthManhattan: function () {

		console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	}

} );

Object.assign( Vector3.prototype, {

	setEulerFromRotationMatrix: function () {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},
	setEulerFromQuaternion: function () {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},
	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
		return this.setFromMatrixPosition( m );

	},
	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
		return this.setFromMatrixScale( m );

	},
	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
		return this.setFromMatrixColumn( matrix, index );

	},
	applyProjection: function ( m ) {

		console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
		return this.applyMatrix4( m );

	},
	fromAttribute: function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	},
	distanceToManhattan: function ( v ) {

		console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
		return this.manhattanDistanceTo( v );

	},
	lengthManhattan: function () {

		console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	}

} );

Object.assign( Vector4.prototype, {

	fromAttribute: function ( attribute, index, offset ) {

		console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
		return this.fromBufferAttribute( attribute, index, offset );

	},
	lengthManhattan: function () {

		console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
		return this.manhattanLength();

	}

} );

//

Object.assign( Geometry.prototype, {

	computeTangents: function () {

		console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

	},
	computeLineDistances: function () {

		console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

	},
	applyMatrix: function ( matrix ) {

		console.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	}

} );

Object.assign( Object3D.prototype, {

	getChildByName: function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	},
	renderDepth: function () {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	},
	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	},
	getWorldRotation: function () {

		console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

	},
	applyMatrix: function ( matrix ) {

		console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	}

} );

Object.defineProperties( Object3D.prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

Object.assign( Mesh.prototype, {

	setDrawMode: function () {

		console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

	},

} );

Object.defineProperties( Mesh.prototype, {

	drawMode: {
		get: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
			return TrianglesDrawMode;

		},
		set: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		}
	}

} );

Object.defineProperties( LOD.prototype, {

	objects: {
		get: function () {

			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
			return this.levels;

		}
	}

} );

Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

	get: function () {

		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

	},
	set: function () {

		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

	}

} );

SkinnedMesh.prototype.initBones = function () {

	console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

};

Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

	get: function () {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		return this.arcLengthDivisions;

	},
	set: function ( value ) {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		this.arcLengthDivisions = value;

	}

} );

//

PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
			"Use .setFocalLength and .filmGauge for a photographic setup." );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( Light.prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( BufferAttribute.prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	},
	dynamic: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			this.setUsage( DynamicDrawUsage );

		}
	}

} );

Object.assign( BufferAttribute.prototype, {
	setDynamic: function ( value ) {

		console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
		this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
		return this;

	},
	copyIndicesArray: function ( /* indices */ ) {

		console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

	},
	setArray: function ( /* array */ ) {

		console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

	}
} );

Object.assign( BufferGeometry.prototype, {

	addIndex: function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	},
	addAttribute: function ( name, attribute ) {

		console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return this;

		}

		return this.setAttribute( name, attribute );

	},
	addDrawCall: function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}
		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	},
	clearDrawCalls: function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	},
	computeTangents: function () {

		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

	},
	computeOffsets: function () {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

	},
	removeAttribute: function ( name ) {

		console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

		return this.deleteAttribute( name );

	},
	applyMatrix: function ( matrix ) {

		console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
		return this.applyMatrix4( matrix );

	}

} );

Object.defineProperties( BufferGeometry.prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

Object.defineProperties( Raycaster.prototype, {

	linePrecision: {
		get: function () {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			return this.params.Line.threshold;

		},
		set: function ( value ) {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			this.params.Line.threshold = value;

		}
	}

} );

Object.defineProperties( InterleavedBuffer.prototype, {

	dynamic: {
		get: function () {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( value ) {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			this.setUsage( value );

		}
	}

} );

Object.assign( InterleavedBuffer.prototype, {
	setDynamic: function ( value ) {

		console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
		this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
		return this;

	},
	setArray: function ( /* array */ ) {

		console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

	}
} );

//

Object.assign( ExtrudeBufferGeometry.prototype, {

	getArrays: function () {

		console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );

	},

	addShapeList: function () {

		console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );

	},

	addShape: function () {

		console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );

	}

} );

//

Object.defineProperties( Uniform.prototype, {

	dynamic: {
		set: function () {

			console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

		}
	},
	onUpdate: {
		value: function () {

			console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
			return this;

		}
	}

} );

//

Object.defineProperties( Material.prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		}
	},

	overdraw: {
		get: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		}
	},

	wrapRGB: {
		get: function () {

			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			return new Color();

		}
	},

	shading: {
		get: function () {

			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			this.flatShading = ( value === FlatShading );

		}
	},

	stencilMask: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			return this.stencilFuncMask;

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			this.stencilFuncMask = value;

		}
	}

} );

Object.defineProperties( MeshPhongMaterial.prototype, {

	metal: {
		get: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

		}
	}

} );

Object.defineProperties( ShaderMaterial.prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

Object.assign( WebGLRenderer.prototype, {

	clearTarget: function ( renderTarget, color, depth, stencil ) {

		console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	},
	animate: function ( callback ) {

		console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
		this.setAnimationLoop( callback );

	},
	getCurrentRenderTarget: function () {

		console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
		return this.getRenderTarget();

	},
	getMaxAnisotropy: function () {

		console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
		return this.capabilities.getMaxAnisotropy();

	},
	getPrecision: function () {

		console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
		return this.capabilities.precision;

	},
	resetGLState: function () {

		console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
		return this.state.reset();

	},
	supportsFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return this.extensions.get( 'OES_texture_float' );

	},
	supportsHalfFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return this.extensions.get( 'OES_texture_half_float' );

	},
	supportsStandardDerivatives: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return this.extensions.get( 'OES_standard_derivatives' );

	},
	supportsCompressedTextureS3TC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

	},
	supportsCompressedTexturePVRTC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	},
	supportsBlendMinMax: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return this.extensions.get( 'EXT_blend_minmax' );

	},
	supportsVertexTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
		return this.capabilities.vertexTextures;

	},
	supportsInstancedArrays: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return this.extensions.get( 'ANGLE_instanced_arrays' );

	},
	enableScissorTest: function ( boolean ) {

		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
		this.setScissorTest( boolean );

	},
	initMaterial: function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	},
	addPrePlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	},
	addPostPlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	},
	updateShadowMap: function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	},
	setFaceCulling: function () {

		console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

	},
	allocTextureUnit: function () {

		console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

	},
	setTexture: function () {

		console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

	},
	setTexture2D: function () {

		console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

	},
	setTextureCube: function () {

		console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

	},
	getActiveMipMapLevel: function () {

		console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
		return this.getActiveMipmapLevel();

	}

} );

Object.defineProperties( WebGLRenderer.prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	context: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
			return this.getContext();

		}
	},
	vr: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
			return this.xr;

		}
	},
	gammaInput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

		}
	},
	gammaOutput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			return false;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

		}
	}

} );

Object.defineProperties( WebGLShadowMap.prototype, {

	cullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* cullFace */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderReverseSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderSingleSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

		}
	}

} );

function WebGLRenderTargetCube( width, height, options ) {

	console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
	return new WebGLCubeRenderTarget( width, options );

}

//

Object.defineProperties( WebGLRenderTarget.prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

Object.defineProperties( Audio.prototype, {

	load: {
		value: function ( file ) {

			console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
			var scope = this;
			var audioLoader = new AudioLoader();
			audioLoader.load( file, function ( buffer ) {

				scope.setBuffer( buffer );

			} );
			return this;

		}
	},
	startTime: {
		set: function () {

			console.warn( 'THREE.Audio: .startTime is now .play( delay ).' );

		}
	}

} );

AudioAnalyser.prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	return this.update( renderer, scene );

};

//

var GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
		var matrix;

		if ( geometry2.isMesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

	var loader = new TextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	var texture = loader.load( url, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

	var loader = new CubeTextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	var texture = loader.load( urls, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadCompressedTexture = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

};

ImageUtils.loadCompressedTextureCube = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

};

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been removed' );

}

//

function JSONLoader() {

	console.error( 'THREE.JSONLoader has been removed.' );

}

//

var SceneUtils = {

	createMultiMaterialObject: function ( /* geometry, materials */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	detach: function ( /* child, parent, scene */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	attach: function ( /* child, scene, parent */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	}

};

//

function LensFlare() {

	console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	/* eslint-disable no-undef */
	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );
	/* eslint-enable no-undef */

}




/***/ }),

/***/ "./src/components/App/Blink.tsx":
/*!**************************************!*\
  !*** ./src/components/App/Blink.tsx ***!
  \**************************************/
/*! exports provided: Blink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Blink", function() { return Blink; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);








function cov_2oymtlalxp() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/components/App/Blink.tsx";
  var hash = "8bf65b181cdf9c2d62d93835b135768f12c9907c";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/components/App/Blink.tsx",
    statementMap: {
      "0": {
        start: {
          line: 14,
          column: 22
        },
        end: {
          line: 14,
          column: 26
        }
      },
      "1": {
        start: {
          line: 15,
          column: 24
        },
        end: {
          line: 18,
          column: 3
        }
      },
      "2": {
        start: {
          line: 20,
          column: 4
        },
        end: {
          line: 20,
          column: 17
        }
      },
      "3": {
        start: {
          line: 21,
          column: 4
        },
        end: {
          line: 24,
          column: 6
        }
      },
      "4": {
        start: {
          line: 25,
          column: 4
        },
        end: {
          line: 25,
          column: 70
        }
      },
      "5": {
        start: {
          line: 28,
          column: 4
        },
        end: {
          line: 31,
          column: 5
        }
      },
      "6": {
        start: {
          line: 29,
          column: 6
        },
        end: {
          line: 29,
          column: 50
        }
      },
      "7": {
        start: {
          line: 30,
          column: 6
        },
        end: {
          line: 30,
          column: 28
        }
      },
      "8": {
        start: {
          line: 33,
          column: 13
        },
        end: {
          line: 46,
          column: 3
        }
      },
      "9": {
        start: {
          line: 33,
          column: 30
        },
        end: {
          line: 46,
          column: 3
        }
      },
      "10": {
        start: {
          line: 34,
          column: 20
        },
        end: {
          line: 34,
          column: 46
        }
      },
      "11": {
        start: {
          line: 35,
          column: 17
        },
        end: {
          line: 35,
          column: 57
        }
      },
      "12": {
        start: {
          line: 37,
          column: 24
        },
        end: {
          line: 37,
          column: 81
        }
      },
      "13": {
        start: {
          line: 38,
          column: 19
        },
        end: {
          line: 38,
          column: 45
        }
      },
      "14": {
        start: {
          line: 39,
          column: 4
        },
        end: {
          line: 42,
          column: 7
        }
      },
      "15": {
        start: {
          line: 43,
          column: 4
        },
        end: {
          line: 45,
          column: 5
        }
      },
      "16": {
        start: {
          line: 44,
          column: 6
        },
        end: {
          line: 44,
          column: 72
        }
      },
      "17": {
        start: {
          line: 48,
          column: 4
        },
        end: {
          line: 48,
          column: 58
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 19,
            column: 2
          },
          end: {
            line: 19,
            column: 3
          }
        },
        loc: {
          start: {
            line: 19,
            column: 34
          },
          end: {
            line: 26,
            column: 3
          }
        },
        line: 19
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 27,
            column: 2
          },
          end: {
            line: 27,
            column: 3
          }
        },
        loc: {
          start: {
            line: 27,
            column: 25
          },
          end: {
            line: 32,
            column: 3
          }
        },
        line: 27
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 33,
            column: 13
          },
          end: {
            line: 33,
            column: 14
          }
        },
        loc: {
          start: {
            line: 33,
            column: 30
          },
          end: {
            line: 46,
            column: 3
          }
        },
        line: 33
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 33,
            column: 30
          },
          end: {
            line: 33,
            column: 31
          }
        },
        loc: {
          start: {
            line: 33,
            column: 36
          },
          end: {
            line: 46,
            column: 3
          }
        },
        line: 33
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 47,
            column: 2
          },
          end: {
            line: 47,
            column: 3
          }
        },
        loc: {
          start: {
            line: 47,
            column: 11
          },
          end: {
            line: 49,
            column: 3
          }
        },
        line: 47
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 28,
            column: 4
          },
          end: {
            line: 31,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 28,
            column: 4
          },
          end: {
            line: 31,
            column: 5
          }
        }, {
          start: {
            line: 28,
            column: 4
          },
          end: {
            line: 31,
            column: 5
          }
        }],
        line: 28
      },
      "1": {
        loc: {
          start: {
            line: 38,
            column: 19
          },
          end: {
            line: 38,
            column: 45
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 38,
            column: 26
          },
          end: {
            line: 38,
            column: 31
          }
        }, {
          start: {
            line: 38,
            column: 34
          },
          end: {
            line: 38,
            column: 45
          }
        }],
        line: 38
      },
      "2": {
        loc: {
          start: {
            line: 43,
            column: 4
          },
          end: {
            line: 45,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 43,
            column: 4
          },
          end: {
            line: 45,
            column: 5
          }
        }, {
          start: {
            line: 43,
            column: 4
          },
          end: {
            line: 45,
            column: 5
          }
        }],
        line: 43
      },
      "3": {
        loc: {
          start: {
            line: 48,
            column: 11
          },
          end: {
            line: 48,
            column: 57
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 48,
            column: 31
          },
          end: {
            line: 48,
            column: 35
          }
        }, {
          start: {
            line: 48,
            column: 38
          },
          end: {
            line: 48,
            column: 57
          }
        }],
        line: 48
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "8bf65b181cdf9c2d62d93835b135768f12c9907c"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2oymtlalxp = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2oymtlalxp();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var Blink = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Blink, _React$Component);

  var _super = _createSuper(Blink);

  function Blink(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Blink);

    cov_2oymtlalxp().f[0]++;
    cov_2oymtlalxp().s[2]++;
    _this = _super.call(this, props);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "requestID", (cov_2oymtlalxp().s[0]++, null));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_animate", (cov_2oymtlalxp().s[8]++, function (now) {
      cov_2oymtlalxp().f[2]++;
      cov_2oymtlalxp().s[9]++;
      return function () {
        cov_2oymtlalxp().f[3]++;
        var elapsed = (cov_2oymtlalxp().s[10]++, now - _this.state.startTime);
        var done = (cov_2oymtlalxp().s[11]++, elapsed > _this.props.totalDurationMillis); // const blinkHidden = Math.floor((elapsed / this.props.blinkDurationMillis) % 2) === 1;  // https://github.com/babel/minify/issues/904

        var blinkHidden = (cov_2oymtlalxp().s[12]++, elapsed / _this.props.blinkDurationMillis % 2 << 0 === 1);
        var hidden = (cov_2oymtlalxp().s[13]++, done ? (cov_2oymtlalxp().b[1][0]++, false) : (cov_2oymtlalxp().b[1][1]++, blinkHidden));
        cov_2oymtlalxp().s[14]++;

        _this.setState(_objectSpread({}, _this.state, {
          hidden: hidden
        }));

        cov_2oymtlalxp().s[15]++;

        if (!done) {
          cov_2oymtlalxp().b[2][0]++;
          cov_2oymtlalxp().s[16]++;
          _this.requestID = requestAnimationFrame(_this._animate(Date.now()));
        } else {
          cov_2oymtlalxp().b[2][1]++;
        }
      };
    }));

    cov_2oymtlalxp().s[3]++;
    _this.state = {
      hidden: false,
      startTime: Date.now()
    };
    cov_2oymtlalxp().s[4]++;
    _this.requestID = requestAnimationFrame(_this._animate(Date.now()));
    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Blink, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cov_2oymtlalxp().f[1]++;
      cov_2oymtlalxp().s[5]++;

      if (this.requestID) {
        cov_2oymtlalxp().b[0][0]++;
        cov_2oymtlalxp().s[6]++;
        window.cancelAnimationFrame(this.requestID);
        cov_2oymtlalxp().s[7]++;
        this.requestID = null;
      } else {
        cov_2oymtlalxp().b[0][1]++;
      }
    }
  }, {
    key: "render",
    value: function render() {
      cov_2oymtlalxp().f[4]++;
      cov_2oymtlalxp().s[17]++;
      return this.state.hidden ? (cov_2oymtlalxp().b[3][0]++, null) : (cov_2oymtlalxp().b[3][1]++, this.props.children);
    }
  }]);

  return Blink;
}((react__WEBPACK_IMPORTED_MODULE_7___default.a.Component));

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Blink, "defaultProps", (cov_2oymtlalxp().s[1]++, {
  totalDurationMillis: 2000,
  blinkDurationMillis: 300
}));

/***/ }),

/***/ "./src/components/App/Game/GameDarkSublayout.tsx":
/*!*******************************************************!*\
  !*** ./src/components/App/Game/GameDarkSublayout.tsx ***!
  \*******************************************************/
/*! exports provided: GameDarkSublayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameDarkSublayout", function() { return GameDarkSublayout; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @material-ui/core/Typography */ "./node_modules/@material-ui/core/esm/Typography/index.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _media_fbg_logo_white_48_png__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../media/fbg_logo_white_48.png */ "./src/components/App/media/fbg_logo_white_48.png");
/* harmony import */ var _media_fbg_logo_white_48_png__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_media_fbg_logo_white_48_png__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _material_ui_core_Button__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @material-ui/core/Button */ "./node_modules/@material-ui/core/esm/Button/index.js");
/* harmony import */ var _material_ui_icons_MoreVert__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @material-ui/icons/MoreVert */ "./node_modules/@material-ui/icons/MoreVert.js");
/* harmony import */ var _material_ui_icons_MoreVert__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_MoreVert__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _material_ui_core_Menu__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @material-ui/core/Menu */ "./node_modules/@material-ui/core/esm/Menu/index.js");
/* harmony import */ var _material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @material-ui/core/MenuItem */ "./node_modules/@material-ui/core/esm/MenuItem/index.js");
/* harmony import */ var _material_ui_icons_Feedback__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @material-ui/icons/Feedback */ "./node_modules/@material-ui/icons/Feedback.js");
/* harmony import */ var _material_ui_icons_Feedback__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Feedback__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var games__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! games */ "./src/games/index.ts");
/* harmony import */ var components_DesktopMobileView__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! components/DesktopMobileView */ "./src/components/DesktopMobileView.tsx");







var __jsx = react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement;

function cov_r7p0jshdj() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/components/App/Game/GameDarkSublayout.tsx";
  var hash = "dc0537ab6fd883677a44d9a264477658c0cf8a3d";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/components/App/Game/GameDarkSublayout.tsx",
    statementMap: {
      "0": {
        start: {
          line: 34,
          column: 4
        },
        end: {
          line: 34,
          column: 17
        }
      },
      "1": {
        start: {
          line: 35,
          column: 4
        },
        end: {
          line: 35,
          column: 106
        }
      },
      "2": {
        start: {
          line: 36,
          column: 4
        },
        end: {
          line: 36,
          column: 50
        }
      },
      "3": {
        start: {
          line: 40,
          column: 4
        },
        end: {
          line: 40,
          column: 65
        }
      },
      "4": {
        start: {
          line: 44,
          column: 26
        },
        end: {
          line: 44,
          column: 63
        }
      },
      "5": {
        start: {
          line: 45,
          column: 21
        },
        end: {
          line: 45,
          column: 65
        }
      },
      "6": {
        start: {
          line: 47,
          column: 4
        },
        end: {
          line: 65,
          column: 5
        }
      },
      "7": {
        start: {
          line: 48,
          column: 6
        },
        end: {
          line: 54,
          column: 7
        }
      },
      "8": {
        start: {
          line: 49,
          column: 8
        },
        end: {
          line: 53,
          column: 10
        }
      },
      "9": {
        start: {
          line: 56,
          column: 6
        },
        end: {
          line: 64,
          column: 8
        }
      },
      "10": {
        start: {
          line: 68,
          column: 4
        },
        end: {
          line: 87,
          column: 5
        }
      },
      "11": {
        start: {
          line: 69,
          column: 6
        },
        end: {
          line: 73,
          column: 8
        }
      },
      "12": {
        start: {
          line: 75,
          column: 6
        },
        end: {
          line: 86,
          column: 8
        }
      },
      "13": {
        start: {
          line: 89,
          column: 4
        },
        end: {
          line: 131,
          column: 6
        }
      },
      "14": {
        start: {
          line: 134,
          column: 4
        },
        end: {
          line: 145,
          column: 5
        }
      },
      "15": {
        start: {
          line: 135,
          column: 6
        },
        end: {
          line: 144,
          column: 8
        }
      },
      "16": {
        start: {
          line: 148,
          column: 20
        },
        end: {
          line: 153,
          column: 3
        }
      },
      "17": {
        start: {
          line: 149,
          column: 4
        },
        end: {
          line: 151,
          column: 13
        }
      },
      "18": {
        start: {
          line: 150,
          column: 6
        },
        end: {
          line: 150,
          column: 41
        }
      },
      "19": {
        start: {
          line: 152,
          column: 4
        },
        end: {
          line: 152,
          column: 54
        }
      },
      "20": {
        start: {
          line: 155,
          column: 21
        },
        end: {
          line: 157,
          column: 3
        }
      },
      "21": {
        start: {
          line: 156,
          column: 4
        },
        end: {
          line: 156,
          column: 57
        }
      },
      "22": {
        start: {
          line: 159,
          column: 22
        },
        end: {
          line: 161,
          column: 3
        }
      },
      "23": {
        start: {
          line: 160,
          column: 4
        },
        end: {
          line: 160,
          column: 42
        }
      },
      "24": {
        start: {
          line: 163,
          column: 17
        },
        end: {
          line: 167,
          column: 3
        }
      },
      "25": {
        start: {
          line: 163,
          column: 46
        },
        end: {
          line: 167,
          column: 3
        }
      },
      "26": {
        start: {
          line: 165,
          column: 4
        },
        end: {
          line: 165,
          column: 29
        }
      },
      "27": {
        start: {
          line: 166,
          column: 4
        },
        end: {
          line: 166,
          column: 18
        }
      },
      "28": {
        start: {
          line: 169,
          column: 25
        },
        end: {
          line: 186,
          column: 3
        }
      },
      "29": {
        start: {
          line: 170,
          column: 4
        },
        end: {
          line: 172,
          column: 5
        }
      },
      "30": {
        start: {
          line: 171,
          column: 6
        },
        end: {
          line: 171,
          column: 13
        }
      },
      "31": {
        start: {
          line: 173,
          column: 29
        },
        end: {
          line: 173,
          column: 39
        }
      },
      "32": {
        start: {
          line: 174,
          column: 22
        },
        end: {
          line: 180,
          column: 6
        }
      },
      "33": {
        start: {
          line: 175,
          column: 6
        },
        end: {
          line: 179,
          column: 8
        }
      },
      "34": {
        start: {
          line: 181,
          column: 4
        },
        end: {
          line: 185,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 33,
            column: 2
          },
          end: {
            line: 33,
            column: 3
          }
        },
        loc: {
          start: {
            line: 33,
            column: 46
          },
          end: {
            line: 37,
            column: 3
          }
        },
        line: 33
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 39,
            column: 2
          },
          end: {
            line: 39,
            column: 3
          }
        },
        loc: {
          start: {
            line: 39,
            column: 25
          },
          end: {
            line: 41,
            column: 3
          }
        },
        line: 39
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 43,
            column: 2
          },
          end: {
            line: 43,
            column: 3
          }
        },
        loc: {
          start: {
            line: 43,
            column: 11
          },
          end: {
            line: 132,
            column: 3
          }
        },
        line: 43
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 133,
            column: 2
          },
          end: {
            line: 133,
            column: 3
          }
        },
        loc: {
          start: {
            line: 133,
            column: 26
          },
          end: {
            line: 146,
            column: 3
          }
        },
        line: 133
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 148,
            column: 20
          },
          end: {
            line: 148,
            column: 21
          }
        },
        loc: {
          start: {
            line: 148,
            column: 26
          },
          end: {
            line: 153,
            column: 3
          }
        },
        line: 148
      },
      "5": {
        name: "(anonymous_5)",
        decl: {
          start: {
            line: 149,
            column: 15
          },
          end: {
            line: 149,
            column: 16
          }
        },
        loc: {
          start: {
            line: 149,
            column: 21
          },
          end: {
            line: 151,
            column: 5
          }
        },
        line: 149
      },
      "6": {
        name: "(anonymous_6)",
        decl: {
          start: {
            line: 155,
            column: 21
          },
          end: {
            line: 155,
            column: 22
          }
        },
        loc: {
          start: {
            line: 155,
            column: 37
          },
          end: {
            line: 157,
            column: 3
          }
        },
        line: 155
      },
      "7": {
        name: "(anonymous_7)",
        decl: {
          start: {
            line: 159,
            column: 22
          },
          end: {
            line: 159,
            column: 23
          }
        },
        loc: {
          start: {
            line: 159,
            column: 28
          },
          end: {
            line: 161,
            column: 3
          }
        },
        line: 159
      },
      "8": {
        name: "(anonymous_8)",
        decl: {
          start: {
            line: 163,
            column: 17
          },
          end: {
            line: 163,
            column: 18
          }
        },
        loc: {
          start: {
            line: 163,
            column: 46
          },
          end: {
            line: 167,
            column: 3
          }
        },
        line: 163
      },
      "9": {
        name: "(anonymous_9)",
        decl: {
          start: {
            line: 163,
            column: 46
          },
          end: {
            line: 163,
            column: 47
          }
        },
        loc: {
          start: {
            line: 163,
            column: 52
          },
          end: {
            line: 167,
            column: 3
          }
        },
        line: 163
      },
      "10": {
        name: "(anonymous_10)",
        decl: {
          start: {
            line: 169,
            column: 25
          },
          end: {
            line: 169,
            column: 26
          }
        },
        loc: {
          start: {
            line: 169,
            column: 31
          },
          end: {
            line: 186,
            column: 3
          }
        },
        line: 169
      },
      "11": {
        name: "(anonymous_11)",
        decl: {
          start: {
            line: 174,
            column: 56
          },
          end: {
            line: 174,
            column: 57
          }
        },
        loc: {
          start: {
            line: 174,
            column: 90
          },
          end: {
            line: 180,
            column: 5
          }
        },
        line: 174
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 47,
            column: 4
          },
          end: {
            line: 65,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 47,
            column: 4
          },
          end: {
            line: 65,
            column: 5
          }
        }, {
          start: {
            line: 47,
            column: 4
          },
          end: {
            line: 65,
            column: 5
          }
        }],
        line: 47
      },
      "1": {
        loc: {
          start: {
            line: 48,
            column: 6
          },
          end: {
            line: 54,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 48,
            column: 6
          },
          end: {
            line: 54,
            column: 7
          }
        }, {
          start: {
            line: 48,
            column: 6
          },
          end: {
            line: 54,
            column: 7
          }
        }],
        line: 48
      },
      "2": {
        loc: {
          start: {
            line: 68,
            column: 4
          },
          end: {
            line: 87,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 68,
            column: 4
          },
          end: {
            line: 87,
            column: 5
          }
        }, {
          start: {
            line: 68,
            column: 4
          },
          end: {
            line: 87,
            column: 5
          }
        }],
        line: 68
      },
      "3": {
        loc: {
          start: {
            line: 101,
            column: 24
          },
          end: {
            line: 101,
            column: 72
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 101,
            column: 54
          },
          end: {
            line: 101,
            column: 62
          }
        }, {
          start: {
            line: 101,
            column: 65
          },
          end: {
            line: 101,
            column: 72
          }
        }],
        line: 101
      },
      "4": {
        loc: {
          start: {
            line: 121,
            column: 22
          },
          end: {
            line: 121,
            column: 70
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 121,
            column: 52
          },
          end: {
            line: 121,
            column: 60
          }
        }, {
          start: {
            line: 121,
            column: 63
          },
          end: {
            line: 121,
            column: 70
          }
        }],
        line: 121
      },
      "5": {
        loc: {
          start: {
            line: 134,
            column: 4
          },
          end: {
            line: 145,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 134,
            column: 4
          },
          end: {
            line: 145,
            column: 5
          }
        }, {
          start: {
            line: 134,
            column: 4
          },
          end: {
            line: 145,
            column: 5
          }
        }],
        line: 134
      },
      "6": {
        loc: {
          start: {
            line: 170,
            column: 4
          },
          end: {
            line: 172,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 170,
            column: 4
          },
          end: {
            line: 172,
            column: 5
          }
        }, {
          start: {
            line: 170,
            column: 4
          },
          end: {
            line: 172,
            column: 5
          }
        }],
        line: 170
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0,
      "23": 0,
      "24": 0,
      "25": 0,
      "26": 0,
      "27": 0,
      "28": 0,
      "29": 0,
      "30": 0,
      "31": 0,
      "32": 0,
      "33": 0,
      "34": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0],
      "4": [0, 0],
      "5": [0, 0],
      "6": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "dc0537ab6fd883677a44d9a264477658c0cf8a3d"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_r7p0jshdj = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_r7p0jshdj();

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }












var GameDarkSublayout = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(GameDarkSublayout, _React$Component);

  var _super = _createSuper(GameDarkSublayout);

  function GameDarkSublayout(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, GameDarkSublayout);

    cov_r7p0jshdj().f[0]++;
    cov_r7p0jshdj().s[0]++;
    _this = _super.call(this, props);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_toggleFeedback", (cov_r7p0jshdj().s[16]++, function () {
      cov_r7p0jshdj().f[4]++;
      cov_r7p0jshdj().s[17]++;
      setTimeout(function () {
        cov_r7p0jshdj().f[5]++;
        cov_r7p0jshdj().s[18]++;

        _this.setState({
          feedback: false
        });
      }, 5000);
      cov_r7p0jshdj().s[19]++;

      _this.setState({
        feedback: !_this.state.feedback
      });
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_openOptionsMenu", (cov_r7p0jshdj().s[20]++, function (event) {
      cov_r7p0jshdj().f[6]++;
      cov_r7p0jshdj().s[21]++;

      _this.setState({
        menuAnchorEl: event.currentTarget
      });
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_closeOptionsMenu", (cov_r7p0jshdj().s[22]++, function () {
      cov_r7p0jshdj().f[7]++;
      cov_r7p0jshdj().s[23]++;

      _this.setState({
        menuAnchorEl: null
      });
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_wrapOnClick", (cov_r7p0jshdj().s[24]++, function (onClickFunc) {
      cov_r7p0jshdj().f[8]++;
      cov_r7p0jshdj().s[25]++;
      return function () {
        cov_r7p0jshdj().f[9]++;
        cov_r7p0jshdj().s[26]++;

        // close menu, call onClickFunc
        _this._closeOptionsMenu();

        cov_r7p0jshdj().s[27]++;
        onClickFunc();
      };
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_getOptionsMenuItems", (cov_r7p0jshdj().s[28]++, function () {
      cov_r7p0jshdj().f[10]++;
      cov_r7p0jshdj().s[29]++;

      if (!_this.props.optionsMenuItems) {
        cov_r7p0jshdj().b[6][0]++;
        cov_r7p0jshdj().s[30]++;
        return;
      } else {
        cov_r7p0jshdj().b[6][1]++;
      }

      var _ref = (cov_r7p0jshdj().s[31]++, _this.state),
          menuAnchorEl = _ref.menuAnchorEl;

      var menuItems = (cov_r7p0jshdj().s[32]++, _this.props.optionsMenuItems().map(function (option, index) {
        cov_r7p0jshdj().f[11]++;
        cov_r7p0jshdj().s[33]++;
        return __jsx(_material_ui_core_MenuItem__WEBPACK_IMPORTED_MODULE_14__["default"], {
          key: "option-".concat(index),
          onClick: _this._wrapOnClick(option.onClick)
        }, option.text);
      }));
      cov_r7p0jshdj().s[34]++;
      return __jsx(_material_ui_core_Menu__WEBPACK_IMPORTED_MODULE_13__["default"], {
        id: "simple-menu",
        anchorEl: menuAnchorEl,
        open: Boolean(menuAnchorEl),
        onClose: _this._closeOptionsMenu
      }, menuItems);
    }));

    cov_r7p0jshdj().s[1]++;
    _this.state = {
      feedback: null,
      menuAnchorEl: null,
      prevBgColor: document.body.style.backgroundColor
    };
    cov_r7p0jshdj().s[2]++;
    document.body.style.backgroundColor = 'black';
    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(GameDarkSublayout, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cov_r7p0jshdj().f[1]++;
      cov_r7p0jshdj().s[3]++;
      document.body.style.backgroundColor = this.state.prevBgColor;
    }
  }, {
    key: "render",
    value: function render() {
      cov_r7p0jshdj().f[2]++;
      var isProdChannel = (cov_r7p0jshdj().s[4]++, false);
      var gameName = (cov_r7p0jshdj().s[5]++, games__WEBPACK_IMPORTED_MODULE_16__["GAMES_MAP"][this.props.gameArgs.gameCode].name);
      var fbgTopLeftText;
      cov_r7p0jshdj().s[6]++;

      if (isProdChannel) {
        cov_r7p0jshdj().b[0][0]++;
        cov_r7p0jshdj().s[7]++;

        if (gameName) {
          cov_r7p0jshdj().b[1][0]++;
          cov_r7p0jshdj().s[8]++;
          fbgTopLeftText = __jsx(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_8__["default"], {
            variant: "h6",
            gutterBottom: true,
            style: {
              "float": 'left',
              paddingTop: '9px',
              color: 'white'
            }
          }, gameName);
        } else {
          cov_r7p0jshdj().b[1][1]++;
        }
      } else {
        cov_r7p0jshdj().b[0][1]++;
        cov_r7p0jshdj().s[9]++;
        fbgTopLeftText = __jsx(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_8__["default"], {
          variant: "h6",
          gutterBottom: true,
          style: {
            "float": 'left',
            marginTop: '10px',
            backgroundColor: 'red',
            color: 'white'
          }
        }, "\xA0", gameName, "\xA0");
      }

      var feedbackButtonOrText;
      cov_r7p0jshdj().s[10]++;

      if (this.state.feedback) {
        cov_r7p0jshdj().b[2][0]++;
        cov_r7p0jshdj().s[11]++;
        feedbackButtonOrText = __jsx(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_8__["default"], {
          variant: "h6",
          gutterBottom: true,
          style: {
            "float": 'right',
            paddingTop: '10px',
            color: 'white'
          }
        }, "Desktop View is Experimental.");
      } else {
        cov_r7p0jshdj().b[2][1]++;
        cov_r7p0jshdj().s[12]++;
        feedbackButtonOrText = __jsx(components_DesktopMobileView__WEBPACK_IMPORTED_MODULE_17__["DesktopView"], {
          thresholdWidth: 680
        }, __jsx(_material_ui_core_Button__WEBPACK_IMPORTED_MODULE_11__["default"], {
          onClick: this._toggleFeedback,
          "aria-label": "Desktop View is Experimental.",
          variant: "outlined",
          style: {
            "float": 'right',
            paddingTop: '14px'
          }
        }, __jsx(_material_ui_icons_Feedback__WEBPACK_IMPORTED_MODULE_15___default.a, {
          style: {
            color: 'white'
          }
        })));
      }

      cov_r7p0jshdj().s[13]++;
      return __jsx("div", null, __jsx("div", {
        style: {
          position: 'fixed',
          top: '0',
          width: '100%',
          zIndex: 1
        }
      }, __jsx("div", {
        style: {
          maxWidth: this.props.allowWiderScreen ? (cov_r7p0jshdj().b[3][0]++, '1000px') : (cov_r7p0jshdj().b[3][1]++, '500px'),
          marginLeft: 'auto',
          marginRight: 'auto'
        }
      }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_9___default.a, {
        href: "/"
      }, __jsx("a", {
        style: {
          "float": 'left',
          textDecoration: 'none'
        }
      }, __jsx("img", {
        src: _media_fbg_logo_white_48_png__WEBPACK_IMPORTED_MODULE_10___default.a,
        alt: "FreeBoardGames.org",
        style: {
          "float": 'left',
          paddingRight: '16px'
        }
      }), fbgTopLeftText)), this._getOptionsMenuButton(), this._getOptionsMenuItems(), feedbackButtonOrText)), __jsx("div", {
        style: {
          position: 'fixed',
          width: '100%',
          maxWidth: this.props.allowWiderScreen ? (cov_r7p0jshdj().b[4][0]++, '1000px') : (cov_r7p0jshdj().b[4][1]++, '500px'),
          color: 'white',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)'
        }
      }, this.props.children));
    }
  }, {
    key: "_getOptionsMenuButton",
    value: function _getOptionsMenuButton() {
      cov_r7p0jshdj().f[3]++;
      cov_r7p0jshdj().s[14]++;

      if (this.props.optionsMenuItems) {
        cov_r7p0jshdj().b[5][0]++;
        cov_r7p0jshdj().s[15]++;
        return __jsx(_material_ui_core_Button__WEBPACK_IMPORTED_MODULE_11__["default"], {
          onClick: this._openOptionsMenu,
          "aria-label": "Open options",
          variant: "outlined",
          style: {
            margin: '8px',
            "float": 'right'
          }
        }, __jsx(_material_ui_icons_MoreVert__WEBPACK_IMPORTED_MODULE_12___default.a, {
          style: {
            color: 'white'
          }
        }));
      } else {
        cov_r7p0jshdj().b[5][1]++;
      }
    }
  }]);

  return GameDarkSublayout;
}((react__WEBPACK_IMPORTED_MODULE_7___default.a.Component));

/***/ }),

/***/ "./src/components/App/Game/GameLayout.tsx":
/*!************************************************!*\
  !*** ./src/components/App/Game/GameLayout.tsx ***!
  \************************************************/
/*! exports provided: GameLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameLayout", function() { return GameLayout; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _GameOver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GameOver */ "./src/components/App/Game/GameOver.tsx");
/* harmony import */ var _GameDarkSublayout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GameDarkSublayout */ "./src/components/App/Game/GameDarkSublayout.tsx");





var __jsx = react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement;

function cov_s9mdjdutx() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/components/App/Game/GameLayout.tsx";
  var hash = "065c0c3ca450449a1b4b2075817619bcc2f35a6c";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/components/App/Game/GameLayout.tsx",
    statementMap: {
      "0": {
        start: {
          line: 18,
          column: 4
        },
        end: {
          line: 36,
          column: 5
        }
      },
      "1": {
        start: {
          line: 19,
          column: 6
        },
        end: {
          line: 25,
          column: 8
        }
      },
      "2": {
        start: {
          line: 27,
          column: 6
        },
        end: {
          line: 35,
          column: 8
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 17,
            column: 2
          },
          end: {
            line: 17,
            column: 3
          }
        },
        loc: {
          start: {
            line: 17,
            column: 11
          },
          end: {
            line: 37,
            column: 3
          }
        },
        line: 17
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 18,
            column: 4
          },
          end: {
            line: 36,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 18,
            column: 4
          },
          end: {
            line: 36,
            column: 5
          }
        }, {
          start: {
            line: 18,
            column: 4
          },
          end: {
            line: 36,
            column: 5
          }
        }],
        line: 18
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0
    },
    f: {
      "0": 0
    },
    b: {
      "0": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "065c0c3ca450449a1b4b2075817619bcc2f35a6c"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_s9mdjdutx = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_s9mdjdutx();

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }




var GameLayout = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(GameLayout, _React$Component);

  var _super = _createSuper(GameLayout);

  function GameLayout() {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, GameLayout);

    return _super.apply(this, arguments);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(GameLayout, [{
    key: "render",
    value: function render() {
      cov_s9mdjdutx().f[0]++;
      cov_s9mdjdutx().s[0]++;

      if (this.props.gameOver) {
        cov_s9mdjdutx().b[0][0]++;
        cov_s9mdjdutx().s[1]++;
        return __jsx(_GameOver__WEBPACK_IMPORTED_MODULE_6__["GameOver"], {
          result: this.props.gameOver,
          gameArgs: this.props.gameArgs,
          extraCardContent: this.props.extraCardContent
        });
      } else {
        cov_s9mdjdutx().b[0][1]++;
        cov_s9mdjdutx().s[2]++;
        return __jsx(_GameDarkSublayout__WEBPACK_IMPORTED_MODULE_7__["GameDarkSublayout"], {
          optionsMenuItems: this.props.optionsMenuItems,
          allowWiderScreen: this.props.allowWiderScreen,
          gameArgs: this.props.gameArgs
        }, this.props.children);
      }
    }
  }]);

  return GameLayout;
}((react__WEBPACK_IMPORTED_MODULE_5___default.a.Component));

/***/ }),

/***/ "./src/components/App/Game/GameOver.tsx":
/*!**********************************************!*\
  !*** ./src/components/App/Game/GameOver.tsx ***!
  \**********************************************/
/*! exports provided: GameOver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameOver", function() { return GameOver; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _GameModePicker__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./GameModePicker */ "./src/components/App/Game/GameModePicker.tsx");
/* harmony import */ var _GamesList__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../GamesList */ "./src/components/App/GamesList.tsx");
/* harmony import */ var _FreeBoardGamesBar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../FreeBoardGamesBar */ "./src/components/App/FreeBoardGamesBar.tsx");
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @material-ui/core/Typography */ "./node_modules/@material-ui/core/esm/Typography/index.js");
/* harmony import */ var _material_ui_core_Button__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @material-ui/core/Button */ "./node_modules/@material-ui/core/esm/Button/index.js");
/* harmony import */ var _material_ui_icons_Replay__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @material-ui/icons/Replay */ "./node_modules/@material-ui/icons/Replay.js");
/* harmony import */ var _material_ui_icons_Replay__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Replay__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var react_ga__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! react-ga */ "./node_modules/react-ga/dist/esm/index.js");
/* harmony import */ var _MessagePage__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../MessagePage */ "./src/components/App/MessagePage.tsx");
/* harmony import */ var _Lobby_LobbyService__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../Lobby/LobbyService */ "./src/components/App/Lobby/LobbyService.ts");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_18__);








var __jsx = react__WEBPACK_IMPORTED_MODULE_8___default.a.createElement;

function cov_17lf02dutf() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/components/App/Game/GameOver.tsx";
  var hash = "557fa5317d84991a365db8ca70b9fd8efabba6e4";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/components/App/Game/GameOver.tsx",
    statementMap: {
      "0": {
        start: {
          line: 25,
          column: 10
        },
        end: {
          line: 25,
          column: 28
        }
      },
      "1": {
        start: {
          line: 27,
          column: 4
        },
        end: {
          line: 30,
          column: 5
        }
      },
      "2": {
        start: {
          line: 28,
          column: 19
        },
        end: {
          line: 28,
          column: 58
        }
      },
      "3": {
        start: {
          line: 29,
          column: 6
        },
        end: {
          line: 29,
          column: 22
        }
      },
      "4": {
        start: {
          line: 32,
          column: 29
        },
        end: {
          line: 32,
          column: 56
        }
      },
      "5": {
        start: {
          line: 33,
          column: 4
        },
        end: {
          line: 46,
          column: 5
        }
      },
      "6": {
        start: {
          line: 34,
          column: 6
        },
        end: {
          line: 45,
          column: 8
        }
      },
      "7": {
        start: {
          line: 47,
          column: 4
        },
        end: {
          line: 51,
          column: 7
        }
      },
      "8": {
        start: {
          line: 52,
          column: 4
        },
        end: {
          line: 61,
          column: 6
        }
      },
      "9": {
        start: {
          line: 63,
          column: 25
        },
        end: {
          line: 71,
          column: 3
        }
      },
      "10": {
        start: {
          line: 64,
          column: 4
        },
        end: {
          line: 66,
          column: 5
        }
      },
      "11": {
        start: {
          line: 65,
          column: 6
        },
        end: {
          line: 65,
          column: 18
        }
      },
      "12": {
        start: {
          line: 68,
          column: 6
        },
        end: {
          line: 68,
          column: 115
        }
      },
      "13": {
        start: {
          line: 70,
          column: 4
        },
        end: {
          line: 70,
          column: 27
        }
      },
      "14": {
        start: {
          line: 73,
          column: 21
        },
        end: {
          line: 88,
          column: 3
        }
      },
      "15": {
        start: {
          line: 74,
          column: 17
        },
        end: {
          line: 74,
          column: 36
        }
      },
      "16": {
        start: {
          line: 75,
          column: 4
        },
        end: {
          line: 79,
          column: 7
        }
      },
      "17": {
        start: {
          line: 81,
          column: 4
        },
        end: {
          line: 87,
          column: 5
        }
      },
      "18": {
        start: {
          line: 82,
          column: 6
        },
        end: {
          line: 82,
          column: 44
        }
      },
      "19": {
        start: {
          line: 84,
          column: 6
        },
        end: {
          line: 84,
          column: 39
        }
      },
      "20": {
        start: {
          line: 85,
          column: 25
        },
        end: {
          line: 85,
          column: 116
        }
      },
      "21": {
        start: {
          line: 86,
          column: 6
        },
        end: {
          line: 86,
          column: 65
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 26,
            column: 2
          },
          end: {
            line: 26,
            column: 3
          }
        },
        loc: {
          start: {
            line: 26,
            column: 11
          },
          end: {
            line: 62,
            column: 3
          }
        },
        line: 26
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 63,
            column: 25
          },
          end: {
            line: 63,
            column: 26
          }
        },
        loc: {
          start: {
            line: 63,
            column: 31
          },
          end: {
            line: 71,
            column: 3
          }
        },
        line: 63
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 73,
            column: 21
          },
          end: {
            line: 73,
            column: 22
          }
        },
        loc: {
          start: {
            line: 73,
            column: 33
          },
          end: {
            line: 88,
            column: 3
          }
        },
        line: 73
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 27,
            column: 4
          },
          end: {
            line: 30,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 27,
            column: 4
          },
          end: {
            line: 30,
            column: 5
          }
        }, {
          start: {
            line: 27,
            column: 4
          },
          end: {
            line: 30,
            column: 5
          }
        }],
        line: 27
      },
      "1": {
        loc: {
          start: {
            line: 33,
            column: 4
          },
          end: {
            line: 46,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 33,
            column: 4
          },
          end: {
            line: 46,
            column: 5
          }
        }, {
          start: {
            line: 33,
            column: 4
          },
          end: {
            line: 46,
            column: 5
          }
        }],
        line: 33
      },
      "2": {
        loc: {
          start: {
            line: 64,
            column: 4
          },
          end: {
            line: 66,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 64,
            column: 4
          },
          end: {
            line: 66,
            column: 5
          }
        }, {
          start: {
            line: 64,
            column: 4
          },
          end: {
            line: 66,
            column: 5
          }
        }],
        line: 64
      },
      "3": {
        loc: {
          start: {
            line: 81,
            column: 4
          },
          end: {
            line: 87,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 81,
            column: 4
          },
          end: {
            line: 87,
            column: 5
          }
        }, {
          start: {
            line: 81,
            column: 4
          },
          end: {
            line: 87,
            column: 5
          }
        }],
        line: 81
      },
      "4": {
        loc: {
          start: {
            line: 81,
            column: 8
          },
          end: {
            line: 81,
            column: 71
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 81,
            column: 8
          },
          end: {
            line: 81,
            column: 33
          }
        }, {
          start: {
            line: 81,
            column: 37
          },
          end: {
            line: 81,
            column: 71
          }
        }],
        line: 81
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0],
      "4": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "557fa5317d84991a365db8ca70b9fd8efabba6e4"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_17lf02dutf = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_17lf02dutf();

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }












var GameOver = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(GameOver, _React$Component);

  var _super = _createSuper(GameOver);

  function GameOver() {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, GameOver);

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(_args));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__["default"])(_this), "state", (cov_17lf02dutf().s[0]++, {
      loading: false
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__["default"])(_this), "_getExtraCardContent", (cov_17lf02dutf().s[9]++, function () {
      cov_17lf02dutf().f[1]++;
      cov_17lf02dutf().s[10]++;

      if (!_this.props.extraCardContent) {
        cov_17lf02dutf().b[2][0]++;
        cov_17lf02dutf().s[11]++;
        return null;
      } else {
        cov_17lf02dutf().b[2][1]++;
      }

      var otherPlayerCard = (cov_17lf02dutf().s[12]++, __jsx("div", {
        style: {
          paddingBottom: '12px',
          maxWidth: '500px',
          margin: 'auto'
        }
      }, _this.props.extraCardContent));
      cov_17lf02dutf().s[13]++;
      return otherPlayerCard;
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__["default"])(_this), "_playAgainHandle", (cov_17lf02dutf().s[14]++, function _callee() {
      var args, nextRoomId;
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.async(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              cov_17lf02dutf().f[2]++;
              args = (cov_17lf02dutf().s[15]++, _this.props.gameArgs);
              cov_17lf02dutf().s[16]++;
              react_ga__WEBPACK_IMPORTED_MODULE_15__["default"].event({
                category: 'GameOver',
                action: 'Clicked play again',
                label: args.gameCode
              });
              cov_17lf02dutf().s[17]++;

              if (!((cov_17lf02dutf().b[4][0]++, args.mode === _GameModePicker__WEBPACK_IMPORTED_MODULE_9__["GameMode"].AI) || (cov_17lf02dutf().b[4][1]++, args.mode === _GameModePicker__WEBPACK_IMPORTED_MODULE_9__["GameMode"].LocalFriend))) {
                _context.next = 11;
                break;
              }

              cov_17lf02dutf().b[3][0]++;
              cov_17lf02dutf().s[18]++;
              next_router__WEBPACK_IMPORTED_MODULE_18___default.a.push(window.location.pathname);
              _context.next = 20;
              break;

            case 11:
              cov_17lf02dutf().b[3][1]++;
              cov_17lf02dutf().s[19]++;

              _this.setState({
                loading: true
              });

              cov_17lf02dutf().s[20]++;
              _context.next = 17;
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.awrap(_Lobby_LobbyService__WEBPACK_IMPORTED_MODULE_17__["LobbyService"].getPlayAgainNextRoom(args.gameCode, args.matchCode, args.players.length));

            case 17:
              nextRoomId = _context.sent;
              cov_17lf02dutf().s[21]++;
              next_router__WEBPACK_IMPORTED_MODULE_18___default.a.push("/room/".concat(args.gameCode, "/").concat(nextRoomId));

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, null, null, null, Promise);
    }));

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(GameOver, [{
    key: "render",
    value: function render() {
      cov_17lf02dutf().f[0]++;
      cov_17lf02dutf().s[1]++;

      if (this.state.loading) {
        cov_17lf02dutf().b[0][0]++;
        var Page = (cov_17lf02dutf().s[2]++, Object(_MessagePage__WEBPACK_IMPORTED_MODULE_16__["default"])('loading', 'Loading...'));
        cov_17lf02dutf().s[3]++;
        return __jsx(Page, null);
      } else {
        cov_17lf02dutf().b[0][1]++;
      }

      var playAgain;
      var extraCardContent = (cov_17lf02dutf().s[4]++, this._getExtraCardContent());
      cov_17lf02dutf().s[5]++;

      if (this.props.gameArgs) {
        cov_17lf02dutf().b[1][0]++;
        cov_17lf02dutf().s[6]++;
        playAgain = __jsx("div", {
          style: {
            textAlign: 'center'
          }
        }, __jsx(_material_ui_core_Button__WEBPACK_IMPORTED_MODULE_13__["default"], {
          onClick: this._playAgainHandle,
          variant: "outlined",
          style: {
            marginRight: 'auto',
            marginLeft: 'auto',
            marginBottom: '24px'
          }
        }, __jsx(_material_ui_icons_Replay__WEBPACK_IMPORTED_MODULE_14___default.a, {
          style: {
            marginRight: '8px'
          }
        }), "Play Again"));
      } else {
        cov_17lf02dutf().b[1][1]++;
      }

      cov_17lf02dutf().s[7]++;
      react_ga__WEBPACK_IMPORTED_MODULE_15__["default"].event({
        category: 'Game',
        label: this.props.gameArgs.gameCode,
        action: 'Game over'
      });
      cov_17lf02dutf().s[8]++;
      return __jsx(_FreeBoardGamesBar__WEBPACK_IMPORTED_MODULE_11__["default"], {
        FEATURE_FLAG_readyForDesktopView: true
      }, __jsx(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_12__["default"], {
        variant: "h6",
        gutterBottom: true,
        align: "center",
        style: {
          marginTop: '16px'
        }
      }, "Game Over, ", this.props.result, "!"), playAgain, extraCardContent, __jsx(_GamesList__WEBPACK_IMPORTED_MODULE_10__["GamesList"], null));
    }
  }]);

  return GameOver;
}((react__WEBPACK_IMPORTED_MODULE_8___default.a.Component));

/***/ }),

/***/ "./src/components/App/GamesList.tsx":
/*!******************************************!*\
  !*** ./src/components/App/GamesList.tsx ***!
  \******************************************/
/*! exports provided: GamesList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GamesList", function() { return GamesList; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var games__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! games */ "./src/games/index.ts");
/* harmony import */ var _Game_GameCard__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Game/GameCard */ "./src/components/App/Game/GameCard.tsx");
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @material-ui/core/Typography */ "./node_modules/@material-ui/core/esm/Typography/index.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_9__);





var __jsx = react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement;

function cov_gqg19tpc3() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/components/App/GamesList.tsx";
  var hash = "d8225ab27af96b136cd0e547bab6686df7f20c72";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/components/App/GamesList.tsx",
    statementMap: {
      "0": {
        start: {
          line: 9,
          column: 22
        },
        end: {
          line: 15,
          column: 6
        }
      },
      "1": {
        start: {
          line: 10,
          column: 6
        },
        end: {
          line: 14,
          column: 13
        }
      },
      "2": {
        start: {
          line: 16,
          column: 4
        },
        end: {
          line: 23,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 8,
            column: 2
          },
          end: {
            line: 8,
            column: 3
          }
        },
        loc: {
          start: {
            line: 8,
            column: 18
          },
          end: {
            line: 24,
            column: 3
          }
        },
        line: 8
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 9,
            column: 37
          },
          end: {
            line: 9,
            column: 38
          }
        },
        loc: {
          start: {
            line: 10,
            column: 6
          },
          end: {
            line: 14,
            column: 13
          }
        },
        line: 10
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0,
      "2": 0
    },
    f: {
      "0": 0,
      "1": 0
    },
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "d8225ab27af96b136cd0e547bab6686df7f20c72"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_gqg19tpc3 = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_gqg19tpc3();

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }






var GamesList = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(GamesList, _React$Component);

  var _super = _createSuper(GamesList);

  function GamesList() {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, GamesList);

    return _super.apply(this, arguments);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(GamesList, [{
    key: "render",
    value: function render() {
      cov_gqg19tpc3().f[0]++;
      var gamesList = (cov_gqg19tpc3().s[0]++, games__WEBPACK_IMPORTED_MODULE_6__["GAMES_LIST"].map(function (game) {
        cov_gqg19tpc3().f[1]++;
        cov_gqg19tpc3().s[1]++;
        return __jsx(next_link__WEBPACK_IMPORTED_MODULE_9___default.a, {
          href: "/play/[gameCode]",
          as: "/play/".concat(game.code),
          key: game.code
        }, __jsx("a", {
          style: {
            textDecoration: 'none',
            flex: 1,
            minWidth: '300px',
            maxWidth: '380px',
            margin: '8px'
          }
        }, __jsx(_Game_GameCard__WEBPACK_IMPORTED_MODULE_7__["GameCard"], {
          game: game,
          isLink: true
        })));
      }));
      cov_gqg19tpc3().s[2]++;
      return __jsx("div", {
        style: {
          marginBottom: '16px'
        }
      }, __jsx(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_8__["default"], {
        component: "h2",
        variant: "h6",
        style: {
          marginBottom: '16px',
          marginLeft: '6px'
        }
      }, "Games"), __jsx("div", {
        style: {
          margin: '0 4px',
          display: 'flex',
          flexWrap: 'wrap'
        }
      }, gamesList));
    }
  }]);

  return GamesList;
}((react__WEBPACK_IMPORTED_MODULE_5___default.a.Component));

/***/ }),

/***/ "./src/components/App/MessagePage.tsx":
/*!********************************************!*\
  !*** ./src/components/App/MessagePage.tsx ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _MessagePageClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MessagePageClass */ "./src/components/App/MessagePageClass.tsx");
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_1pdcu8e572() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/components/App/MessagePage.tsx";
  var hash = "85d261dfe45136253ee1519c39345121c5c964bb";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/components/App/MessagePage.tsx",
    statementMap: {
      "0": {
        start: {
          line: 4,
          column: 23
        },
        end: {
          line: 8,
          column: 1
        }
      },
      "1": {
        start: {
          line: 5,
          column: 2
        },
        end: {
          line: 7,
          column: 4
        }
      },
      "2": {
        start: {
          line: 6,
          column: 4
        },
        end: {
          line: 6,
          column: 62
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 4,
            column: 23
          },
          end: {
            line: 4,
            column: 24
          }
        },
        loc: {
          start: {
            line: 4,
            column: 71
          },
          end: {
            line: 8,
            column: 1
          }
        },
        line: 4
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 5,
            column: 9
          },
          end: {
            line: 5,
            column: 10
          }
        },
        loc: {
          start: {
            line: 5,
            column: 15
          },
          end: {
            line: 7,
            column: 3
          }
        },
        line: 5
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0,
      "2": 0
    },
    f: {
      "0": 0,
      "1": 0
    },
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "85d261dfe45136253ee1519c39345121c5c964bb"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_1pdcu8e572 = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_1pdcu8e572();


cov_1pdcu8e572().s[0]++;

var getMessagePage = function getMessagePage(type, message) {
  cov_1pdcu8e572().f[0]++;
  cov_1pdcu8e572().s[1]++;
  return function () {
    cov_1pdcu8e572().f[1]++;
    cov_1pdcu8e572().s[2]++;
    return __jsx(_MessagePageClass__WEBPACK_IMPORTED_MODULE_1__["default"], {
      type: type,
      message: message
    });
  };
};

/* harmony default export */ __webpack_exports__["default"] = (getMessagePage);

/***/ }),

/***/ "./src/components/App/MessagePageClass.tsx":
/*!*************************************************!*\
  !*** ./src/components/App/MessagePageClass.tsx ***!
  \*************************************************/
/*! exports provided: MessagePage, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessagePage", function() { return MessagePage; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _material_ui_core_Button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @material-ui/core/Button */ "./node_modules/@material-ui/core/esm/Button/index.js");
/* harmony import */ var _material_ui_icons_Home__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @material-ui/icons/Home */ "./node_modules/@material-ui/icons/Home.js");
/* harmony import */ var _material_ui_icons_Home__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_Home__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _material_ui_core_CircularProgress__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @material-ui/core/CircularProgress */ "./node_modules/@material-ui/core/esm/CircularProgress/index.js");
/* harmony import */ var _FreeBoardGamesBar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./FreeBoardGamesBar */ "./src/components/App/FreeBoardGamesBar.tsx");
/* harmony import */ var _media_SvgError__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./media/SvgError */ "./src/components/App/media/SvgError.tsx");
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @material-ui/core/Typography */ "./node_modules/@material-ui/core/esm/Typography/index.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_14__);







var __jsx = react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement;

function cov_1y46eufq54() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/components/App/MessagePageClass.tsx";
  var hash = "8e571e562b46c16beb7ae6d0cedc91229204127d";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/components/App/MessagePageClass.tsx",
    statementMap: {
      "0": {
        start: {
          line: 22,
          column: 22
        },
        end: {
          line: 22,
          column: 26
        }
      },
      "1": {
        start: {
          line: 24,
          column: 4
        },
        end: {
          line: 24,
          column: 17
        }
      },
      "2": {
        start: {
          line: 25,
          column: 4
        },
        end: {
          line: 28,
          column: 6
        }
      },
      "3": {
        start: {
          line: 29,
          column: 4
        },
        end: {
          line: 31,
          column: 5
        }
      },
      "4": {
        start: {
          line: 30,
          column: 6
        },
        end: {
          line: 30,
          column: 79
        }
      },
      "5": {
        start: {
          line: 34,
          column: 13
        },
        end: {
          line: 46,
          column: 3
        }
      },
      "6": {
        start: {
          line: 34,
          column: 30
        },
        end: {
          line: 46,
          column: 3
        }
      },
      "7": {
        start: {
          line: 35,
          column: 4
        },
        end: {
          line: 45,
          column: 5
        }
      },
      "8": {
        start: {
          line: 36,
          column: 22
        },
        end: {
          line: 36,
          column: 48
        }
      },
      "9": {
        start: {
          line: 37,
          column: 25
        },
        end: {
          line: 37,
          column: 39
        }
      },
      "10": {
        start: {
          line: 38,
          column: 6
        },
        end: {
          line: 41,
          column: 9
        }
      },
      "11": {
        start: {
          line: 42,
          column: 6
        },
        end: {
          line: 44,
          column: 7
        }
      },
      "12": {
        start: {
          line: 43,
          column: 8
        },
        end: {
          line: 43,
          column: 81
        }
      },
      "13": {
        start: {
          line: 49,
          column: 4
        },
        end: {
          line: 52,
          column: 5
        }
      },
      "14": {
        start: {
          line: 50,
          column: 6
        },
        end: {
          line: 50,
          column: 50
        }
      },
      "15": {
        start: {
          line: 51,
          column: 6
        },
        end: {
          line: 51,
          column: 28
        }
      },
      "16": {
        start: {
          line: 58,
          column: 4
        },
        end: {
          line: 62,
          column: 5
        }
      },
      "17": {
        start: {
          line: 59,
          column: 6
        },
        end: {
          line: 59,
          column: 54
        }
      },
      "18": {
        start: {
          line: 61,
          column: 6
        },
        end: {
          line: 61,
          column: 34
        }
      },
      "19": {
        start: {
          line: 63,
          column: 4
        },
        end: {
          line: 75,
          column: 5
        }
      },
      "20": {
        start: {
          line: 64,
          column: 25
        },
        end: {
          line: 64,
          column: 34
        }
      },
      "21": {
        start: {
          line: 65,
          column: 6
        },
        end: {
          line: 74,
          column: 8
        }
      },
      "22": {
        start: {
          line: 76,
          column: 4
        },
        end: {
          line: 89,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 23,
            column: 2
          },
          end: {
            line: 23,
            column: 3
          }
        },
        loc: {
          start: {
            line: 23,
            column: 36
          },
          end: {
            line: 32,
            column: 3
          }
        },
        line: 23
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 34,
            column: 13
          },
          end: {
            line: 34,
            column: 14
          }
        },
        loc: {
          start: {
            line: 34,
            column: 30
          },
          end: {
            line: 46,
            column: 3
          }
        },
        line: 34
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 34,
            column: 30
          },
          end: {
            line: 34,
            column: 31
          }
        },
        loc: {
          start: {
            line: 34,
            column: 36
          },
          end: {
            line: 46,
            column: 3
          }
        },
        line: 34
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 48,
            column: 2
          },
          end: {
            line: 48,
            column: 3
          }
        },
        loc: {
          start: {
            line: 48,
            column: 25
          },
          end: {
            line: 53,
            column: 3
          }
        },
        line: 48
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 55,
            column: 2
          },
          end: {
            line: 55,
            column: 3
          }
        },
        loc: {
          start: {
            line: 55,
            column: 11
          },
          end: {
            line: 90,
            column: 3
          }
        },
        line: 55
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 29,
            column: 4
          },
          end: {
            line: 31,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 29,
            column: 4
          },
          end: {
            line: 31,
            column: 5
          }
        }, {
          start: {
            line: 29,
            column: 4
          },
          end: {
            line: 31,
            column: 5
          }
        }],
        line: 29
      },
      "1": {
        loc: {
          start: {
            line: 29,
            column: 8
          },
          end: {
            line: 29,
            column: 63
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 29,
            column: 8
          },
          end: {
            line: 29,
            column: 37
          }
        }, {
          start: {
            line: 29,
            column: 41
          },
          end: {
            line: 29,
            column: 63
          }
        }],
        line: 29
      },
      "2": {
        loc: {
          start: {
            line: 35,
            column: 4
          },
          end: {
            line: 45,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 35,
            column: 4
          },
          end: {
            line: 45,
            column: 5
          }
        }, {
          start: {
            line: 35,
            column: 4
          },
          end: {
            line: 45,
            column: 5
          }
        }],
        line: 35
      },
      "3": {
        loc: {
          start: {
            line: 42,
            column: 6
          },
          end: {
            line: 44,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 42,
            column: 6
          },
          end: {
            line: 44,
            column: 7
          }
        }, {
          start: {
            line: 42,
            column: 6
          },
          end: {
            line: 44,
            column: 7
          }
        }],
        line: 42
      },
      "4": {
        loc: {
          start: {
            line: 49,
            column: 4
          },
          end: {
            line: 52,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 49,
            column: 4
          },
          end: {
            line: 52,
            column: 5
          }
        }, {
          start: {
            line: 49,
            column: 4
          },
          end: {
            line: 52,
            column: 5
          }
        }],
        line: 49
      },
      "5": {
        loc: {
          start: {
            line: 58,
            column: 4
          },
          end: {
            line: 62,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 58,
            column: 4
          },
          end: {
            line: 62,
            column: 5
          }
        }, {
          start: {
            line: 58,
            column: 4
          },
          end: {
            line: 62,
            column: 5
          }
        }],
        line: 58
      },
      "6": {
        loc: {
          start: {
            line: 63,
            column: 4
          },
          end: {
            line: 75,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 63,
            column: 4
          },
          end: {
            line: 75,
            column: 5
          }
        }, {
          start: {
            line: 63,
            column: 4
          },
          end: {
            line: 75,
            column: 5
          }
        }],
        line: 63
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0],
      "4": [0, 0],
      "5": [0, 0],
      "6": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "8e571e562b46c16beb7ae6d0cedc91229204127d"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_1y46eufq54 = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_1y46eufq54();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }









var MessagePage = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(MessagePage, _React$Component);

  var _super = _createSuper(MessagePage);

  function MessagePage(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, MessagePage);

    cov_1y46eufq54().f[0]++;
    cov_1y46eufq54().s[1]++;
    _this = _super.call(this, props);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "requestID", (cov_1y46eufq54().s[0]++, null));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_animate", (cov_1y46eufq54().s[5]++, function (now) {
      cov_1y46eufq54().f[1]++;
      cov_1y46eufq54().s[6]++;
      return function () {
        cov_1y46eufq54().f[2]++;
        cov_1y46eufq54().s[7]++;

        if (_this.requestID) {
          cov_1y46eufq54().b[2][0]++;
          var elapsed = (cov_1y46eufq54().s[8]++, now - _this.state.startTime);
          var linkHidden = (cov_1y46eufq54().s[9]++, elapsed < 5000);
          cov_1y46eufq54().s[10]++;

          _this.setState(_objectSpread({}, _this.state, {
            linkHidden: linkHidden
          }));

          cov_1y46eufq54().s[11]++;

          if (linkHidden) {
            cov_1y46eufq54().b[3][0]++;
            cov_1y46eufq54().s[12]++;
            _this.requestID = window.requestAnimationFrame(_this._animate(Date.now()));
          } else {
            cov_1y46eufq54().b[3][1]++;
          }
        } else {
          cov_1y46eufq54().b[2][1]++;
        }
      };
    }));

    cov_1y46eufq54().s[2]++;
    _this.state = {
      linkHidden: props.type !== 'error',
      startTime: Date.now()
    };
    cov_1y46eufq54().s[3]++;

    if ((cov_1y46eufq54().b[1][0]++, true) && (cov_1y46eufq54().b[1][1]++, props.type !== 'error')) {
      cov_1y46eufq54().b[0][0]++;
      cov_1y46eufq54().s[4]++;
      _this.requestID = window.requestAnimationFrame(_this._animate(Date.now()));
    } else {
      cov_1y46eufq54().b[0][1]++;
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(MessagePage, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cov_1y46eufq54().f[3]++;
      cov_1y46eufq54().s[13]++;

      if (this.requestID) {
        cov_1y46eufq54().b[4][0]++;
        cov_1y46eufq54().s[14]++;
        window.cancelAnimationFrame(this.requestID);
        cov_1y46eufq54().s[15]++;
        this.requestID = null;
      } else {
        cov_1y46eufq54().b[4][1]++;
      }
    }
  }, {
    key: "render",
    value: function render() {
      cov_1y46eufq54().f[4]++;
      var icon;
      var linkHome;
      cov_1y46eufq54().s[16]++;

      if (this.props.type === 'error') {
        cov_1y46eufq54().b[5][0]++;
        cov_1y46eufq54().s[17]++;
        icon = __jsx(_media_SvgError__WEBPACK_IMPORTED_MODULE_12__["default"], {
          style: {
            height: '128px'
          }
        });
      } else {
        cov_1y46eufq54().b[5][1]++;
        cov_1y46eufq54().s[18]++;
        icon = __jsx(_material_ui_core_CircularProgress__WEBPACK_IMPORTED_MODULE_10__["default"], null);
      }

      cov_1y46eufq54().s[19]++;

      if (!this.state.linkHidden) {
        cov_1y46eufq54().b[6][0]++;
        var goHomeText = (cov_1y46eufq54().s[20]++, 'Go Home');
        cov_1y46eufq54().s[21]++;
        linkHome = __jsx(next_link__WEBPACK_IMPORTED_MODULE_14___default.a, {
          href: "/"
        }, __jsx("a", {
          style: {
            textDecoration: 'none'
          }
        }, __jsx(_material_ui_core_Button__WEBPACK_IMPORTED_MODULE_8__["default"], {
          variant: "outlined",
          style: {
            margin: '8px'
          }
        }, __jsx(_material_ui_icons_Home__WEBPACK_IMPORTED_MODULE_9___default.a, {
          style: {
            marginRight: '8px'
          }
        }), goHomeText)));
      } else {
        cov_1y46eufq54().b[6][1]++;
      }

      cov_1y46eufq54().s[22]++;
      return __jsx(_FreeBoardGamesBar__WEBPACK_IMPORTED_MODULE_11__["default"], null, __jsx("div", {
        style: {
          paddingTop: '16px',
          textAlign: 'center'
        }
      }, icon, __jsx(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_13__["default"], {
        variant: "h6",
        gutterBottom: true,
        style: {
          paddingTop: '16px'
        }
      }, this.props.message, __jsx("br", null), __jsx("br", null), linkHome, this.props.actionComponent)));
    }
  }]);

  return MessagePage;
}((react__WEBPACK_IMPORTED_MODULE_7___default.a.Component));
/* harmony default export */ __webpack_exports__["default"] = (MessagePage);

/***/ }),

/***/ "./src/components/App/media/SvgError.tsx":
/*!***********************************************!*\
  !*** ./src/components/App/media/SvgError.tsx ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_12fnlg8tgm() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/components/App/media/SvgError.tsx";
  var hash = "a583da3972de338c0a9ff67f967832e75c2fac12";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/components/App/media/SvgError.tsx",
    statementMap: {
      "0": {
        start: {
          line: 2,
          column: 17
        },
        end: {
          line: 9,
          column: 1
        }
      },
      "1": {
        start: {
          line: 3,
          column: 2
        },
        end: {
          line: 8,
          column: 8
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 2,
            column: 17
          },
          end: {
            line: 2,
            column: 18
          }
        },
        loc: {
          start: {
            line: 3,
            column: 2
          },
          end: {
            line: 8,
            column: 8
          }
        },
        line: 3
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0
    },
    f: {
      "0": 0
    },
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "a583da3972de338c0a9ff67f967832e75c2fac12"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_12fnlg8tgm = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_12fnlg8tgm();

cov_12fnlg8tgm().s[0]++;

var SvgError = function SvgError(props) {
  cov_12fnlg8tgm().f[0]++;
  cov_12fnlg8tgm().s[1]++;
  return __jsx("svg", {
    viewBox: "0 0 1 1",
    style: props.style
  }, __jsx("g", null, __jsx("line", {
    x1: "0.2",
    y1: "0.2",
    x2: "0.8",
    y2: "0.8",
    stroke: "black",
    strokeWidth: "0.05"
  }), __jsx("line", {
    x1: "0.8",
    y1: "0.2",
    x2: "0.2",
    y2: "0.8",
    stroke: "black",
    strokeWidth: "0.05"
  })));
};

/* harmony default export */ __webpack_exports__["default"] = (SvgError);

/***/ }),

/***/ "./src/components/DesktopMobileView.tsx":
/*!**********************************************!*\
  !*** ./src/components/DesktopMobileView.tsx ***!
  \**********************************************/
/*! exports provided: DesktopView, MobileView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DesktopView", function() { return DesktopView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MobileView", function() { return MobileView; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var hooks_useWindowDimensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hooks/useWindowDimensions */ "./src/hooks/useWindowDimensions.ts");
/* harmony import */ var mobile_detect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mobile-detect */ "./node_modules/mobile-detect/mobile-detect.js");
/* harmony import */ var mobile_detect__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mobile_detect__WEBPACK_IMPORTED_MODULE_2__);
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_1jre50uwcf() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/components/DesktopMobileView.tsx";
  var hash = "0f0b32a919beacee3d27852a9b0e92630e49b411";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/components/DesktopMobileView.tsx",
    statementMap: {
      "0": {
        start: {
          line: 11,
          column: 32
        },
        end: {
          line: 11,
          column: 35
        }
      },
      "1": {
        start: {
          line: 14,
          column: 26
        },
        end: {
          line: 14,
          column: 106
        }
      },
      "2": {
        start: {
          line: 15,
          column: 14
        },
        end: {
          line: 15,
          column: 41
        }
      },
      "3": {
        start: {
          line: 16,
          column: 20
        },
        end: {
          line: 16,
          column: 49
        }
      },
      "4": {
        start: {
          line: 18,
          column: 2
        },
        end: {
          line: 25,
          column: 3
        }
      },
      "5": {
        start: {
          line: 20,
          column: 15
        },
        end: {
          line: 20,
          column: 48
        }
      },
      "6": {
        start: {
          line: 21,
          column: 4
        },
        end: {
          line: 21,
          column: 51
        }
      },
      "7": {
        start: {
          line: 23,
          column: 27
        },
        end: {
          line: 23,
          column: 74
        }
      },
      "8": {
        start: {
          line: 24,
          column: 4
        },
        end: {
          line: 24,
          column: 45
        }
      },
      "9": {
        start: {
          line: 26,
          column: 2
        },
        end: {
          line: 26,
          column: 24
        }
      },
      "10": {
        start: {
          line: 29,
          column: 27
        },
        end: {
          line: 35,
          column: 1
        }
      },
      "11": {
        start: {
          line: 30,
          column: 2
        },
        end: {
          line: 34,
          column: 3
        }
      },
      "12": {
        start: {
          line: 31,
          column: 4
        },
        end: {
          line: 31,
          column: 61
        }
      },
      "13": {
        start: {
          line: 33,
          column: 4
        },
        end: {
          line: 33,
          column: 16
        }
      },
      "14": {
        start: {
          line: 37,
          column: 26
        },
        end: {
          line: 43,
          column: 1
        }
      },
      "15": {
        start: {
          line: 38,
          column: 2
        },
        end: {
          line: 42,
          column: 3
        }
      },
      "16": {
        start: {
          line: 39,
          column: 4
        },
        end: {
          line: 39,
          column: 61
        }
      },
      "17": {
        start: {
          line: 41,
          column: 4
        },
        end: {
          line: 41,
          column: 16
        }
      }
    },
    fnMap: {
      "0": {
        name: "isMobile",
        decl: {
          start: {
            line: 13,
            column: 9
          },
          end: {
            line: 13,
            column: 17
          }
        },
        loc: {
          start: {
            line: 13,
            column: 49
          },
          end: {
            line: 27,
            column: 1
          }
        },
        line: 13
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 29,
            column: 27
          },
          end: {
            line: 29,
            column: 28
          }
        },
        loc: {
          start: {
            line: 29,
            column: 62
          },
          end: {
            line: 35,
            column: 1
          }
        },
        line: 29
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 37,
            column: 26
          },
          end: {
            line: 37,
            column: 27
          }
        },
        loc: {
          start: {
            line: 37,
            column: 61
          },
          end: {
            line: 43,
            column: 1
          }
        },
        line: 37
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 14,
            column: 26
          },
          end: {
            line: 14,
            column: 106
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 14,
            column: 26
          },
          end: {
            line: 14,
            column: 57
          }
        }, {
          start: {
            line: 14,
            column: 61
          },
          end: {
            line: 14,
            column: 106
          }
        }],
        line: 14
      },
      "1": {
        loc: {
          start: {
            line: 18,
            column: 2
          },
          end: {
            line: 25,
            column: 3
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 18,
            column: 2
          },
          end: {
            line: 25,
            column: 3
          }
        }, {
          start: {
            line: 18,
            column: 2
          },
          end: {
            line: 25,
            column: 3
          }
        }],
        line: 18
      },
      "2": {
        loc: {
          start: {
            line: 18,
            column: 6
          },
          end: {
            line: 18,
            column: 56
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 18,
            column: 7
          },
          end: {
            line: 18,
            column: 17
          }
        }, {
          start: {
            line: 18,
            column: 21
          },
          end: {
            line: 18,
            column: 36
          }
        }, {
          start: {
            line: 18,
            column: 41
          },
          end: {
            line: 18,
            column: 56
          }
        }],
        line: 18
      },
      "3": {
        loc: {
          start: {
            line: 21,
            column: 21
          },
          end: {
            line: 21,
            column: 50
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 21,
            column: 21
          },
          end: {
            line: 21,
            column: 34
          }
        }, {
          start: {
            line: 21,
            column: 38
          },
          end: {
            line: 21,
            column: 50
          }
        }],
        line: 21
      },
      "4": {
        loc: {
          start: {
            line: 23,
            column: 27
          },
          end: {
            line: 23,
            column: 74
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 23,
            column: 27
          },
          end: {
            line: 23,
            column: 47
          }
        }, {
          start: {
            line: 23,
            column: 51
          },
          end: {
            line: 23,
            column: 74
          }
        }],
        line: 23
      },
      "5": {
        loc: {
          start: {
            line: 30,
            column: 2
          },
          end: {
            line: 34,
            column: 3
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 30,
            column: 2
          },
          end: {
            line: 34,
            column: 3
          }
        }, {
          start: {
            line: 30,
            column: 2
          },
          end: {
            line: 34,
            column: 3
          }
        }],
        line: 30
      },
      "6": {
        loc: {
          start: {
            line: 38,
            column: 2
          },
          end: {
            line: 42,
            column: 3
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 38,
            column: 2
          },
          end: {
            line: 42,
            column: 3
          }
        }, {
          start: {
            line: 38,
            column: 2
          },
          end: {
            line: 42,
            column: 3
          }
        }],
        line: 38
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0, 0],
      "3": [0, 0],
      "4": [0, 0],
      "5": [0, 0],
      "6": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "0f0b32a919beacee3d27852a9b0e92630e49b411"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_1jre50uwcf = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_1jre50uwcf();



var DEFAULT_THRESHOLD_WIDTH = (cov_1jre50uwcf().s[0]++, 550);

function isMobile(props) {
  var _document;

  cov_1jre50uwcf().f[0]++;
  var hasJssSSRStyles = (cov_1jre50uwcf().s[1]++, (cov_1jre50uwcf().b[0][0]++, typeof document !== 'undefined') && (cov_1jre50uwcf().b[0][1]++, !!((_document = document) === null || _document === void 0 ? void 0 : _document.querySelector('#jss-server-side'))));
  var width = (cov_1jre50uwcf().s[2]++, Object(hooks_useWindowDimensions__WEBPACK_IMPORTED_MODULE_1__["default"])().width);
  var isBrowser = (cov_1jre50uwcf().s[3]++, true);
  var isMobileResult;
  cov_1jre50uwcf().s[4]++;

  if (((cov_1jre50uwcf().b[2][0]++, !isBrowser) || (cov_1jre50uwcf().b[2][1]++, hasJssSSRStyles)) && (cov_1jre50uwcf().b[2][2]++, props.userAgent)) {
    cov_1jre50uwcf().b[1][0]++;
    // keep the isDesktop() return uniform if JSS styles exist
    var md = (cov_1jre50uwcf().s[5]++, new mobile_detect__WEBPACK_IMPORTED_MODULE_2___default.a(props.userAgent));
    cov_1jre50uwcf().s[6]++;
    isMobileResult = (cov_1jre50uwcf().b[3][0]++, !!md.mobile()) && (cov_1jre50uwcf().b[3][1]++, !md.tablet());
  } else {
    cov_1jre50uwcf().b[1][1]++;
    var thresholdWidth = (cov_1jre50uwcf().s[7]++, (cov_1jre50uwcf().b[4][0]++, props.thresholdWidth) || (cov_1jre50uwcf().b[4][1]++, DEFAULT_THRESHOLD_WIDTH));
    cov_1jre50uwcf().s[8]++;
    isMobileResult = width <= thresholdWidth;
  }

  cov_1jre50uwcf().s[9]++;
  return isMobileResult;
}

cov_1jre50uwcf().s[10]++;
var DesktopView = function DesktopView(props) {
  cov_1jre50uwcf().f[1]++;
  cov_1jre50uwcf().s[11]++;

  if (!isMobile(props)) {
    cov_1jre50uwcf().b[5][0]++;
    cov_1jre50uwcf().s[12]++;
    return __jsx(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, props.children);
  } else {
    cov_1jre50uwcf().b[5][1]++;
    cov_1jre50uwcf().s[13]++;
    return null;
  }
};
cov_1jre50uwcf().s[14]++;
var MobileView = function MobileView(props) {
  cov_1jre50uwcf().f[2]++;
  cov_1jre50uwcf().s[15]++;

  if (isMobile(props)) {
    cov_1jre50uwcf().b[6][0]++;
    cov_1jre50uwcf().s[16]++;
    return __jsx(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, props.children);
  } else {
    cov_1jre50uwcf().b[6][1]++;
    cov_1jre50uwcf().s[17]++;
    return null;
  }
};

/***/ }),

/***/ "./src/games/common/gameMode.ts":
/*!**************************************!*\
  !*** ./src/games/common/gameMode.ts ***!
  \**************************************/
/*! exports provided: isLocalGame, isOnlineGame, isAIGame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLocalGame", function() { return isLocalGame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOnlineGame", function() { return isOnlineGame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAIGame", function() { return isAIGame; });
/* harmony import */ var components_App_Game_GameModePicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! components/App/Game/GameModePicker */ "./src/components/App/Game/GameModePicker.tsx");
function cov_2msw7xr2jk() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/common/gameMode.ts";
  var hash = "e1e58a91b90a0a839b501f1e740063c5286345a2";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/common/gameMode.ts",
    statementMap: {
      "0": {
        start: {
          line: 5,
          column: 2
        },
        end: {
          line: 5,
          column: 60
        }
      },
      "1": {
        start: {
          line: 9,
          column: 2
        },
        end: {
          line: 9,
          column: 61
        }
      },
      "2": {
        start: {
          line: 13,
          column: 2
        },
        end: {
          line: 13,
          column: 51
        }
      }
    },
    fnMap: {
      "0": {
        name: "isLocalGame",
        decl: {
          start: {
            line: 4,
            column: 16
          },
          end: {
            line: 4,
            column: 27
          }
        },
        loc: {
          start: {
            line: 4,
            column: 49
          },
          end: {
            line: 6,
            column: 1
          }
        },
        line: 4
      },
      "1": {
        name: "isOnlineGame",
        decl: {
          start: {
            line: 8,
            column: 16
          },
          end: {
            line: 8,
            column: 28
          }
        },
        loc: {
          start: {
            line: 8,
            column: 50
          },
          end: {
            line: 10,
            column: 1
          }
        },
        line: 8
      },
      "2": {
        name: "isAIGame",
        decl: {
          start: {
            line: 12,
            column: 16
          },
          end: {
            line: 12,
            column: 24
          }
        },
        loc: {
          start: {
            line: 12,
            column: 46
          },
          end: {
            line: 14,
            column: 1
          }
        },
        line: 12
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 5,
            column: 9
          },
          end: {
            line: 5,
            column: 59
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 5,
            column: 9
          },
          end: {
            line: 5,
            column: 17
          }
        }, {
          start: {
            line: 5,
            column: 21
          },
          end: {
            line: 5,
            column: 59
          }
        }],
        line: 5
      },
      "1": {
        loc: {
          start: {
            line: 9,
            column: 9
          },
          end: {
            line: 9,
            column: 60
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 9,
            column: 9
          },
          end: {
            line: 9,
            column: 17
          }
        }, {
          start: {
            line: 9,
            column: 21
          },
          end: {
            line: 9,
            column: 60
          }
        }],
        line: 9
      },
      "2": {
        loc: {
          start: {
            line: 13,
            column: 9
          },
          end: {
            line: 13,
            column: 50
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 13,
            column: 9
          },
          end: {
            line: 13,
            column: 17
          }
        }, {
          start: {
            line: 13,
            column: 21
          },
          end: {
            line: 13,
            column: 50
          }
        }],
        line: 13
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "e1e58a91b90a0a839b501f1e740063c5286345a2"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2msw7xr2jk = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2msw7xr2jk();

function isLocalGame(gameArgs) {
  cov_2msw7xr2jk().f[0]++;
  cov_2msw7xr2jk().s[0]++;
  return (cov_2msw7xr2jk().b[0][0]++, gameArgs) && (cov_2msw7xr2jk().b[0][1]++, gameArgs.mode === components_App_Game_GameModePicker__WEBPACK_IMPORTED_MODULE_0__["GameMode"].LocalFriend);
}
function isOnlineGame(gameArgs) {
  cov_2msw7xr2jk().f[1]++;
  cov_2msw7xr2jk().s[1]++;
  return (cov_2msw7xr2jk().b[1][0]++, gameArgs) && (cov_2msw7xr2jk().b[1][1]++, gameArgs.mode === components_App_Game_GameModePicker__WEBPACK_IMPORTED_MODULE_0__["GameMode"].OnlineFriend);
}
function isAIGame(gameArgs) {
  cov_2msw7xr2jk().f[2]++;
  cov_2msw7xr2jk().s[2]++;
  return (cov_2msw7xr2jk().b[2][0]++, gameArgs) && (cov_2msw7xr2jk().b[2][1]++, gameArgs.mode === components_App_Game_GameModePicker__WEBPACK_IMPORTED_MODULE_0__["GameMode"].AI);
}

/***/ }),

/***/ "./src/games/seabattle/Battle.tsx":
/*!****************************************!*\
  !*** ./src/games/seabattle/Battle.tsx ***!
  \****************************************/
/*! exports provided: Battle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Battle", function() { return Battle; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _Radar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Radar */ "./src/games/seabattle/Radar.tsx");
/* harmony import */ var _sound__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sound */ "./src/games/seabattle/sound.ts");
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @material-ui/core/Typography */ "./node_modules/@material-ui/core/esm/Typography/index.js");







var __jsx = react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement;

function cov_1ax6qcfozm() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/Battle.tsx";
  var hash = "d8fa7898b8f17ec3d7b1e6c03eb4f209f2de6972";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/Battle.tsx",
    statementMap: {
      "0": {
        start: {
          line: 31,
          column: 4
        },
        end: {
          line: 31,
          column: 17
        }
      },
      "1": {
        start: {
          line: 32,
          column: 4
        },
        end: {
          line: 38,
          column: 6
        }
      },
      "2": {
        start: {
          line: 40,
          column: 13
        },
        end: {
          line: 59,
          column: 3
        }
      },
      "3": {
        start: {
          line: 42,
          column: 6
        },
        end: {
          line: 45,
          column: 20
        }
      },
      "4": {
        start: {
          line: 44,
          column: 10
        },
        end: {
          line: 44,
          column: 119
        }
      },
      "5": {
        start: {
          line: 46,
          column: 4
        },
        end: {
          line: 58,
          column: 5
        }
      },
      "6": {
        start: {
          line: 47,
          column: 6
        },
        end: {
          line: 47,
          column: 45
        }
      },
      "7": {
        start: {
          line: 48,
          column: 6
        },
        end: {
          line: 57,
          column: 7
        }
      },
      "8": {
        start: {
          line: 49,
          column: 8
        },
        end: {
          line: 51,
          column: 11
        }
      },
      "9": {
        start: {
          line: 50,
          column: 10
        },
        end: {
          line: 50,
          column: 50
        }
      },
      "10": {
        start: {
          line: 52,
          column: 8
        },
        end: {
          line: 56,
          column: 17
        }
      },
      "11": {
        start: {
          line: 53,
          column: 10
        },
        end: {
          line: 55,
          column: 13
        }
      },
      "12": {
        start: {
          line: 54,
          column: 12
        },
        end: {
          line: 54,
          column: 53
        }
      },
      "13": {
        start: {
          line: 62,
          column: 4
        },
        end: {
          line: 73,
          column: 5
        }
      },
      "14": {
        start: {
          line: 63,
          column: 6
        },
        end: {
          line: 71,
          column: 9
        }
      },
      "15": {
        start: {
          line: 72,
          column: 6
        },
        end: {
          line: 72,
          column: 55
        }
      },
      "16": {
        start: {
          line: 77,
          column: 19
        },
        end: {
          line: 77,
          column: 104
        }
      },
      "17": {
        start: {
          line: 78,
          column: 27
        },
        end: {
          line: 78,
          column: 86
        }
      },
      "18": {
        start: {
          line: 78,
          column: 63
        },
        end: {
          line: 78,
          column: 85
        }
      },
      "19": {
        start: {
          line: 79,
          column: 29
        },
        end: {
          line: 79,
          column: 99
        }
      },
      "20": {
        start: {
          line: 79,
          column: 75
        },
        end: {
          line: 79,
          column: 98
        }
      },
      "21": {
        start: {
          line: 80,
          column: 20
        },
        end: {
          line: 80,
          column: 38
        }
      },
      "22": {
        start: {
          line: 81,
          column: 4
        },
        end: {
          line: 83,
          column: 5
        }
      },
      "23": {
        start: {
          line: 82,
          column: 6
        },
        end: {
          line: 82,
          column: 34
        }
      },
      "24": {
        start: {
          line: 84,
          column: 4
        },
        end: {
          line: 98,
          column: 6
        }
      },
      "25": {
        start: {
          line: 102,
          column: 4
        },
        end: {
          line: 108,
          column: 5
        }
      },
      "26": {
        start: {
          line: 103,
          column: 6
        },
        end: {
          line: 103,
          column: 51
        }
      },
      "27": {
        start: {
          line: 104,
          column: 11
        },
        end: {
          line: 108,
          column: 5
        }
      },
      "28": {
        start: {
          line: 105,
          column: 6
        },
        end: {
          line: 105,
          column: 30
        }
      },
      "29": {
        start: {
          line: 107,
          column: 6
        },
        end: {
          line: 107,
          column: 39
        }
      },
      "30": {
        start: {
          line: 112,
          column: 4
        },
        end: {
          line: 122,
          column: 18
        }
      },
      "31": {
        start: {
          line: 113,
          column: 22
        },
        end: {
          line: 113,
          column: 48
        }
      },
      "32": {
        start: {
          line: 114,
          column: 6
        },
        end: {
          line: 121,
          column: 7
        }
      },
      "33": {
        start: {
          line: 115,
          column: 8
        },
        end: {
          line: 115,
          column: 57
        }
      },
      "34": {
        start: {
          line: 117,
          column: 8
        },
        end: {
          line: 120,
          column: 11
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 30,
            column: 2
          },
          end: {
            line: 30,
            column: 3
          }
        },
        loc: {
          start: {
            line: 30,
            column: 35
          },
          end: {
            line: 39,
            column: 3
          }
        },
        line: 30
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 40,
            column: 13
          },
          end: {
            line: 40,
            column: 14
          }
        },
        loc: {
          start: {
            line: 40,
            column: 30
          },
          end: {
            line: 59,
            column: 3
          }
        },
        line: 40
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 43,
            column: 8
          },
          end: {
            line: 43,
            column: 9
          }
        },
        loc: {
          start: {
            line: 44,
            column: 10
          },
          end: {
            line: 44,
            column: 119
          }
        },
        line: 44
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 49,
            column: 22
          },
          end: {
            line: 49,
            column: 23
          }
        },
        loc: {
          start: {
            line: 49,
            column: 36
          },
          end: {
            line: 51,
            column: 9
          }
        },
        line: 49
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 52,
            column: 19
          },
          end: {
            line: 52,
            column: 20
          }
        },
        loc: {
          start: {
            line: 52,
            column: 25
          },
          end: {
            line: 56,
            column: 9
          }
        },
        line: 52
      },
      "5": {
        name: "(anonymous_5)",
        decl: {
          start: {
            line: 53,
            column: 24
          },
          end: {
            line: 53,
            column: 25
          }
        },
        loc: {
          start: {
            line: 53,
            column: 38
          },
          end: {
            line: 55,
            column: 11
          }
        },
        line: 53
      },
      "6": {
        name: "(anonymous_6)",
        decl: {
          start: {
            line: 61,
            column: 2
          },
          end: {
            line: 61,
            column: 3
          }
        },
        loc: {
          start: {
            line: 61,
            column: 46
          },
          end: {
            line: 74,
            column: 3
          }
        },
        line: 61
      },
      "7": {
        name: "(anonymous_7)",
        decl: {
          start: {
            line: 76,
            column: 2
          },
          end: {
            line: 76,
            column: 3
          }
        },
        loc: {
          start: {
            line: 76,
            column: 11
          },
          end: {
            line: 99,
            column: 3
          }
        },
        line: 76
      },
      "8": {
        name: "(anonymous_8)",
        decl: {
          start: {
            line: 78,
            column: 53
          },
          end: {
            line: 78,
            column: 54
          }
        },
        loc: {
          start: {
            line: 78,
            column: 63
          },
          end: {
            line: 78,
            column: 85
          }
        },
        line: 78
      },
      "9": {
        name: "(anonymous_9)",
        decl: {
          start: {
            line: 79,
            column: 56
          },
          end: {
            line: 79,
            column: 57
          }
        },
        loc: {
          start: {
            line: 79,
            column: 75
          },
          end: {
            line: 79,
            column: 98
          }
        },
        line: 79
      },
      "10": {
        name: "(anonymous_10)",
        decl: {
          start: {
            line: 101,
            column: 2
          },
          end: {
            line: 101,
            column: 3
          }
        },
        loc: {
          start: {
            line: 101,
            column: 16
          },
          end: {
            line: 109,
            column: 3
          }
        },
        line: 101
      },
      "11": {
        name: "(anonymous_11)",
        decl: {
          start: {
            line: 111,
            column: 2
          },
          end: {
            line: 111,
            column: 3
          }
        },
        loc: {
          start: {
            line: 111,
            column: 24
          },
          end: {
            line: 123,
            column: 3
          }
        },
        line: 111
      },
      "12": {
        name: "(anonymous_12)",
        decl: {
          start: {
            line: 112,
            column: 12
          },
          end: {
            line: 112,
            column: 13
          }
        },
        loc: {
          start: {
            line: 112,
            column: 18
          },
          end: {
            line: 122,
            column: 5
          }
        },
        line: 112
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 44,
            column: 10
          },
          end: {
            line: 44,
            column: 119
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 44,
            column: 10
          },
          end: {
            line: 44,
            column: 65
          }
        }, {
          start: {
            line: 44,
            column: 69
          },
          end: {
            line: 44,
            column: 92
          }
        }, {
          start: {
            line: 44,
            column: 96
          },
          end: {
            line: 44,
            column: 119
          }
        }],
        line: 44
      },
      "1": {
        loc: {
          start: {
            line: 46,
            column: 4
          },
          end: {
            line: 58,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 46,
            column: 4
          },
          end: {
            line: 58,
            column: 5
          }
        }, {
          start: {
            line: 46,
            column: 4
          },
          end: {
            line: 58,
            column: 5
          }
        }],
        line: 46
      },
      "2": {
        loc: {
          start: {
            line: 48,
            column: 6
          },
          end: {
            line: 57,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 48,
            column: 6
          },
          end: {
            line: 57,
            column: 7
          }
        }, {
          start: {
            line: 48,
            column: 6
          },
          end: {
            line: 57,
            column: 7
          }
        }],
        line: 48
      },
      "3": {
        loc: {
          start: {
            line: 48,
            column: 10
          },
          end: {
            line: 48,
            column: 54
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 48,
            column: 10
          },
          end: {
            line: 48,
            column: 29
          }
        }, {
          start: {
            line: 48,
            column: 33
          },
          end: {
            line: 48,
            column: 54
          }
        }],
        line: 48
      },
      "4": {
        loc: {
          start: {
            line: 62,
            column: 4
          },
          end: {
            line: 73,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 62,
            column: 4
          },
          end: {
            line: 73,
            column: 5
          }
        }, {
          start: {
            line: 62,
            column: 4
          },
          end: {
            line: 73,
            column: 5
          }
        }],
        line: 62
      },
      "5": {
        loc: {
          start: {
            line: 77,
            column: 28
          },
          end: {
            line: 77,
            column: 99
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 77,
            column: 51
          },
          end: {
            line: 77,
            column: 72
          }
        }, {
          start: {
            line: 77,
            column: 75
          },
          end: {
            line: 77,
            column: 99
          }
        }],
        line: 77
      },
      "6": {
        loc: {
          start: {
            line: 81,
            column: 4
          },
          end: {
            line: 83,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 81,
            column: 4
          },
          end: {
            line: 83,
            column: 5
          }
        }, {
          start: {
            line: 81,
            column: 4
          },
          end: {
            line: 83,
            column: 5
          }
        }],
        line: 81
      },
      "7": {
        loc: {
          start: {
            line: 102,
            column: 4
          },
          end: {
            line: 108,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 102,
            column: 4
          },
          end: {
            line: 108,
            column: 5
          }
        }, {
          start: {
            line: 102,
            column: 4
          },
          end: {
            line: 108,
            column: 5
          }
        }],
        line: 102
      },
      "8": {
        loc: {
          start: {
            line: 103,
            column: 13
          },
          end: {
            line: 103,
            column: 50
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 103,
            column: 36
          },
          end: {
            line: 103,
            column: 41
          }
        }, {
          start: {
            line: 103,
            column: 44
          },
          end: {
            line: 103,
            column: 50
          }
        }],
        line: 103
      },
      "9": {
        loc: {
          start: {
            line: 104,
            column: 11
          },
          end: {
            line: 108,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 104,
            column: 11
          },
          end: {
            line: 108,
            column: 5
          }
        }, {
          start: {
            line: 104,
            column: 11
          },
          end: {
            line: 108,
            column: 5
          }
        }],
        line: 104
      },
      "10": {
        loc: {
          start: {
            line: 114,
            column: 6
          },
          end: {
            line: 121,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 114,
            column: 6
          },
          end: {
            line: 121,
            column: 7
          }
        }, {
          start: {
            line: 114,
            column: 6
          },
          end: {
            line: 121,
            column: 7
          }
        }],
        line: 114
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0,
      "23": 0,
      "24": 0,
      "25": 0,
      "26": 0,
      "27": 0,
      "28": 0,
      "29": 0,
      "30": 0,
      "31": 0,
      "32": 0,
      "33": 0,
      "34": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0
    },
    b: {
      "0": [0, 0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0],
      "4": [0, 0],
      "5": [0, 0],
      "6": [0, 0],
      "7": [0, 0],
      "8": [0, 0],
      "9": [0, 0],
      "10": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "d8fa7898b8f17ec3d7b1e6c03eb4f209f2de6972"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_1ax6qcfozm = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_1ax6qcfozm();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Battle = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Battle, _React$Component);

  var _super = _createSuper(Battle);

  function Battle(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Battle);

    cov_1ax6qcfozm().f[0]++;
    cov_1ax6qcfozm().s[0]++;
    _this = _super.call(this, props);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_onClick", (cov_1ax6qcfozm().s[2]++, function (cell) {
      cov_1ax6qcfozm().f[1]++;
      var uniqueMove = (cov_1ax6qcfozm().s[3]++, _this.state.G.salvos.filter(function (salvo) {
        cov_1ax6qcfozm().f[2]++;
        cov_1ax6qcfozm().s[4]++;
        return (cov_1ax6qcfozm().b[0][0]++, salvo.player === parseInt(_this.state.currentPlayer, 10)) && (cov_1ax6qcfozm().b[0][1]++, salvo.cell.x === cell.x) && (cov_1ax6qcfozm().b[0][2]++, salvo.cell.y === cell.y);
      }).length === 0);
      cov_1ax6qcfozm().s[5]++;

      if (uniqueMove) {
        cov_1ax6qcfozm().b[1][0]++;
        cov_1ax6qcfozm().s[6]++;

        _this.props.moves.salvo(cell.x, cell.y);

        cov_1ax6qcfozm().s[7]++;

        if ((cov_1ax6qcfozm().b[3][0]++, _this.props.isAIGame) && (cov_1ax6qcfozm().b[3][1]++, !_this.state.aiPlaying)) {
          cov_1ax6qcfozm().b[2][0]++;
          cov_1ax6qcfozm().s[8]++;

          _this.setState(function (oldState) {
            cov_1ax6qcfozm().f[3]++;
            cov_1ax6qcfozm().s[9]++;
            return _objectSpread({}, oldState, {
              aiPlaying: true
            });
          });

          cov_1ax6qcfozm().s[10]++;
          setTimeout(function () {
            cov_1ax6qcfozm().f[4]++;
            cov_1ax6qcfozm().s[11]++;

            _this.setState(function (oldState) {
              cov_1ax6qcfozm().f[5]++;
              cov_1ax6qcfozm().s[12]++;
              return _objectSpread({}, oldState, {
                aiPlaying: false
              });
            });
          }, 2500);
        } else {
          cov_1ax6qcfozm().b[2][1]++;
        }
      } else {
        cov_1ax6qcfozm().b[1][1]++;
      }
    }));

    cov_1ax6qcfozm().s[1]++;
    _this.state = {
      G: props.G,
      playerID: props.playerID,
      currentPlayer: props.currentPlayer,
      showSalvo: false,
      aiPlaying: false
    };
    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Battle, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      cov_1ax6qcfozm().f[6]++;
      cov_1ax6qcfozm().s[13]++;

      if (prevProps.currentPlayer !== this.props.currentPlayer) {
        cov_1ax6qcfozm().b[4][0]++;
        cov_1ax6qcfozm().s[14]++;
        this.setState({
          G: this.props.G,
          playerID: this.props.playerID,
          currentPlayer: this.props.currentPlayer,
          showSalvo: true,
          prevPlayer: prevProps.currentPlayer,
          startTime: Date.now(),
          salvo: this.props.G.salvos[this.props.G.salvos.length - 1]
        });
        cov_1ax6qcfozm().s[15]++;
        requestAnimationFrame(this._animate(Date.now()));
      } else {
        cov_1ax6qcfozm().b[4][1]++;
      }
    }
  }, {
    key: "render",
    value: function render() {
      cov_1ax6qcfozm().f[7]++;
      var player = (cov_1ax6qcfozm().s[16]++, parseInt(this.state.showSalvo ? (cov_1ax6qcfozm().b[5][0]++, this.state.prevPlayer) : (cov_1ax6qcfozm().b[5][1]++, this.state.currentPlayer), 10));
      var ships = (cov_1ax6qcfozm().s[17]++, this.state.G.ships.filter(function (ship) {
        cov_1ax6qcfozm().f[8]++;
        cov_1ax6qcfozm().s[18]++;
        return ship.player !== player;
      }));
      var salvos = (cov_1ax6qcfozm().s[19]++, this.state.G.salvos.filter(function (salvo) {
        cov_1ax6qcfozm().f[9]++;
        cov_1ax6qcfozm().s[20]++;
        return salvo.player === player;
      }));
      var message = (cov_1ax6qcfozm().s[21]++, this._getMessage());
      cov_1ax6qcfozm().s[22]++;

      if (this.props.getSoundPref()) {
        cov_1ax6qcfozm().b[6][0]++;
        cov_1ax6qcfozm().s[23]++;
        Object(_sound__WEBPACK_IMPORTED_MODULE_9__["playSeabattleSound"])(message);
      } else {
        cov_1ax6qcfozm().b[6][1]++;
      }

      cov_1ax6qcfozm().s[24]++;
      return __jsx("div", null, __jsx(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_10__["default"], {
        variant: "h5",
        style: {
          textAlign: 'center',
          color: 'white',
          marginBottom: '16px'
        }
      }, message), __jsx(_Radar__WEBPACK_IMPORTED_MODULE_8__["Radar"], {
        player: player,
        ships: ships,
        salvos: salvos,
        editable: false,
        blinkSalvo: this.state.showSalvo,
        onClick: this._onClick
      }));
    }
  }, {
    key: "_getMessage",
    value: function _getMessage() {
      cov_1ax6qcfozm().f[10]++;
      cov_1ax6qcfozm().s[25]++;

      if (this.state.showSalvo) {
        cov_1ax6qcfozm().b[7][0]++;
        cov_1ax6qcfozm().s[26]++;
        return this.state.salvo.hit ? (cov_1ax6qcfozm().b[8][0]++, 'HIT') : (cov_1ax6qcfozm().b[8][1]++, 'MISS');
      } else {
        cov_1ax6qcfozm().b[7][1]++;
        cov_1ax6qcfozm().s[27]++;

        if (this.state.playerID === this.state.currentPlayer) {
          cov_1ax6qcfozm().b[9][0]++;
          cov_1ax6qcfozm().s[28]++;
          return 'CLICK TO SHOOT';
        } else {
          cov_1ax6qcfozm().b[9][1]++;
          cov_1ax6qcfozm().s[29]++;
          return 'Waiting for opponent...';
        }
      }
    }
  }, {
    key: "_animate",
    value: function _animate(now) {
      var _this2 = this;

      cov_1ax6qcfozm().f[11]++;
      cov_1ax6qcfozm().s[30]++;
      return function () {
        cov_1ax6qcfozm().f[12]++;
        var elapsed = (cov_1ax6qcfozm().s[31]++, now - _this2.state.startTime);
        cov_1ax6qcfozm().s[32]++;

        if (elapsed < 2e3) {
          cov_1ax6qcfozm().b[10][0]++;
          cov_1ax6qcfozm().s[33]++;
          requestAnimationFrame(_this2._animate(Date.now()));
        } else {
          cov_1ax6qcfozm().b[10][1]++;
          cov_1ax6qcfozm().s[34]++;

          _this2.setState(_objectSpread({}, _this2.state, {
            showSalvo: false
          }));
        }
      }.bind(this);
    }
  }]);

  return Battle;
}((react__WEBPACK_IMPORTED_MODULE_7___default.a.Component));

/***/ }),

/***/ "./src/games/seabattle/Radar.tsx":
/*!***************************************!*\
  !*** ./src/games/seabattle/Radar.tsx ***!
  \***************************************/
/*! exports provided: Radar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Radar", function() { return Radar; });
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./game */ "./src/games/seabattle/game.ts");
/* harmony import */ var ui__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ui */ "./src/ui/index.ts");
/* harmony import */ var _media_SvgShip2__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./media/SvgShip2 */ "./src/games/seabattle/media/SvgShip2.tsx");
/* harmony import */ var _media_SvgShip3__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./media/SvgShip3 */ "./src/games/seabattle/media/SvgShip3.tsx");
/* harmony import */ var _media_SvgShip4__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./media/SvgShip4 */ "./src/games/seabattle/media/SvgShip4.tsx");
/* harmony import */ var _media_SvgShip5__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./media/SvgShip5 */ "./src/games/seabattle/media/SvgShip5.tsx");
/* harmony import */ var _media_SvgBackground__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./media/SvgBackground */ "./src/games/seabattle/media/SvgBackground.tsx");
/* harmony import */ var _media_SvgHit__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./media/SvgHit */ "./src/games/seabattle/media/SvgHit.tsx");
/* harmony import */ var _media_SvgMiss__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./media/SvgMiss */ "./src/games/seabattle/media/SvgMiss.tsx");
/* harmony import */ var components_App_Blink__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! components/App/Blink */ "./src/components/App/Blink.tsx");








var __jsx = react__WEBPACK_IMPORTED_MODULE_8___default.a.createElement;

function cov_xq0uwk3n8() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/Radar.tsx";
  var hash = "72c84c1dd0213be758a846891b5bcfbc651d7bdc";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/Radar.tsx",
    statementMap: {
      "0": {
        start: {
          line: 29,
          column: 4
        },
        end: {
          line: 29,
          column: 17
        }
      },
      "1": {
        start: {
          line: 33,
          column: 19
        },
        end: {
          line: 35,
          column: 32
        }
      },
      "2": {
        start: {
          line: 36,
          column: 4
        },
        end: {
          line: 42,
          column: 6
        }
      },
      "3": {
        start: {
          line: 45,
          column: 13
        },
        end: {
          line: 54,
          column: 3
        }
      },
      "4": {
        start: {
          line: 46,
          column: 4
        },
        end: {
          line: 53,
          column: 5
        }
      },
      "5": {
        start: {
          line: 47,
          column: 24
        },
        end: {
          line: 47,
          column: 58
        }
      },
      "6": {
        start: {
          line: 48,
          column: 6
        },
        end: {
          line: 50,
          column: 7
        }
      },
      "7": {
        start: {
          line: 49,
          column: 8
        },
        end: {
          line: 49,
          column: 36
        }
      },
      "8": {
        start: {
          line: 52,
          column: 6
        },
        end: {
          line: 52,
          column: 33
        }
      },
      "9": {
        start: {
          line: 56,
          column: 16
        },
        end: {
          line: 58,
          column: 3
        }
      },
      "10": {
        start: {
          line: 57,
          column: 4
        },
        end: {
          line: 57,
          column: 31
        }
      },
      "11": {
        start: {
          line: 60,
          column: 12
        },
        end: {
          line: 72,
          column: 3
        }
      },
      "12": {
        start: {
          line: 61,
          column: 14
        },
        end: {
          line: 61,
          column: 34
        }
      },
      "13": {
        start: {
          line: 62,
          column: 14
        },
        end: {
          line: 62,
          column: 34
        }
      },
      "14": {
        start: {
          line: 63,
          column: 22
        },
        end: {
          line: 63,
          column: 38
        }
      },
      "15": {
        start: {
          line: 64,
          column: 22
        },
        end: {
          line: 64,
          column: 38
        }
      },
      "16": {
        start: {
          line: 65,
          column: 4
        },
        end: {
          line: 67,
          column: 5
        }
      },
      "17": {
        start: {
          line: 66,
          column: 6
        },
        end: {
          line: 66,
          column: 13
        }
      },
      "18": {
        start: {
          line: 68,
          column: 4
        },
        end: {
          line: 71,
          column: 5
        }
      },
      "19": {
        start: {
          line: 69,
          column: 24
        },
        end: {
          line: 69,
          column: 60
        }
      },
      "20": {
        start: {
          line: 70,
          column: 6
        },
        end: {
          line: 70,
          column: 38
        }
      },
      "21": {
        start: {
          line: 75,
          column: 4
        },
        end: {
          line: 77,
          column: 7
        }
      },
      "22": {
        start: {
          line: 76,
          column: 6
        },
        end: {
          line: 76,
          column: 72
        }
      },
      "23": {
        start: {
          line: 76,
          column: 41
        },
        end: {
          line: 76,
          column: 63
        }
      },
      "24": {
        start: {
          line: 81,
          column: 17
        },
        end: {
          line: 81,
          column: 44
        }
      },
      "25": {
        start: {
          line: 82,
          column: 18
        },
        end: {
          line: 82,
          column: 61
        }
      },
      "26": {
        start: {
          line: 83,
          column: 4
        },
        end: {
          line: 83,
          column: 42
        }
      },
      "27": {
        start: {
          line: 87,
          column: 17
        },
        end: {
          line: 87,
          column: 44
        }
      },
      "28": {
        start: {
          line: 88,
          column: 18
        },
        end: {
          line: 88,
          column: 61
        }
      },
      "29": {
        start: {
          line: 89,
          column: 17
        },
        end: {
          line: 89,
          column: 24
        }
      },
      "30": {
        start: {
          line: 90,
          column: 4
        },
        end: {
          line: 90,
          column: 22
        }
      },
      "31": {
        start: {
          line: 91,
          column: 4
        },
        end: {
          line: 91,
          column: 19
        }
      },
      "32": {
        start: {
          line: 92,
          column: 4
        },
        end: {
          line: 92,
          column: 70
        }
      },
      "33": {
        start: {
          line: 96,
          column: 17
        },
        end: {
          line: 96,
          column: 40
        }
      },
      "34": {
        start: {
          line: 97,
          column: 21
        },
        end: {
          line: 97,
          column: 23
        }
      },
      "35": {
        start: {
          line: 98,
          column: 4
        },
        end: {
          line: 100,
          column: 5
        }
      },
      "36": {
        start: {
          line: 98,
          column: 17
        },
        end: {
          line: 98,
          column: 18
        }
      },
      "37": {
        start: {
          line: 99,
          column: 6
        },
        end: {
          line: 99,
          column: 66
        }
      },
      "38": {
        start: {
          line: 101,
          column: 21
        },
        end: {
          line: 101,
          column: 42
        }
      },
      "39": {
        start: {
          line: 102,
          column: 4
        },
        end: {
          line: 102,
          column: 51
        }
      },
      "40": {
        start: {
          line: 103,
          column: 4
        },
        end: {
          line: 103,
          column: 32
        }
      },
      "41": {
        start: {
          line: 111,
          column: 4
        },
        end: {
          line: 124,
          column: 5
        }
      },
      "42": {
        start: {
          line: 113,
          column: 8
        },
        end: {
          line: 113,
          column: 28
        }
      },
      "43": {
        start: {
          line: 114,
          column: 8
        },
        end: {
          line: 114,
          column: 14
        }
      },
      "44": {
        start: {
          line: 116,
          column: 8
        },
        end: {
          line: 116,
          column: 28
        }
      },
      "45": {
        start: {
          line: 117,
          column: 8
        },
        end: {
          line: 117,
          column: 14
        }
      },
      "46": {
        start: {
          line: 119,
          column: 8
        },
        end: {
          line: 119,
          column: 28
        }
      },
      "47": {
        start: {
          line: 120,
          column: 8
        },
        end: {
          line: 120,
          column: 14
        }
      },
      "48": {
        start: {
          line: 122,
          column: 8
        },
        end: {
          line: 122,
          column: 28
        }
      },
      "49": {
        start: {
          line: 123,
          column: 8
        },
        end: {
          line: 123,
          column: 14
        }
      },
      "50": {
        start: {
          line: 125,
          column: 4
        },
        end: {
          line: 129,
          column: 5
        }
      },
      "51": {
        start: {
          line: 126,
          column: 6
        },
        end: {
          line: 126,
          column: 65
        }
      },
      "52": {
        start: {
          line: 128,
          column: 6
        },
        end: {
          line: 128,
          column: 18
        }
      },
      "53": {
        start: {
          line: 133,
          column: 19
        },
        end: {
          line: 133,
          column: 21
        }
      },
      "54": {
        start: {
          line: 134,
          column: 4
        },
        end: {
          line: 150,
          column: 5
        }
      },
      "55": {
        start: {
          line: 135,
          column: 19
        },
        end: {
          line: 135,
          column: 32
        }
      },
      "56": {
        start: {
          line: 136,
          column: 26
        },
        end: {
          line: 136,
          column: 105
        }
      },
      "57": {
        start: {
          line: 138,
          column: 6
        },
        end: {
          line: 149,
          column: 8
        }
      },
      "58": {
        start: {
          line: 151,
          column: 4
        },
        end: {
          line: 151,
          column: 18
        }
      },
      "59": {
        start: {
          line: 155,
          column: 34
        },
        end: {
          line: 155,
          column: 36
        }
      },
      "60": {
        start: {
          line: 156,
          column: 4
        },
        end: {
          line: 158,
          column: 5
        }
      },
      "61": {
        start: {
          line: 157,
          column: 6
        },
        end: {
          line: 157,
          column: 20
        }
      },
      "62": {
        start: {
          line: 159,
          column: 12
        },
        end: {
          line: 159,
          column: 13
        }
      },
      "63": {
        start: {
          line: 160,
          column: 4
        },
        end: {
          line: 177,
          column: 5
        }
      },
      "64": {
        start: {
          line: 162,
          column: 6
        },
        end: {
          line: 166,
          column: 7
        }
      },
      "65": {
        start: {
          line: 163,
          column: 8
        },
        end: {
          line: 163,
          column: 29
        }
      },
      "66": {
        start: {
          line: 165,
          column: 8
        },
        end: {
          line: 165,
          column: 30
        }
      },
      "67": {
        start: {
          line: 167,
          column: 6
        },
        end: {
          line: 169,
          column: 7
        }
      },
      "68": {
        start: {
          line: 168,
          column: 8
        },
        end: {
          line: 168,
          column: 43
        }
      },
      "69": {
        start: {
          line: 170,
          column: 21
        },
        end: {
          line: 170,
          column: 43
        }
      },
      "70": {
        start: {
          line: 171,
          column: 6
        },
        end: {
          line: 175,
          column: 8
        }
      },
      "71": {
        start: {
          line: 176,
          column: 6
        },
        end: {
          line: 176,
          column: 10
        }
      },
      "72": {
        start: {
          line: 178,
          column: 4
        },
        end: {
          line: 178,
          column: 18
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 28,
            column: 2
          },
          end: {
            line: 28,
            column: 3
          }
        },
        loc: {
          start: {
            line: 28,
            column: 34
          },
          end: {
            line: 30,
            column: 3
          }
        },
        line: 28
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 32,
            column: 2
          },
          end: {
            line: 32,
            column: 3
          }
        },
        loc: {
          start: {
            line: 32,
            column: 11
          },
          end: {
            line: 43,
            column: 3
          }
        },
        line: 32
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 45,
            column: 13
          },
          end: {
            line: 45,
            column: 14
          }
        },
        loc: {
          start: {
            line: 45,
            column: 51
          },
          end: {
            line: 54,
            column: 3
          }
        },
        line: 45
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 56,
            column: 16
          },
          end: {
            line: 56,
            column: 17
          }
        },
        loc: {
          start: {
            line: 56,
            column: 22
          },
          end: {
            line: 58,
            column: 3
          }
        },
        line: 56
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 60,
            column: 12
          },
          end: {
            line: 60,
            column: 13
          }
        },
        loc: {
          start: {
            line: 60,
            column: 88
          },
          end: {
            line: 72,
            column: 3
          }
        },
        line: 60
      },
      "5": {
        name: "(anonymous_5)",
        decl: {
          start: {
            line: 74,
            column: 2
          },
          end: {
            line: 74,
            column: 3
          }
        },
        loc: {
          start: {
            line: 74,
            column: 42
          },
          end: {
            line: 78,
            column: 3
          }
        },
        line: 74
      },
      "6": {
        name: "(anonymous_6)",
        decl: {
          start: {
            line: 75,
            column: 38
          },
          end: {
            line: 75,
            column: 39
          }
        },
        loc: {
          start: {
            line: 75,
            column: 48
          },
          end: {
            line: 77,
            column: 5
          }
        },
        line: 75
      },
      "7": {
        name: "(anonymous_7)",
        decl: {
          start: {
            line: 76,
            column: 34
          },
          end: {
            line: 76,
            column: 35
          }
        },
        loc: {
          start: {
            line: 76,
            column: 41
          },
          end: {
            line: 76,
            column: 63
          }
        },
        line: 76
      },
      "8": {
        name: "(anonymous_8)",
        decl: {
          start: {
            line: 80,
            column: 2
          },
          end: {
            line: 80,
            column: 3
          }
        },
        loc: {
          start: {
            line: 80,
            column: 53
          },
          end: {
            line: 84,
            column: 3
          }
        },
        line: 80
      },
      "9": {
        name: "(anonymous_9)",
        decl: {
          start: {
            line: 86,
            column: 2
          },
          end: {
            line: 86,
            column: 3
          }
        },
        loc: {
          start: {
            line: 86,
            column: 33
          },
          end: {
            line: 93,
            column: 3
          }
        },
        line: 86
      },
      "10": {
        name: "(anonymous_10)",
        decl: {
          start: {
            line: 95,
            column: 2
          },
          end: {
            line: 95,
            column: 3
          }
        },
        loc: {
          start: {
            line: 95,
            column: 63
          },
          end: {
            line: 104,
            column: 3
          }
        },
        line: 95
      },
      "11": {
        name: "(anonymous_11)",
        decl: {
          start: {
            line: 106,
            column: 2
          },
          end: {
            line: 106,
            column: 3
          }
        },
        loc: {
          start: {
            line: 106,
            column: 53
          },
          end: {
            line: 130,
            column: 3
          }
        },
        line: 106
      },
      "12": {
        name: "(anonymous_12)",
        decl: {
          start: {
            line: 132,
            column: 2
          },
          end: {
            line: 132,
            column: 3
          }
        },
        loc: {
          start: {
            line: 132,
            column: 14
          },
          end: {
            line: 152,
            column: 3
          }
        },
        line: 132
      },
      "13": {
        name: "(anonymous_13)",
        decl: {
          start: {
            line: 154,
            column: 2
          },
          end: {
            line: 154,
            column: 3
          }
        },
        loc: {
          start: {
            line: 154,
            column: 15
          },
          end: {
            line: 179,
            column: 3
          }
        },
        line: 154
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 46,
            column: 4
          },
          end: {
            line: 53,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 46,
            column: 4
          },
          end: {
            line: 53,
            column: 5
          }
        }, {
          start: {
            line: 46,
            column: 4
          },
          end: {
            line: 53,
            column: 5
          }
        }],
        line: 46
      },
      "1": {
        loc: {
          start: {
            line: 48,
            column: 6
          },
          end: {
            line: 50,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 48,
            column: 6
          },
          end: {
            line: 50,
            column: 7
          }
        }, {
          start: {
            line: 48,
            column: 6
          },
          end: {
            line: 50,
            column: 7
          }
        }],
        line: 48
      },
      "2": {
        loc: {
          start: {
            line: 65,
            column: 4
          },
          end: {
            line: 67,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 65,
            column: 4
          },
          end: {
            line: 67,
            column: 5
          }
        }, {
          start: {
            line: 65,
            column: 4
          },
          end: {
            line: 67,
            column: 5
          }
        }],
        line: 65
      },
      "3": {
        loc: {
          start: {
            line: 65,
            column: 8
          },
          end: {
            line: 65,
            column: 44
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 65,
            column: 8
          },
          end: {
            line: 65,
            column: 13
          }
        }, {
          start: {
            line: 65,
            column: 17
          },
          end: {
            line: 65,
            column: 22
          }
        }, {
          start: {
            line: 65,
            column: 26
          },
          end: {
            line: 65,
            column: 33
          }
        }, {
          start: {
            line: 65,
            column: 37
          },
          end: {
            line: 65,
            column: 44
          }
        }],
        line: 65
      },
      "4": {
        loc: {
          start: {
            line: 68,
            column: 4
          },
          end: {
            line: 71,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 68,
            column: 4
          },
          end: {
            line: 71,
            column: 5
          }
        }, {
          start: {
            line: 68,
            column: 4
          },
          end: {
            line: 71,
            column: 5
          }
        }],
        line: 68
      },
      "5": {
        loc: {
          start: {
            line: 68,
            column: 8
          },
          end: {
            line: 68,
            column: 42
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 68,
            column: 8
          },
          end: {
            line: 68,
            column: 23
          }
        }, {
          start: {
            line: 68,
            column: 27
          },
          end: {
            line: 68,
            column: 42
          }
        }],
        line: 68
      },
      "6": {
        loc: {
          start: {
            line: 76,
            column: 41
          },
          end: {
            line: 76,
            column: 63
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 76,
            column: 41
          },
          end: {
            line: 76,
            column: 50
          }
        }, {
          start: {
            line: 76,
            column: 54
          },
          end: {
            line: 76,
            column: 63
          }
        }],
        line: 76
      },
      "7": {
        loc: {
          start: {
            line: 111,
            column: 4
          },
          end: {
            line: 124,
            column: 5
          }
        },
        type: "switch",
        locations: [{
          start: {
            line: 112,
            column: 6
          },
          end: {
            line: 114,
            column: 14
          }
        }, {
          start: {
            line: 115,
            column: 6
          },
          end: {
            line: 117,
            column: 14
          }
        }, {
          start: {
            line: 118,
            column: 6
          },
          end: {
            line: 120,
            column: 14
          }
        }, {
          start: {
            line: 121,
            column: 6
          },
          end: {
            line: 123,
            column: 14
          }
        }],
        line: 111
      },
      "8": {
        loc: {
          start: {
            line: 125,
            column: 4
          },
          end: {
            line: 129,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 125,
            column: 4
          },
          end: {
            line: 129,
            column: 5
          }
        }, {
          start: {
            line: 125,
            column: 4
          },
          end: {
            line: 129,
            column: 5
          }
        }],
        line: 125
      },
      "9": {
        loc: {
          start: {
            line: 136,
            column: 66
          },
          end: {
            line: 136,
            column: 104
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 136,
            column: 95
          },
          end: {
            line: 136,
            column: 98
          }
        }, {
          start: {
            line: 136,
            column: 101
          },
          end: {
            line: 136,
            column: 104
          }
        }],
        line: 136
      },
      "10": {
        loc: {
          start: {
            line: 156,
            column: 4
          },
          end: {
            line: 158,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 156,
            column: 4
          },
          end: {
            line: 158,
            column: 5
          }
        }, {
          start: {
            line: 156,
            column: 4
          },
          end: {
            line: 158,
            column: 5
          }
        }],
        line: 156
      },
      "11": {
        loc: {
          start: {
            line: 162,
            column: 6
          },
          end: {
            line: 166,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 162,
            column: 6
          },
          end: {
            line: 166,
            column: 7
          }
        }, {
          start: {
            line: 162,
            column: 6
          },
          end: {
            line: 166,
            column: 7
          }
        }],
        line: 162
      },
      "12": {
        loc: {
          start: {
            line: 167,
            column: 6
          },
          end: {
            line: 169,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 167,
            column: 6
          },
          end: {
            line: 169,
            column: 7
          }
        }, {
          start: {
            line: 167,
            column: 6
          },
          end: {
            line: 169,
            column: 7
          }
        }],
        line: 167
      },
      "13": {
        loc: {
          start: {
            line: 167,
            column: 10
          },
          end: {
            line: 167,
            column: 69
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 167,
            column: 10
          },
          end: {
            line: 167,
            column: 31
          }
        }, {
          start: {
            line: 167,
            column: 35
          },
          end: {
            line: 167,
            column: 69
          }
        }],
        line: 167
      },
      "14": {
        loc: {
          start: {
            line: 170,
            column: 21
          },
          end: {
            line: 170,
            column: 43
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 170,
            column: 21
          },
          end: {
            line: 170,
            column: 38
          }
        }, {
          start: {
            line: 170,
            column: 42
          },
          end: {
            line: 170,
            column: 43
          }
        }],
        line: 170
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0,
      "23": 0,
      "24": 0,
      "25": 0,
      "26": 0,
      "27": 0,
      "28": 0,
      "29": 0,
      "30": 0,
      "31": 0,
      "32": 0,
      "33": 0,
      "34": 0,
      "35": 0,
      "36": 0,
      "37": 0,
      "38": 0,
      "39": 0,
      "40": 0,
      "41": 0,
      "42": 0,
      "43": 0,
      "44": 0,
      "45": 0,
      "46": 0,
      "47": 0,
      "48": 0,
      "49": 0,
      "50": 0,
      "51": 0,
      "52": 0,
      "53": 0,
      "54": 0,
      "55": 0,
      "56": 0,
      "57": 0,
      "58": 0,
      "59": 0,
      "60": 0,
      "61": 0,
      "62": 0,
      "63": 0,
      "64": 0,
      "65": 0,
      "66": 0,
      "67": 0,
      "68": 0,
      "69": 0,
      "70": 0,
      "71": 0,
      "72": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0, 0, 0],
      "4": [0, 0],
      "5": [0, 0],
      "6": [0, 0],
      "7": [0, 0, 0, 0],
      "8": [0, 0],
      "9": [0, 0],
      "10": [0, 0],
      "11": [0, 0],
      "12": [0, 0],
      "13": [0, 0],
      "14": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "72c84c1dd0213be758a846891b5bcfbc651d7bdc"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_xq0uwk3n8 = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_xq0uwk3n8();

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }













var Radar = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Radar, _React$Component);

  var _super = _createSuper(Radar);

  function Radar(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Radar);

    cov_xq0uwk3n8().f[0]++;
    cov_xq0uwk3n8().s[0]++;
    _this = _super.call(this, props);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__["default"])(_this), "_onClick", (cov_xq0uwk3n8().s[3]++, function (coords) {
      cov_xq0uwk3n8().f[2]++;
      cov_xq0uwk3n8().s[4]++;

      if (_this.props.editable) {
        cov_xq0uwk3n8().b[0][0]++;
        var shipIndex = (cov_xq0uwk3n8().s[5]++, _this._findShip(coords.x, coords.y));
        cov_xq0uwk3n8().s[6]++;

        if (shipIndex !== -1) {
          cov_xq0uwk3n8().b[1][0]++;
          cov_xq0uwk3n8().s[7]++;

          _this._rotateShip(shipIndex);
        } else {
          cov_xq0uwk3n8().b[1][1]++;
        }
      } else {
        cov_xq0uwk3n8().b[0][1]++;
        cov_xq0uwk3n8().s[8]++;

        _this.props.onClick(coords);
      }
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__["default"])(_this), "_shouldDrag", (cov_xq0uwk3n8().s[9]++, function () {
      cov_xq0uwk3n8().f[3]++;
      cov_xq0uwk3n8().s[10]++;
      return _this.props.editable;
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__["default"])(_this), "_onDrop", (cov_xq0uwk3n8().s[11]++, function (coords) {
      cov_xq0uwk3n8().f[4]++;
      var x = (cov_xq0uwk3n8().s[12]++, Math.round(coords.x));
      var y = (cov_xq0uwk3n8().s[13]++, Math.round(coords.y));
      var originalX = (cov_xq0uwk3n8().s[14]++, coords.originalX);
      var originalY = (cov_xq0uwk3n8().s[15]++, coords.originalY);
      cov_xq0uwk3n8().s[16]++;

      if ((cov_xq0uwk3n8().b[3][0]++, x < 0) || (cov_xq0uwk3n8().b[3][1]++, y < 0) || (cov_xq0uwk3n8().b[3][2]++, x >= 10) || (cov_xq0uwk3n8().b[3][3]++, y >= 10)) {
        cov_xq0uwk3n8().b[2][0]++;
        cov_xq0uwk3n8().s[17]++;
        return;
      } else {
        cov_xq0uwk3n8().b[2][1]++;
      }

      cov_xq0uwk3n8().s[18]++;

      if ((cov_xq0uwk3n8().b[5][0]++, originalX !== x) || (cov_xq0uwk3n8().b[5][1]++, originalY !== y)) {
        cov_xq0uwk3n8().b[4][0]++;
        var shipIndex = (cov_xq0uwk3n8().s[19]++, _this._findShip(originalX, originalY));
        cov_xq0uwk3n8().s[20]++;

        _this._moveShip(shipIndex, x, y);
      } else {
        cov_xq0uwk3n8().b[4][1]++;
      }
    }));

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(Radar, [{
    key: "render",
    value: function render() {
      cov_xq0uwk3n8().f[1]++;
      var result = (cov_xq0uwk3n8().s[1]++, [__jsx(_media_SvgBackground__WEBPACK_IMPORTED_MODULE_15__["default"], {
        onClick: this._onClick,
        key: "background"
      })].concat(this._getShips()).concat(this._getSalvos()));
      cov_xq0uwk3n8().s[2]++;
      return __jsx("div", {
        className: "seabattle-radar"
      }, __jsx(ui__WEBPACK_IMPORTED_MODULE_10__["Grid"], {
        rows: 10,
        cols: 10,
        outline: false,
        onClick: this._onClick
      }, result));
    }
  }, {
    key: "_findShip",
    value: function _findShip(x, y) {
      cov_xq0uwk3n8().f[5]++;
      cov_xq0uwk3n8().s[21]++;
      return this.props.ships.findIndex(function (ship) {
        cov_xq0uwk3n8().f[6]++;
        cov_xq0uwk3n8().s[22]++;
        return ship.cells.findIndex(function (c) {
          cov_xq0uwk3n8().f[7]++;
          cov_xq0uwk3n8().s[23]++;
          return (cov_xq0uwk3n8().b[6][0]++, c.x === x) && (cov_xq0uwk3n8().b[6][1]++, c.y === y);
        }) !== -1;
      });
    }
  }, {
    key: "_moveShip",
    value: function _moveShip(shipIndex, x, y) {
      cov_xq0uwk3n8().f[8]++;
      var ship = (cov_xq0uwk3n8().s[24]++, this.props.ships[shipIndex]);
      var delta = (cov_xq0uwk3n8().s[25]++, Object(_game__WEBPACK_IMPORTED_MODULE_9__["getCellVector"])(ship.cells[1], ship.cells[0]));
      cov_xq0uwk3n8().s[26]++;

      this._setShip(shipIndex, x, y, delta);
    }
  }, {
    key: "_rotateShip",
    value: function _rotateShip(shipIndex) {
      cov_xq0uwk3n8().f[9]++;
      var ship = (cov_xq0uwk3n8().s[27]++, this.props.ships[shipIndex]);
      var delta = (cov_xq0uwk3n8().s[28]++, Object(_game__WEBPACK_IMPORTED_MODULE_9__["getCellVector"])(ship.cells[1], ship.cells[0]));
      var temp = (cov_xq0uwk3n8().s[29]++, delta.x);
      cov_xq0uwk3n8().s[30]++;
      delta.x = delta.y;
      cov_xq0uwk3n8().s[31]++;
      delta.y = temp;
      cov_xq0uwk3n8().s[32]++;

      this._setShip(shipIndex, ship.cells[0].x, ship.cells[0].y, delta);
    }
  }, {
    key: "_setShip",
    value: function _setShip(index, x, y, vector) {
      cov_xq0uwk3n8().f[10]++;
      var ship = (cov_xq0uwk3n8().s[33]++, this.props.ships[index]);
      var newCells = (cov_xq0uwk3n8().s[34]++, []);
      cov_xq0uwk3n8().s[35]++;

      for (var i = (cov_xq0uwk3n8().s[36]++, 0); i < ship.cells.length; i++) {
        cov_xq0uwk3n8().s[37]++;
        newCells.push({
          x: x + vector.x * i,
          y: y + vector.y * i
        });
      }

      var newShips = (cov_xq0uwk3n8().s[38]++, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(this.props.ships));
      cov_xq0uwk3n8().s[39]++;
      newShips[index] = _objectSpread({}, ship, {
        cells: newCells
      });
      cov_xq0uwk3n8().s[40]++;
      this.props.onEdit(newShips);
    }
  }, {
    key: "_getShipDrawing",
    value: function _getShipDrawing(size, rotation) {
      cov_xq0uwk3n8().f[11]++;
      // Drawings from https://github.com/studioromeo/battleship-svgs (MIT license)
      // Used SVGR to transform to react components.
      // https://github.com/smooth-code/svgr
      var ship;
      cov_xq0uwk3n8().s[41]++;

      switch (size) {
        case 2:
          cov_xq0uwk3n8().b[7][0]++;
          cov_xq0uwk3n8().s[42]++;
          ship = __jsx(_media_SvgShip2__WEBPACK_IMPORTED_MODULE_11__["default"], null);
          cov_xq0uwk3n8().s[43]++;
          break;

        case 3:
          cov_xq0uwk3n8().b[7][1]++;
          cov_xq0uwk3n8().s[44]++;
          ship = __jsx(_media_SvgShip3__WEBPACK_IMPORTED_MODULE_12__["default"], null);
          cov_xq0uwk3n8().s[45]++;
          break;

        case 4:
          cov_xq0uwk3n8().b[7][2]++;
          cov_xq0uwk3n8().s[46]++;
          ship = __jsx(_media_SvgShip4__WEBPACK_IMPORTED_MODULE_13__["default"], null);
          cov_xq0uwk3n8().s[47]++;
          break;

        case 5:
          cov_xq0uwk3n8().b[7][3]++;
          cov_xq0uwk3n8().s[48]++;
          ship = __jsx(_media_SvgShip5__WEBPACK_IMPORTED_MODULE_14__["default"], null);
          cov_xq0uwk3n8().s[49]++;
          break;
      }

      cov_xq0uwk3n8().s[50]++;

      if (rotation === 'v') {
        cov_xq0uwk3n8().b[8][0]++;
        cov_xq0uwk3n8().s[51]++;
        return __jsx("g", {
          transform: "translate(1 0) rotate(90)"
        }, ship);
      } else {
        cov_xq0uwk3n8().b[8][1]++;
        cov_xq0uwk3n8().s[52]++;
        return ship;
      }
    }
  }, {
    key: "_getShips",
    value: function _getShips() {
      cov_xq0uwk3n8().f[12]++;
      var result = (cov_xq0uwk3n8().s[53]++, []);
      cov_xq0uwk3n8().s[54]++;

      var _iterator = _createForOfIteratorHelper(this.props.ships),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ship = _step.value;

          var _cell = (cov_xq0uwk3n8().s[55]++, ship.cells[0]);

          var shipDrawing = (cov_xq0uwk3n8().s[56]++, this._getShipDrawing(ship.cells.length, _cell.x === ship.cells[1].x ? (cov_xq0uwk3n8().b[9][0]++, 'v') : (cov_xq0uwk3n8().b[9][1]++, 'h')));
          cov_xq0uwk3n8().s[57]++;
          result.push(__jsx(ui__WEBPACK_IMPORTED_MODULE_10__["Token"], {
            x: _cell.x,
            y: _cell.y,
            draggable: this.props.editable,
            shouldDrag: this._shouldDrag,
            onDrop: this._onDrop,
            key: ship.id
          }, shipDrawing));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      cov_xq0uwk3n8().s[58]++;
      return result;
    }
  }, {
    key: "_getSalvos",
    value: function _getSalvos() {
      cov_xq0uwk3n8().f[13]++;
      var result = (cov_xq0uwk3n8().s[59]++, []);
      cov_xq0uwk3n8().s[60]++;

      if (!this.props.salvos) {
        cov_xq0uwk3n8().b[10][0]++;
        cov_xq0uwk3n8().s[61]++;
        return result;
      } else {
        cov_xq0uwk3n8().b[10][1]++;
      }

      var i = (cov_xq0uwk3n8().s[62]++, 0);
      cov_xq0uwk3n8().s[63]++;

      var _iterator2 = _createForOfIteratorHelper(this.props.salvos),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var salvo = _step2.value;
          var drawing = void 0;
          cov_xq0uwk3n8().s[64]++;

          if (salvo.hit) {
            cov_xq0uwk3n8().b[11][0]++;
            cov_xq0uwk3n8().s[65]++;
            drawing = __jsx(_media_SvgHit__WEBPACK_IMPORTED_MODULE_16__["default"], null);
          } else {
            cov_xq0uwk3n8().b[11][1]++;
            cov_xq0uwk3n8().s[66]++;
            drawing = __jsx(_media_SvgMiss__WEBPACK_IMPORTED_MODULE_17__["default"], null);
          }

          cov_xq0uwk3n8().s[67]++;

          if ((cov_xq0uwk3n8().b[13][0]++, this.props.blinkSalvo) && (cov_xq0uwk3n8().b[13][1]++, i === this.props.salvos.length - 1)) {
            cov_xq0uwk3n8().b[12][0]++;
            cov_xq0uwk3n8().s[68]++;
            drawing = __jsx(components_App_Blink__WEBPACK_IMPORTED_MODULE_18__["Blink"], null, drawing);
          } else {
            cov_xq0uwk3n8().b[12][1]++;
          }

          var player = (cov_xq0uwk3n8().s[69]++, (cov_xq0uwk3n8().b[14][0]++, this.props.player) || (cov_xq0uwk3n8().b[14][1]++, 0));
          cov_xq0uwk3n8().s[70]++;
          result.push(__jsx(ui__WEBPACK_IMPORTED_MODULE_10__["Token"], {
            x: salvo.cell.x,
            y: salvo.cell.y,
            draggable: false,
            key: "salvo_".concat(i, "_").concat(player)
          }, drawing));
          cov_xq0uwk3n8().s[71]++;
          i++;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      cov_xq0uwk3n8().s[72]++;
      return result;
    }
  }]);

  return Radar;
}((react__WEBPACK_IMPORTED_MODULE_8___default.a.Component));

/***/ }),

/***/ "./src/games/seabattle/ShipsPlacement.tsx":
/*!************************************************!*\
  !*** ./src/games/seabattle/ShipsPlacement.tsx ***!
  \************************************************/
/*! exports provided: ShipsPlacement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShipsPlacement", function() { return ShipsPlacement; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _material_ui_core_Button__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @material-ui/core/Button */ "./node_modules/@material-ui/core/esm/Button/index.js");
/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./game */ "./src/games/seabattle/game.ts");
/* harmony import */ var _Radar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Radar */ "./src/games/seabattle/Radar.tsx");
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @material-ui/core/Typography */ "./node_modules/@material-ui/core/esm/Typography/index.js");







var __jsx = react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement;

function cov_21j3sakrae() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/ShipsPlacement.tsx";
  var hash = "696edd0af67f48ef9e3aefc48a6ac09f9e10cc8d";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/ShipsPlacement.tsx",
    statementMap: {
      "0": {
        start: {
          line: 18,
          column: 21
        },
        end: {
          line: 21,
          column: 3
        }
      },
      "1": {
        start: {
          line: 23,
          column: 4
        },
        end: {
          line: 23,
          column: 17
        }
      },
      "2": {
        start: {
          line: 24,
          column: 4
        },
        end: {
          line: 24,
          column: 72
        }
      },
      "3": {
        start: {
          line: 28,
          column: 18
        },
        end: {
          line: 28,
          column: 48
        }
      },
      "4": {
        start: {
          line: 29,
          column: 23
        },
        end: {
          line: 29,
          column: 60
        }
      },
      "5": {
        start: {
          line: 30,
          column: 4
        },
        end: {
          line: 32,
          column: 5
        }
      },
      "6": {
        start: {
          line: 31,
          column: 6
        },
        end: {
          line: 31,
          column: 38
        }
      },
      "7": {
        start: {
          line: 33,
          column: 4
        },
        end: {
          line: 49,
          column: 6
        }
      },
      "8": {
        start: {
          line: 52,
          column: 11
        },
        end: {
          line: 56,
          column: 3
        }
      },
      "9": {
        start: {
          line: 53,
          column: 4
        },
        end: {
          line: 55,
          column: 7
        }
      },
      "10": {
        start: {
          line: 58,
          column: 9
        },
        end: {
          line: 60,
          column: 3
        }
      },
      "11": {
        start: {
          line: 59,
          column: 4
        },
        end: {
          line: 59,
          column: 42
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 22,
            column: 2
          },
          end: {
            line: 22,
            column: 3
          }
        },
        loc: {
          start: {
            line: 22,
            column: 43
          },
          end: {
            line: 25,
            column: 3
          }
        },
        line: 22
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 27,
            column: 2
          },
          end: {
            line: 27,
            column: 3
          }
        },
        loc: {
          start: {
            line: 27,
            column: 11
          },
          end: {
            line: 50,
            column: 3
          }
        },
        line: 27
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 52,
            column: 11
          },
          end: {
            line: 52,
            column: 12
          }
        },
        loc: {
          start: {
            line: 52,
            column: 31
          },
          end: {
            line: 56,
            column: 3
          }
        },
        line: 52
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 58,
            column: 9
          },
          end: {
            line: 58,
            column: 10
          }
        },
        loc: {
          start: {
            line: 58,
            column: 15
          },
          end: {
            line: 60,
            column: 3
          }
        },
        line: 58
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 30,
            column: 4
          },
          end: {
            line: 32,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 30,
            column: 4
          },
          end: {
            line: 32,
            column: 5
          }
        }, {
          start: {
            line: 30,
            column: 4
          },
          end: {
            line: 32,
            column: 5
          }
        }],
        line: 30
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0
    },
    b: {
      "0": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "696edd0af67f48ef9e3aefc48a6ac09f9e10cc8d"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_21j3sakrae = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_21j3sakrae();

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }







var ShipsPlacement = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(ShipsPlacement, _React$Component);

  var _super = _createSuper(ShipsPlacement);

  function ShipsPlacement(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ShipsPlacement);

    cov_21j3sakrae().f[0]++;
    cov_21j3sakrae().s[1]++;
    _this = _super.call(this, props);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "onEdit", (cov_21j3sakrae().s[8]++, function (ships) {
      cov_21j3sakrae().f[2]++;
      cov_21j3sakrae().s[9]++;

      _this.setState({
        ships: ships
      });
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "done", (cov_21j3sakrae().s[10]++, function () {
      cov_21j3sakrae().f[3]++;
      cov_21j3sakrae().s[11]++;

      _this.props.setShips(_this.state.ships);
    }));

    cov_21j3sakrae().s[2]++;
    _this.state = {
      ships: Object(_game__WEBPACK_IMPORTED_MODULE_10__["generateRandomShips"])(Number(props.playerID))
    };
    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ShipsPlacement, [{
    key: "render",
    value: function render() {
      cov_21j3sakrae().f[1]++;
      var message = (cov_21j3sakrae().s[3]++, 'Drag & drop, click to rotate');
      var validShips = (cov_21j3sakrae().s[4]++, Object(_game__WEBPACK_IMPORTED_MODULE_10__["validateShips"])(this.state.ships).valid);
      cov_21j3sakrae().s[5]++;

      if (!validShips) {
        cov_21j3sakrae().b[0][0]++;
        cov_21j3sakrae().s[6]++;
        message = 'INVALID POSITIONING';
      } else {
        cov_21j3sakrae().b[0][1]++;
      }

      cov_21j3sakrae().s[7]++;
      return __jsx("div", null, __jsx(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_12__["default"], {
        variant: "h5",
        style: {
          textAlign: 'center',
          color: 'white',
          marginBottom: '16px'
        }
      }, message), __jsx(_Radar__WEBPACK_IMPORTED_MODULE_11__["Radar"], {
        ships: this.state.ships,
        editable: true,
        onEdit: this.onEdit
      }), __jsx(_material_ui_core_Button__WEBPACK_IMPORTED_MODULE_9__["default"], {
        style: {
          "float": 'right',
          marginTop: '8px'
        },
        variant: "contained",
        color: "primary",
        onClick: this.done,
        disabled: !validShips
      }, "Done"));
    }
  }]);

  return ShipsPlacement;
}((react__WEBPACK_IMPORTED_MODULE_7___default.a.Component));

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(ShipsPlacement, "propTypes", (cov_21j3sakrae().s[0]++, {
  playerID: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.string,
  setShips: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.any
}));

/***/ }),

/***/ "./src/games/seabattle/board.tsx":
/*!***************************************!*\
  !*** ./src/games/seabattle/board.tsx ***!
  \***************************************/
/*! exports provided: Board */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Board", function() { return Board; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _ShipsPlacement__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ShipsPlacement */ "./src/games/seabattle/ShipsPlacement.tsx");
/* harmony import */ var components_App_Game_GameLayout__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! components/App/Game/GameLayout */ "./src/components/App/Game/GameLayout.tsx");
/* harmony import */ var _Battle__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Battle */ "./src/games/seabattle/Battle.tsx");
/* harmony import */ var _Radar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Radar */ "./src/games/seabattle/Radar.tsx");
/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @material-ui/core/Typography */ "./node_modules/@material-ui/core/esm/Typography/index.js");
/* harmony import */ var games_common_gameMode__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! games/common/gameMode */ "./src/games/common/gameMode.ts");







var __jsx = react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement;

function cov_2l65tzy772() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/board.tsx";
  var hash = "f455d8a32b860412cc36e8fec6dd7cee81d912c9";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/board.tsx",
    statementMap: {
      "0": {
        start: {
          line: 30,
          column: 4
        },
        end: {
          line: 30,
          column: 24
        }
      },
      "1": {
        start: {
          line: 31,
          column: 4
        },
        end: {
          line: 33,
          column: 6
        }
      },
      "2": {
        start: {
          line: 37,
          column: 16
        },
        end: {
          line: 37,
          column: 30
        }
      },
      "3": {
        start: {
          line: 38,
          column: 4
        },
        end: {
          line: 53,
          column: 5
        }
      },
      "4": {
        start: {
          line: 39,
          column: 21
        },
        end: {
          line: 39,
          column: 89
        }
      },
      "5": {
        start: {
          line: 40,
          column: 21
        },
        end: {
          line: 40,
          column: 48
        }
      },
      "6": {
        start: {
          line: 41,
          column: 26
        },
        end: {
          line: 41,
          column: 46
        }
      },
      "7": {
        start: {
          line: 42,
          column: 31
        },
        end: {
          line: 42,
          column: 101
        }
      },
      "8": {
        start: {
          line: 42,
          column: 77
        },
        end: {
          line: 42,
          column: 100
        }
      },
      "9": {
        start: {
          line: 43,
          column: 29
        },
        end: {
          line: 43,
          column: 98
        }
      },
      "10": {
        start: {
          line: 43,
          column: 70
        },
        end: {
          line: 43,
          column: 97
        }
      },
      "11": {
        start: {
          line: 45,
          column: 8
        },
        end: {
          line: 50,
          column: 14
        }
      },
      "12": {
        start: {
          line: 52,
          column: 6
        },
        end: {
          line: 52,
          column: 113
        }
      },
      "13": {
        start: {
          line: 55,
          column: 4
        },
        end: {
          line: 80,
          column: 5
        }
      },
      "14": {
        start: {
          line: 61,
          column: 6
        },
        end: {
          line: 61,
          column: 90
        }
      },
      "15": {
        start: {
          line: 62,
          column: 11
        },
        end: {
          line: 80,
          column: 5
        }
      },
      "16": {
        start: {
          line: 63,
          column: 6
        },
        end: {
          line: 67,
          column: 8
        }
      },
      "17": {
        start: {
          line: 69,
          column: 6
        },
        end: {
          line: 79,
          column: 8
        }
      },
      "18": {
        start: {
          line: 81,
          column: 4
        },
        end: {
          line: 85,
          column: 6
        }
      },
      "19": {
        start: {
          line: 88,
          column: 18
        },
        end: {
          line: 92,
          column: 3
        }
      },
      "20": {
        start: {
          line: 89,
          column: 4
        },
        end: {
          line: 91,
          column: 7
        }
      },
      "21": {
        start: {
          line: 90,
          column: 6
        },
        end: {
          line: 90,
          column: 43
        }
      },
      "22": {
        start: {
          line: 94,
          column: 21
        },
        end: {
          line: 96,
          column: 3
        }
      },
      "23": {
        start: {
          line: 95,
          column: 4
        },
        end: {
          line: 95,
          column: 46
        }
      },
      "24": {
        start: {
          line: 98,
          column: 18
        },
        end: {
          line: 100,
          column: 3
        }
      },
      "25": {
        start: {
          line: 99,
          column: 4
        },
        end: {
          line: 99,
          column: 35
        }
      },
      "26": {
        start: {
          line: 102,
          column: 25
        },
        end: {
          line: 111,
          column: 3
        }
      },
      "27": {
        start: {
          line: 103,
          column: 25
        },
        end: {
          line: 103,
          column: 45
        }
      },
      "28": {
        start: {
          line: 104,
          column: 25
        },
        end: {
          line: 104,
          column: 38
        }
      },
      "29": {
        start: {
          line: 105,
          column: 34
        },
        end: {
          line: 108,
          column: 5
        }
      },
      "30": {
        start: {
          line: 109,
          column: 20
        },
        end: {
          line: 109,
          column: 28
        }
      },
      "31": {
        start: {
          line: 110,
          column: 4
        },
        end: {
          line: 110,
          column: 19
        }
      },
      "32": {
        start: {
          line: 113,
          column: 14
        },
        end: {
          line: 115,
          column: 3
        }
      },
      "33": {
        start: {
          line: 114,
          column: 4
        },
        end: {
          line: 114,
          column: 37
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 29,
            column: 2
          },
          end: {
            line: 29,
            column: 3
          }
        },
        loc: {
          start: {
            line: 29,
            column: 54
          },
          end: {
            line: 34,
            column: 3
          }
        },
        line: 29
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 36,
            column: 2
          },
          end: {
            line: 36,
            column: 3
          }
        },
        loc: {
          start: {
            line: 36,
            column: 11
          },
          end: {
            line: 86,
            column: 3
          }
        },
        line: 36
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 42,
            column: 58
          },
          end: {
            line: 42,
            column: 59
          }
        },
        loc: {
          start: {
            line: 42,
            column: 77
          },
          end: {
            line: 42,
            column: 100
          }
        },
        line: 42
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 43,
            column: 55
          },
          end: {
            line: 43,
            column: 56
          }
        },
        loc: {
          start: {
            line: 43,
            column: 70
          },
          end: {
            line: 43,
            column: 97
          }
        },
        line: 43
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 88,
            column: 18
          },
          end: {
            line: 88,
            column: 19
          }
        },
        loc: {
          start: {
            line: 88,
            column: 45
          },
          end: {
            line: 92,
            column: 3
          }
        },
        line: 88
      },
      "5": {
        name: "(anonymous_5)",
        decl: {
          start: {
            line: 89,
            column: 18
          },
          end: {
            line: 89,
            column: 19
          }
        },
        loc: {
          start: {
            line: 89,
            column: 32
          },
          end: {
            line: 91,
            column: 5
          }
        },
        line: 89
      },
      "6": {
        name: "(anonymous_6)",
        decl: {
          start: {
            line: 94,
            column: 21
          },
          end: {
            line: 94,
            column: 22
          }
        },
        loc: {
          start: {
            line: 94,
            column: 27
          },
          end: {
            line: 96,
            column: 3
          }
        },
        line: 94
      },
      "7": {
        name: "(anonymous_7)",
        decl: {
          start: {
            line: 98,
            column: 18
          },
          end: {
            line: 98,
            column: 19
          }
        },
        loc: {
          start: {
            line: 98,
            column: 24
          },
          end: {
            line: 100,
            column: 3
          }
        },
        line: 98
      },
      "8": {
        name: "(anonymous_8)",
        decl: {
          start: {
            line: 102,
            column: 25
          },
          end: {
            line: 102,
            column: 26
          }
        },
        loc: {
          start: {
            line: 102,
            column: 31
          },
          end: {
            line: 111,
            column: 3
          }
        },
        line: 102
      },
      "9": {
        name: "(anonymous_9)",
        decl: {
          start: {
            line: 113,
            column: 14
          },
          end: {
            line: 113,
            column: 15
          }
        },
        loc: {
          start: {
            line: 113,
            column: 34
          },
          end: {
            line: 115,
            column: 3
          }
        },
        line: 113
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 38,
            column: 4
          },
          end: {
            line: 53,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 38,
            column: 4
          },
          end: {
            line: 53,
            column: 5
          }
        }, {
          start: {
            line: 38,
            column: 4
          },
          end: {
            line: 53,
            column: 5
          }
        }],
        line: 38
      },
      "1": {
        loc: {
          start: {
            line: 39,
            column: 21
          },
          end: {
            line: 39,
            column: 89
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 39,
            column: 67
          },
          end: {
            line: 39,
            column: 76
          }
        }, {
          start: {
            line: 39,
            column: 79
          },
          end: {
            line: 39,
            column: 89
          }
        }],
        line: 39
      },
      "2": {
        loc: {
          start: {
            line: 41,
            column: 26
          },
          end: {
            line: 41,
            column: 46
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 41,
            column: 41
          },
          end: {
            line: 41,
            column: 42
          }
        }, {
          start: {
            line: 41,
            column: 45
          },
          end: {
            line: 41,
            column: 46
          }
        }],
        line: 41
      },
      "3": {
        loc: {
          start: {
            line: 55,
            column: 4
          },
          end: {
            line: 80,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 55,
            column: 4
          },
          end: {
            line: 80,
            column: 5
          }
        }, {
          start: {
            line: 55,
            column: 4
          },
          end: {
            line: 80,
            column: 5
          }
        }],
        line: 55
      },
      "4": {
        loc: {
          start: {
            line: 56,
            column: 6
          },
          end: {
            line: 59,
            column: 66
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 56,
            column: 6
          },
          end: {
            line: 56,
            column: 27
          }
        }, {
          start: {
            line: 57,
            column: 6
          },
          end: {
            line: 57,
            column: 34
          }
        }, {
          start: {
            line: 58,
            column: 6
          },
          end: {
            line: 58,
            column: 32
          }
        }, {
          start: {
            line: 59,
            column: 6
          },
          end: {
            line: 59,
            column: 66
          }
        }],
        line: 56
      },
      "5": {
        loc: {
          start: {
            line: 62,
            column: 11
          },
          end: {
            line: 80,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 62,
            column: 11
          },
          end: {
            line: 80,
            column: 5
          }
        }, {
          start: {
            line: 62,
            column: 11
          },
          end: {
            line: 80,
            column: 5
          }
        }],
        line: 62
      },
      "6": {
        loc: {
          start: {
            line: 107,
            column: 15
          },
          end: {
            line: 107,
            column: 50
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 107,
            column: 30
          },
          end: {
            line: 107,
            column: 38
          }
        }, {
          start: {
            line: 107,
            column: 41
          },
          end: {
            line: 107,
            column: 50
          }
        }],
        line: 107
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0,
      "23": 0,
      "24": 0,
      "25": 0,
      "26": 0,
      "27": 0,
      "28": 0,
      "29": 0,
      "30": 0,
      "31": 0,
      "32": 0,
      "33": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0],
      "4": [0, 0, 0, 0],
      "5": [0, 0],
      "6": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "f455d8a32b860412cc36e8fec6dd7cee81d912c9"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2l65tzy772 = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2l65tzy772();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }








var Board = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Board, _React$Component);

  var _super = _createSuper(Board);

  function Board(props, state) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Board);

    cov_2l65tzy772().f[0]++;
    cov_2l65tzy772().s[0]++;
    _this = _super.call(this, props, state);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_setSoundPref", (cov_2l65tzy772().s[19]++, function (soundEnabled) {
      cov_2l65tzy772().f[4]++;
      cov_2l65tzy772().s[20]++;

      _this.setState(function (oldState) {
        cov_2l65tzy772().f[5]++;
        cov_2l65tzy772().s[21]++;
        return _objectSpread({}, oldState, {
          soundEnabled: soundEnabled
        });
      });
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_toggleSoundPref", (cov_2l65tzy772().s[22]++, function () {
      cov_2l65tzy772().f[6]++;
      cov_2l65tzy772().s[23]++;

      _this._setSoundPref(!_this._getSoundPref());
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_getSoundPref", (cov_2l65tzy772().s[24]++, function () {
      cov_2l65tzy772().f[7]++;
      cov_2l65tzy772().s[25]++;
      return _this.state.soundEnabled;
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_getOptionsMenuItems", (cov_2l65tzy772().s[26]++, function () {
      cov_2l65tzy772().f[8]++;
      var curSoundPref = (cov_2l65tzy772().s[27]++, _this._getSoundPref());
      var newSoundPref = (cov_2l65tzy772().s[28]++, !curSoundPref);
      var option = (cov_2l65tzy772().s[29]++, {
        onClick: _this._toggleSoundPref,
        text: "".concat(newSoundPref ? (cov_2l65tzy772().b[6][0]++, 'Enable') : (cov_2l65tzy772().b[6][1]++, 'Disable'), " sound")
      });
      var options = (cov_2l65tzy772().s[30]++, [option]);
      cov_2l65tzy772().s[31]++;
      return options;
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_setShips", (cov_2l65tzy772().s[32]++, function (ships) {
      cov_2l65tzy772().f[9]++;
      cov_2l65tzy772().s[33]++;

      _this.props.moves.setShips(ships);
    }));

    cov_2l65tzy772().s[1]++;
    _this.state = {
      soundEnabled: true
    };
    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Board, [{
    key: "render",
    value: function render() {
      cov_2l65tzy772().f[1]++;
      var ctx = (cov_2l65tzy772().s[2]++, this.props.ctx);
      cov_2l65tzy772().s[3]++;

      if (ctx.gameover) {
        cov_2l65tzy772().b[0][0]++;
        var result = (cov_2l65tzy772().s[4]++, ctx.gameover.winner === this.props.playerID ? (cov_2l65tzy772().b[1][0]++, 'you won') : (cov_2l65tzy772().b[1][1]++, 'you lost'));
        var player = (cov_2l65tzy772().s[5]++, Number(this.props.playerID));
        var otherPlayer = (cov_2l65tzy772().s[6]++, player === 0 ? (cov_2l65tzy772().b[2][0]++, 1) : (cov_2l65tzy772().b[2][1]++, 0));
        var salvos = (cov_2l65tzy772().s[7]++, this.props.G.salvos.filter(function (salvo) {
          cov_2l65tzy772().f[2]++;
          cov_2l65tzy772().s[8]++;
          return salvo.player === player;
        }));
        var ships = (cov_2l65tzy772().s[9]++, this.props.G.ships.filter(function (ship) {
          cov_2l65tzy772().f[3]++;
          cov_2l65tzy772().s[10]++;
          return ship.player === otherPlayer;
        }));
        var extraCardContent = (cov_2l65tzy772().s[11]++, __jsx("div", null, __jsx(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_12__["default"], {
          variant: "h6",
          align: "center",
          style: {
            marginTop: '0px',
            marginBottom: '16px'
          }
        }, "Your Opponent's Board"), __jsx(_Radar__WEBPACK_IMPORTED_MODULE_11__["Radar"], {
          player: player,
          ships: ships,
          salvos: salvos,
          editable: false
        })));
        cov_2l65tzy772().s[12]++;
        return __jsx(components_App_Game_GameLayout__WEBPACK_IMPORTED_MODULE_9__["GameLayout"], {
          gameOver: result,
          extraCardContent: extraCardContent,
          gameArgs: this.props.gameArgs
        });
      } else {
        cov_2l65tzy772().b[0][1]++;
      }

      var child;
      cov_2l65tzy772().s[13]++;

      if ((cov_2l65tzy772().b[4][0]++, ctx.phase === 'setup') && (cov_2l65tzy772().b[4][1]++, this.props.playerID !== null) && (cov_2l65tzy772().b[4][2]++, ctx.activePlayers !== null) && (cov_2l65tzy772().b[4][3]++, Object.keys(ctx.activePlayers).includes(this.props.playerID))) {
        cov_2l65tzy772().b[3][0]++;
        cov_2l65tzy772().s[14]++;
        child = __jsx(_ShipsPlacement__WEBPACK_IMPORTED_MODULE_8__["ShipsPlacement"], {
          playerID: this.props.playerID,
          setShips: this._setShips
        });
      } else {
        cov_2l65tzy772().b[3][1]++;
        cov_2l65tzy772().s[15]++;

        if (ctx.phase === 'setup') {
          cov_2l65tzy772().b[5][0]++;
          cov_2l65tzy772().s[16]++;
          child = __jsx(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_12__["default"], {
            variant: "h4",
            style: {
              color: 'white'
            }
          }, "Waiting for opponent...");
        } else {
          cov_2l65tzy772().b[5][1]++;
          cov_2l65tzy772().s[17]++;
          child = __jsx(_Battle__WEBPACK_IMPORTED_MODULE_10__["Battle"], {
            ctx: ctx,
            G: this.props.G,
            moves: this.props.moves,
            playerID: this.props.playerID,
            currentPlayer: ctx.currentPlayer,
            isAIGame: Object(games_common_gameMode__WEBPACK_IMPORTED_MODULE_13__["isAIGame"])(this.props.gameArgs),
            getSoundPref: this._getSoundPref
          });
        }
      }

      cov_2l65tzy772().s[18]++;
      return __jsx(components_App_Game_GameLayout__WEBPACK_IMPORTED_MODULE_9__["GameLayout"], {
        optionsMenuItems: this._getOptionsMenuItems,
        gameArgs: this.props.gameArgs
      }, child);
    }
  }]);

  return Board;
}((react__WEBPACK_IMPORTED_MODULE_7___default.a.Component));

/***/ }),

/***/ "./src/games/seabattle/config.ts":
/*!***************************************!*\
  !*** ./src/games/seabattle/config.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ "./src/games/seabattle/game.ts");
/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board */ "./src/games/seabattle/board.tsx");
function cov_1x64odt6tk() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/config.ts";
  var hash = "0b03affb611697f1beeb41839f44c6738a88db93";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/config.ts",
    statementMap: {
      "0": {
        start: {
          line: 5,
          column: 28
        },
        end: {
          line: 9,
          column: 1
        }
      }
    },
    fnMap: {},
    branchMap: {},
    s: {
      "0": 0
    },
    f: {},
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "0b03affb611697f1beeb41839f44c6738a88db93"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_1x64odt6tk = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_1x64odt6tk();


var config = (cov_1x64odt6tk().s[0]++, {
  bgioGame: _game__WEBPACK_IMPORTED_MODULE_0__["SeabattleGame"],
  bgioBoard: _board__WEBPACK_IMPORTED_MODULE_1__["Board"],
  enhancers: []
});
/* harmony default export */ __webpack_exports__["default"] = (config);

/***/ }),

/***/ "./src/games/seabattle/game.ts":
/*!*************************************!*\
  !*** ./src/games/seabattle/game.ts ***!
  \*************************************/
/*! exports provided: playerView, SeabattleGame, generateRandomShips, validateShips, getCellVector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "playerView", function() { return playerView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SeabattleGame", function() { return SeabattleGame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateRandomShips", function() { return generateRandomShips; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateShips", function() { return validateShips; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCellVector", function() { return getCellVector; });
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var boardgame_io_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! boardgame.io/core */ "./node_modules/boardgame.io/dist/esm/core.js");
/* harmony import */ var shortid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
/* harmony import */ var shortid__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(shortid__WEBPACK_IMPORTED_MODULE_3__);



function cov_2rmfy6gvhj() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/game.ts";
  var hash = "106f2512b460b9a2154489996c028fb2dd27e1ae";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/game.ts",
    statementMap: {
      "0": {
        start: {
          line: 32,
          column: 36
        },
        end: {
          line: 32,
          column: 48
        }
      },
      "1": {
        start: {
          line: 33,
          column: 54
        },
        end: {
          line: 38,
          column: 1
        }
      },
      "2": {
        start: {
          line: 40,
          column: 26
        },
        end: {
          line: 47,
          column: 1
        }
      },
      "3": {
        start: {
          line: 41,
          column: 17
        },
        end: {
          line: 41,
          column: 39
        }
      },
      "4": {
        start: {
          line: 42,
          column: 25
        },
        end: {
          line: 42,
          column: 86
        }
      },
      "5": {
        start: {
          line: 42,
          column: 50
        },
        end: {
          line: 42,
          column: 85
        }
      },
      "6": {
        start: {
          line: 43,
          column: 2
        },
        end: {
          line: 46,
          column: 4
        }
      },
      "7": {
        start: {
          line: 50,
          column: 17
        },
        end: {
          line: 50,
          column: 43
        }
      },
      "8": {
        start: {
          line: 51,
          column: 21
        },
        end: {
          line: 51,
          column: 49
        }
      },
      "9": {
        start: {
          line: 52,
          column: 2
        },
        end: {
          line: 54,
          column: 3
        }
      },
      "10": {
        start: {
          line: 53,
          column: 4
        },
        end: {
          line: 53,
          column: 38
        }
      },
      "11": {
        start: {
          line: 56,
          column: 2
        },
        end: {
          line: 56,
          column: 49
        }
      },
      "12": {
        start: {
          line: 60,
          column: 17
        },
        end: {
          line: 60,
          column: 43
        }
      },
      "13": {
        start: {
          line: 61,
          column: 20
        },
        end: {
          line: 61,
          column: 63
        }
      },
      "14": {
        start: {
          line: 64,
          column: 4
        },
        end: {
          line: 64,
          column: 112
        }
      },
      "15": {
        start: {
          line: 64,
          column: 31
        },
        end: {
          line: 64,
          column: 98
        }
      },
      "16": {
        start: {
          line: 65,
          column: 2
        },
        end: {
          line: 67,
          column: 3
        }
      },
      "17": {
        start: {
          line: 66,
          column: 4
        },
        end: {
          line: 66,
          column: 20
        }
      },
      "18": {
        start: {
          line: 68,
          column: 2
        },
        end: {
          line: 71,
          column: 3
        }
      },
      "19": {
        start: {
          line: 70,
          column: 4
        },
        end: {
          line: 70,
          column: 83
        }
      },
      "20": {
        start: {
          line: 72,
          column: 15
        },
        end: {
          line: 72,
          column: 33
        }
      },
      "21": {
        start: {
          line: 74,
          column: 19
        },
        end: {
          line: 74,
          column: 31
        }
      },
      "22": {
        start: {
          line: 75,
          column: 2
        },
        end: {
          line: 77,
          column: 3
        }
      },
      "23": {
        start: {
          line: 76,
          column: 4
        },
        end: {
          line: 76,
          column: 65
        }
      },
      "24": {
        start: {
          line: 78,
          column: 2
        },
        end: {
          line: 82,
          column: 4
        }
      },
      "25": {
        start: {
          line: 85,
          column: 40
        },
        end: {
          line: 125,
          column: 1
        }
      },
      "26": {
        start: {
          line: 88,
          column: 33
        },
        end: {
          line: 91,
          column: 3
        }
      },
      "27": {
        start: {
          line: 101,
          column: 10
        },
        end: {
          line: 103,
          column: 11
        }
      },
      "28": {
        start: {
          line: 102,
          column: 12
        },
        end: {
          line: 102,
          column: 34
        }
      },
      "29": {
        start: {
          line: 112,
          column: 4
        },
        end: {
          line: 119,
          column: 5
        }
      },
      "30": {
        start: {
          line: 113,
          column: 6
        },
        end: {
          line: 115,
          column: 7
        }
      },
      "31": {
        start: {
          line: 114,
          column: 8
        },
        end: {
          line: 114,
          column: 31
        }
      },
      "32": {
        start: {
          line: 116,
          column: 6
        },
        end: {
          line: 118,
          column: 7
        }
      },
      "33": {
        start: {
          line: 117,
          column: 8
        },
        end: {
          line: 117,
          column: 31
        }
      },
      "34": {
        start: {
          line: 131,
          column: 2
        },
        end: {
          line: 140,
          column: 49
        }
      },
      "35": {
        start: {
          line: 132,
          column: 4
        },
        end: {
          line: 132,
          column: 16
        }
      },
      "36": {
        start: {
          line: 133,
          column: 4
        },
        end: {
          line: 139,
          column: 5
        }
      },
      "37": {
        start: {
          line: 134,
          column: 28
        },
        end: {
          line: 134,
          column: 55
        }
      },
      "38": {
        start: {
          line: 135,
          column: 6
        },
        end: {
          line: 138,
          column: 7
        }
      },
      "39": {
        start: {
          line: 135,
          column: 19
        },
        end: {
          line: 135,
          column: 20
        }
      },
      "40": {
        start: {
          line: 136,
          column: 8
        },
        end: {
          line: 136,
          column: 36
        }
      },
      "41": {
        start: {
          line: 137,
          column: 8
        },
        end: {
          line: 137,
          column: 63
        }
      },
      "42": {
        start: {
          line: 141,
          column: 2
        },
        end: {
          line: 141,
          column: 16
        }
      },
      "43": {
        start: {
          line: 146,
          column: 22
        },
        end: {
          line: 152,
          column: 3
        }
      },
      "44": {
        start: {
          line: 153,
          column: 2
        },
        end: {
          line: 155,
          column: 3
        }
      },
      "45": {
        start: {
          line: 154,
          column: 4
        },
        end: {
          line: 154,
          column: 60
        }
      },
      "46": {
        start: {
          line: 156,
          column: 2
        },
        end: {
          line: 160,
          column: 3
        }
      },
      "47": {
        start: {
          line: 157,
          column: 4
        },
        end: {
          line: 159,
          column: 5
        }
      },
      "48": {
        start: {
          line: 158,
          column: 6
        },
        end: {
          line: 158,
          column: 24
        }
      },
      "49": {
        start: {
          line: 161,
          column: 2
        },
        end: {
          line: 161,
          column: 25
        }
      },
      "50": {
        start: {
          line: 166,
          column: 2
        },
        end: {
          line: 170,
          column: 3
        }
      },
      "51": {
        start: {
          line: 167,
          column: 4
        },
        end: {
          line: 169,
          column: 5
        }
      },
      "52": {
        start: {
          line: 168,
          column: 6
        },
        end: {
          line: 168,
          column: 19
        }
      },
      "53": {
        start: {
          line: 171,
          column: 2
        },
        end: {
          line: 171,
          column: 14
        }
      },
      "54": {
        start: {
          line: 175,
          column: 22
        },
        end: {
          line: 175,
          column: 66
        }
      },
      "55": {
        start: {
          line: 176,
          column: 20
        },
        end: {
          line: 176,
          column: 53
        }
      },
      "56": {
        start: {
          line: 177,
          column: 22
        },
        end: {
          line: 177,
          column: 60
        }
      },
      "57": {
        start: {
          line: 178,
          column: 2
        },
        end: {
          line: 186,
          column: 3
        }
      },
      "58": {
        start: {
          line: 178,
          column: 15
        },
        end: {
          line: 178,
          column: 16
        }
      },
      "59": {
        start: {
          line: 179,
          column: 4
        },
        end: {
          line: 185,
          column: 5
        }
      },
      "60": {
        start: {
          line: 181,
          column: 6
        },
        end: {
          line: 181,
          column: 50
        }
      },
      "61": {
        start: {
          line: 184,
          column: 6
        },
        end: {
          line: 184,
          column: 50
        }
      },
      "62": {
        start: {
          line: 187,
          column: 2
        },
        end: {
          line: 187,
          column: 14
        }
      },
      "63": {
        start: {
          line: 191,
          column: 2
        },
        end: {
          line: 191,
          column: 43
        }
      },
      "64": {
        start: {
          line: 195,
          column: 2
        },
        end: {
          line: 197,
          column: 4
        }
      },
      "65": {
        start: {
          line: 196,
          column: 14
        },
        end: {
          line: 196,
          column: 108
        }
      },
      "66": {
        start: {
          line: 196,
          column: 42
        },
        end: {
          line: 196,
          column: 74
        }
      },
      "67": {
        start: {
          line: 201,
          column: 2
        },
        end: {
          line: 201,
          column: 59
        }
      },
      "68": {
        start: {
          line: 201,
          column: 30
        },
        end: {
          line: 201,
          column: 50
        }
      },
      "69": {
        start: {
          line: 210,
          column: 22
        },
        end: {
          line: 210,
          column: 67
        }
      },
      "70": {
        start: {
          line: 210,
          column: 49
        },
        end: {
          line: 210,
          column: 66
        }
      },
      "71": {
        start: {
          line: 211,
          column: 43
        },
        end: {
          line: 211,
          column: 67
        }
      },
      "72": {
        start: {
          line: 212,
          column: 2
        },
        end: {
          line: 217,
          column: 3
        }
      },
      "73": {
        start: {
          line: 213,
          column: 4
        },
        end: {
          line: 215,
          column: 5
        }
      },
      "74": {
        start: {
          line: 214,
          column: 6
        },
        end: {
          line: 214,
          column: 71
        }
      },
      "75": {
        start: {
          line: 216,
          column: 4
        },
        end: {
          line: 216,
          column: 20
        }
      },
      "76": {
        start: {
          line: 218,
          column: 2
        },
        end: {
          line: 222,
          column: 3
        }
      },
      "77": {
        start: {
          line: 219,
          column: 4
        },
        end: {
          line: 221,
          column: 5
        }
      },
      "78": {
        start: {
          line: 220,
          column: 6
        },
        end: {
          line: 220,
          column: 61
        }
      },
      "79": {
        start: {
          line: 223,
          column: 2
        },
        end: {
          line: 223,
          column: 25
        }
      },
      "80": {
        start: {
          line: 227,
          column: 17
        },
        end: {
          line: 227,
          column: 56
        }
      },
      "81": {
        start: {
          line: 227,
          column: 44
        },
        end: {
          line: 227,
          column: 55
        }
      },
      "82": {
        start: {
          line: 228,
          column: 2
        },
        end: {
          line: 232,
          column: 3
        }
      },
      "83": {
        start: {
          line: 229,
          column: 4
        },
        end: {
          line: 231,
          column: 5
        }
      },
      "84": {
        start: {
          line: 230,
          column: 6
        },
        end: {
          line: 230,
          column: 92
        }
      },
      "85": {
        start: {
          line: 233,
          column: 2
        },
        end: {
          line: 233,
          column: 25
        }
      },
      "86": {
        start: {
          line: 237,
          column: 2
        },
        end: {
          line: 259,
          column: 3
        }
      },
      "87": {
        start: {
          line: 238,
          column: 4
        },
        end: {
          line: 240,
          column: 5
        }
      },
      "88": {
        start: {
          line: 239,
          column: 6
        },
        end: {
          line: 239,
          column: 15
        }
      },
      "89": {
        start: {
          line: 241,
          column: 27
        },
        end: {
          line: 241,
          column: 40
        }
      },
      "90": {
        start: {
          line: 242,
          column: 26
        },
        end: {
          line: 242,
          column: 69
        }
      },
      "91": {
        start: {
          line: 243,
          column: 4
        },
        end: {
          line: 250,
          column: 5
        }
      },
      "92": {
        start: {
          line: 249,
          column: 6
        },
        end: {
          line: 249,
          column: 67
        }
      },
      "93": {
        start: {
          line: 251,
          column: 4
        },
        end: {
          line: 258,
          column: 5
        }
      },
      "94": {
        start: {
          line: 251,
          column: 17
        },
        end: {
          line: 251,
          column: 18
        }
      },
      "95": {
        start: {
          line: 252,
          column: 19
        },
        end: {
          line: 252,
          column: 32
        }
      },
      "96": {
        start: {
          line: 253,
          column: 24
        },
        end: {
          line: 253,
          column: 54
        }
      },
      "97": {
        start: {
          line: 254,
          column: 6
        },
        end: {
          line: 256,
          column: 7
        }
      },
      "98": {
        start: {
          line: 255,
          column: 8
        },
        end: {
          line: 255,
          column: 67
        }
      },
      "99": {
        start: {
          line: 257,
          column: 6
        },
        end: {
          line: 257,
          column: 23
        }
      },
      "100": {
        start: {
          line: 260,
          column: 2
        },
        end: {
          line: 260,
          column: 25
        }
      },
      "101": {
        start: {
          line: 264,
          column: 2
        },
        end: {
          line: 264,
          column: 40
        }
      },
      "102": {
        start: {
          line: 268,
          column: 45
        },
        end: {
          line: 268,
          column: 47
        }
      },
      "103": {
        start: {
          line: 269,
          column: 2
        },
        end: {
          line: 274,
          column: 3
        }
      },
      "104": {
        start: {
          line: 270,
          column: 4
        },
        end: {
          line: 272,
          column: 5
        }
      },
      "105": {
        start: {
          line: 271,
          column: 6
        },
        end: {
          line: 271,
          column: 66
        }
      },
      "106": {
        start: {
          line: 273,
          column: 4
        },
        end: {
          line: 273,
          column: 28
        }
      },
      "107": {
        start: {
          line: 275,
          column: 2
        },
        end: {
          line: 275,
          column: 25
        }
      },
      "108": {
        start: {
          line: 279,
          column: 2
        },
        end: {
          line: 285,
          column: 3
        }
      },
      "109": {
        start: {
          line: 280,
          column: 4
        },
        end: {
          line: 284,
          column: 5
        }
      },
      "110": {
        start: {
          line: 281,
          column: 6
        },
        end: {
          line: 283,
          column: 7
        }
      },
      "111": {
        start: {
          line: 282,
          column: 8
        },
        end: {
          line: 282,
          column: 63
        }
      },
      "112": {
        start: {
          line: 286,
          column: 2
        },
        end: {
          line: 286,
          column: 25
        }
      },
      "113": {
        start: {
          line: 290,
          column: 63
        },
        end: {
          line: 290,
          column: 65
        }
      },
      "114": {
        start: {
          line: 291,
          column: 2
        },
        end: {
          line: 301,
          column: 3
        }
      },
      "115": {
        start: {
          line: 292,
          column: 4
        },
        end: {
          line: 300,
          column: 5
        }
      },
      "116": {
        start: {
          line: 293,
          column: 6
        },
        end: {
          line: 295,
          column: 7
        }
      },
      "117": {
        start: {
          line: 294,
          column: 8
        },
        end: {
          line: 294,
          column: 31
        }
      },
      "118": {
        start: {
          line: 296,
          column: 6
        },
        end: {
          line: 298,
          column: 7
        }
      },
      "119": {
        start: {
          line: 297,
          column: 8
        },
        end: {
          line: 297,
          column: 61
        }
      },
      "120": {
        start: {
          line: 299,
          column: 6
        },
        end: {
          line: 299,
          column: 39
        }
      },
      "121": {
        start: {
          line: 302,
          column: 2
        },
        end: {
          line: 302,
          column: 25
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 40,
            column: 26
          },
          end: {
            line: 40,
            column: 27
          }
        },
        loc: {
          start: {
            line: 40,
            column: 96
          },
          end: {
            line: 47,
            column: 1
          }
        },
        line: 40
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 42,
            column: 40
          },
          end: {
            line: 42,
            column: 41
          }
        },
        loc: {
          start: {
            line: 42,
            column: 50
          },
          end: {
            line: 42,
            column: 85
          }
        },
        line: 42
      },
      "2": {
        name: "setShips",
        decl: {
          start: {
            line: 49,
            column: 9
          },
          end: {
            line: 49,
            column: 17
          }
        },
        loc: {
          start: {
            line: 49,
            column: 69
          },
          end: {
            line: 57,
            column: 1
          }
        },
        line: 49
      },
      "3": {
        name: "salvo",
        decl: {
          start: {
            line: 59,
            column: 9
          },
          end: {
            line: 59,
            column: 14
          }
        },
        loc: {
          start: {
            line: 59,
            column: 68
          },
          end: {
            line: 83,
            column: 1
          }
        },
        line: 59
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 64,
            column: 20
          },
          end: {
            line: 64,
            column: 21
          }
        },
        loc: {
          start: {
            line: 64,
            column: 31
          },
          end: {
            line: 64,
            column: 98
          }
        },
        line: 64
      },
      "5": {
        name: "(anonymous_5)",
        decl: {
          start: {
            line: 88,
            column: 9
          },
          end: {
            line: 88,
            column: 10
          }
        },
        loc: {
          start: {
            line: 88,
            column: 33
          },
          end: {
            line: 91,
            column: 3
          }
        },
        line: 88
      },
      "6": {
        name: "(anonymous_6)",
        decl: {
          start: {
            line: 100,
            column: 16
          },
          end: {
            line: 100,
            column: 17
          }
        },
        loc: {
          start: {
            line: 100,
            column: 28
          },
          end: {
            line: 104,
            column: 9
          }
        },
        line: 100
      },
      "7": {
        name: "(anonymous_7)",
        decl: {
          start: {
            line: 111,
            column: 9
          },
          end: {
            line: 111,
            column: 10
          }
        },
        loc: {
          start: {
            line: 111,
            column: 21
          },
          end: {
            line: 120,
            column: 3
          }
        },
        line: 111
      },
      "8": {
        name: "generateRandomShips",
        decl: {
          start: {
            line: 128,
            column: 16
          },
          end: {
            line: 128,
            column: 35
          }
        },
        loc: {
          start: {
            line: 128,
            column: 61
          },
          end: {
            line: 142,
            column: 1
          }
        },
        line: 128
      },
      "9": {
        name: "validateShips",
        decl: {
          start: {
            line: 145,
            column: 16
          },
          end: {
            line: 145,
            column: 29
          }
        },
        loc: {
          start: {
            line: 145,
            column: 87
          },
          end: {
            line: 162,
            column: 1
          }
        },
        line: 145
      },
      "10": {
        name: "checkAllShipsSunk",
        decl: {
          start: {
            line: 165,
            column: 9
          },
          end: {
            line: 165,
            column: 26
          }
        },
        loc: {
          start: {
            line: 165,
            column: 68
          },
          end: {
            line: 172,
            column: 1
          }
        },
        line: 165
      },
      "11": {
        name: "randomlyGetShip",
        decl: {
          start: {
            line: 174,
            column: 9
          },
          end: {
            line: 174,
            column: 24
          }
        },
        loc: {
          start: {
            line: 174,
            column: 78
          },
          end: {
            line: 188,
            column: 1
          }
        },
        line: 174
      },
      "12": {
        name: "getRandomInt",
        decl: {
          start: {
            line: 190,
            column: 9
          },
          end: {
            line: 190,
            column: 21
          }
        },
        loc: {
          start: {
            line: 190,
            column: 43
          },
          end: {
            line: 192,
            column: 1
          }
        },
        line: 190
      },
      "13": {
        name: "findShipWithCell",
        decl: {
          start: {
            line: 194,
            column: 9
          },
          end: {
            line: 194,
            column: 25
          }
        },
        loc: {
          start: {
            line: 194,
            column: 79
          },
          end: {
            line: 198,
            column: 1
          }
        },
        line: 194
      },
      "14": {
        name: "(anonymous_14)",
        decl: {
          start: {
            line: 196,
            column: 4
          },
          end: {
            line: 196,
            column: 5
          }
        },
        loc: {
          start: {
            line: 196,
            column: 14
          },
          end: {
            line: 196,
            column: 108
          }
        },
        line: 196
      },
      "15": {
        name: "(anonymous_15)",
        decl: {
          start: {
            line: 196,
            column: 35
          },
          end: {
            line: 196,
            column: 36
          }
        },
        loc: {
          start: {
            line: 196,
            column: 42
          },
          end: {
            line: 196,
            column: 74
          }
        },
        line: 196
      },
      "16": {
        name: "countShipHits",
        decl: {
          start: {
            line: 200,
            column: 9
          },
          end: {
            line: 200,
            column: 22
          }
        },
        loc: {
          start: {
            line: 200,
            column: 65
          },
          end: {
            line: 202,
            column: 1
          }
        },
        line: 200
      },
      "17": {
        name: "(anonymous_17)",
        decl: {
          start: {
            line: 201,
            column: 23
          },
          end: {
            line: 201,
            column: 24
          }
        },
        loc: {
          start: {
            line: 201,
            column: 30
          },
          end: {
            line: 201,
            column: 50
          }
        },
        line: 201
      },
      "18": {
        name: "validateShipsCount",
        decl: {
          start: {
            line: 209,
            column: 9
          },
          end: {
            line: 209,
            column: 27
          }
        },
        loc: {
          start: {
            line: 209,
            column: 68
          },
          end: {
            line: 224,
            column: 1
          }
        },
        line: 209
      },
      "19": {
        name: "(anonymous_19)",
        decl: {
          start: {
            line: 210,
            column: 32
          },
          end: {
            line: 210,
            column: 33
          }
        },
        loc: {
          start: {
            line: 210,
            column: 49
          },
          end: {
            line: 210,
            column: 66
          }
        },
        line: 210
      },
      "20": {
        name: "validateShipsOwnership",
        decl: {
          start: {
            line: 226,
            column: 9
          },
          end: {
            line: 226,
            column: 31
          }
        },
        loc: {
          start: {
            line: 226,
            column: 88
          },
          end: {
            line: 234,
            column: 1
          }
        },
        line: 226
      },
      "21": {
        name: "(anonymous_21)",
        decl: {
          start: {
            line: 227,
            column: 27
          },
          end: {
            line: 227,
            column: 28
          }
        },
        loc: {
          start: {
            line: 227,
            column: 44
          },
          end: {
            line: 227,
            column: 55
          }
        },
        line: 227
      },
      "22": {
        name: "validateShipsContinuity",
        decl: {
          start: {
            line: 236,
            column: 9
          },
          end: {
            line: 236,
            column: 32
          }
        },
        loc: {
          start: {
            line: 236,
            column: 73
          },
          end: {
            line: 261,
            column: 1
          }
        },
        line: 236
      },
      "23": {
        name: "getCellVector",
        decl: {
          start: {
            line: 263,
            column: 16
          },
          end: {
            line: 263,
            column: 29
          }
        },
        loc: {
          start: {
            line: 263,
            column: 57
          },
          end: {
            line: 265,
            column: 1
          }
        },
        line: 263
      },
      "24": {
        name: "validateShipsHaveUniqueIDs",
        decl: {
          start: {
            line: 267,
            column: 9
          },
          end: {
            line: 267,
            column: 35
          }
        },
        loc: {
          start: {
            line: 267,
            column: 76
          },
          end: {
            line: 276,
            column: 1
          }
        },
        line: 267
      },
      "25": {
        name: "validateShipsNotOutOfBounds",
        decl: {
          start: {
            line: 278,
            column: 9
          },
          end: {
            line: 278,
            column: 36
          }
        },
        loc: {
          start: {
            line: 278,
            column: 77
          },
          end: {
            line: 287,
            column: 1
          }
        },
        line: 278
      },
      "26": {
        name: "validateShipsNotOverlapping",
        decl: {
          start: {
            line: 289,
            column: 9
          },
          end: {
            line: 289,
            column: 36
          }
        },
        loc: {
          start: {
            line: 289,
            column: 77
          },
          end: {
            line: 303,
            column: 1
          }
        },
        line: 289
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 42,
            column: 50
          },
          end: {
            line: 42,
            column: 85
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 42,
            column: 50
          },
          end: {
            line: 42,
            column: 72
          }
        }, {
          start: {
            line: 42,
            column: 76
          },
          end: {
            line: 42,
            column: 85
          }
        }],
        line: 42
      },
      "1": {
        loc: {
          start: {
            line: 52,
            column: 2
          },
          end: {
            line: 54,
            column: 3
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 52,
            column: 2
          },
          end: {
            line: 54,
            column: 3
          }
        }, {
          start: {
            line: 52,
            column: 2
          },
          end: {
            line: 54,
            column: 3
          }
        }],
        line: 52
      },
      "2": {
        loc: {
          start: {
            line: 64,
            column: 31
          },
          end: {
            line: 64,
            column: 98
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 64,
            column: 31
          },
          end: {
            line: 64,
            column: 54
          }
        }, {
          start: {
            line: 64,
            column: 58
          },
          end: {
            line: 64,
            column: 76
          }
        }, {
          start: {
            line: 64,
            column: 80
          },
          end: {
            line: 64,
            column: 98
          }
        }],
        line: 64
      },
      "3": {
        loc: {
          start: {
            line: 65,
            column: 2
          },
          end: {
            line: 67,
            column: 3
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 65,
            column: 2
          },
          end: {
            line: 67,
            column: 3
          }
        }, {
          start: {
            line: 65,
            column: 2
          },
          end: {
            line: 67,
            column: 3
          }
        }],
        line: 65
      },
      "4": {
        loc: {
          start: {
            line: 68,
            column: 2
          },
          end: {
            line: 71,
            column: 3
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 68,
            column: 2
          },
          end: {
            line: 71,
            column: 3
          }
        }, {
          start: {
            line: 68,
            column: 2
          },
          end: {
            line: 71,
            column: 3
          }
        }],
        line: 68
      },
      "5": {
        loc: {
          start: {
            line: 75,
            column: 2
          },
          end: {
            line: 77,
            column: 3
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 75,
            column: 2
          },
          end: {
            line: 77,
            column: 3
          }
        }, {
          start: {
            line: 75,
            column: 2
          },
          end: {
            line: 77,
            column: 3
          }
        }],
        line: 75
      },
      "6": {
        loc: {
          start: {
            line: 101,
            column: 10
          },
          end: {
            line: 103,
            column: 11
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 101,
            column: 10
          },
          end: {
            line: 103,
            column: 11
          }
        }, {
          start: {
            line: 101,
            column: 10
          },
          end: {
            line: 103,
            column: 11
          }
        }],
        line: 101
      },
      "7": {
        loc: {
          start: {
            line: 112,
            column: 4
          },
          end: {
            line: 119,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 112,
            column: 4
          },
          end: {
            line: 119,
            column: 5
          }
        }, {
          start: {
            line: 112,
            column: 4
          },
          end: {
            line: 119,
            column: 5
          }
        }],
        line: 112
      },
      "8": {
        loc: {
          start: {
            line: 113,
            column: 6
          },
          end: {
            line: 115,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 113,
            column: 6
          },
          end: {
            line: 115,
            column: 7
          }
        }, {
          start: {
            line: 113,
            column: 6
          },
          end: {
            line: 115,
            column: 7
          }
        }],
        line: 113
      },
      "9": {
        loc: {
          start: {
            line: 116,
            column: 6
          },
          end: {
            line: 118,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 116,
            column: 6
          },
          end: {
            line: 118,
            column: 7
          }
        }, {
          start: {
            line: 116,
            column: 6
          },
          end: {
            line: 118,
            column: 7
          }
        }],
        line: 116
      },
      "10": {
        loc: {
          start: {
            line: 153,
            column: 2
          },
          end: {
            line: 155,
            column: 3
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 153,
            column: 2
          },
          end: {
            line: 155,
            column: 3
          }
        }, {
          start: {
            line: 153,
            column: 2
          },
          end: {
            line: 155,
            column: 3
          }
        }],
        line: 153
      },
      "11": {
        loc: {
          start: {
            line: 157,
            column: 4
          },
          end: {
            line: 159,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 157,
            column: 4
          },
          end: {
            line: 159,
            column: 5
          }
        }, {
          start: {
            line: 157,
            column: 4
          },
          end: {
            line: 159,
            column: 5
          }
        }],
        line: 157
      },
      "12": {
        loc: {
          start: {
            line: 167,
            column: 4
          },
          end: {
            line: 169,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 167,
            column: 4
          },
          end: {
            line: 169,
            column: 5
          }
        }, {
          start: {
            line: 167,
            column: 4
          },
          end: {
            line: 169,
            column: 5
          }
        }],
        line: 167
      },
      "13": {
        loc: {
          start: {
            line: 167,
            column: 8
          },
          end: {
            line: 167,
            column: 44
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 167,
            column: 8
          },
          end: {
            line: 167,
            column: 30
          }
        }, {
          start: {
            line: 167,
            column: 34
          },
          end: {
            line: 167,
            column: 44
          }
        }],
        line: 167
      },
      "14": {
        loc: {
          start: {
            line: 176,
            column: 20
          },
          end: {
            line: 176,
            column: 53
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 176,
            column: 44
          },
          end: {
            line: 176,
            column: 47
          }
        }, {
          start: {
            line: 176,
            column: 50
          },
          end: {
            line: 176,
            column: 53
          }
        }],
        line: 176
      },
      "15": {
        loc: {
          start: {
            line: 179,
            column: 4
          },
          end: {
            line: 185,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 179,
            column: 4
          },
          end: {
            line: 185,
            column: 5
          }
        }, {
          start: {
            line: 179,
            column: 4
          },
          end: {
            line: 185,
            column: 5
          }
        }],
        line: 179
      },
      "16": {
        loc: {
          start: {
            line: 196,
            column: 14
          },
          end: {
            line: 196,
            column: 108
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 196,
            column: 14
          },
          end: {
            line: 196,
            column: 82
          }
        }, {
          start: {
            line: 196,
            column: 86
          },
          end: {
            line: 196,
            column: 108
          }
        }],
        line: 196
      },
      "17": {
        loc: {
          start: {
            line: 196,
            column: 42
          },
          end: {
            line: 196,
            column: 74
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 196,
            column: 42
          },
          end: {
            line: 196,
            column: 56
          }
        }, {
          start: {
            line: 196,
            column: 60
          },
          end: {
            line: 196,
            column: 74
          }
        }],
        line: 196
      },
      "18": {
        loc: {
          start: {
            line: 213,
            column: 4
          },
          end: {
            line: 215,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 213,
            column: 4
          },
          end: {
            line: 215,
            column: 5
          }
        }, {
          start: {
            line: 213,
            column: 4
          },
          end: {
            line: 215,
            column: 5
          }
        }],
        line: 213
      },
      "19": {
        loc: {
          start: {
            line: 219,
            column: 4
          },
          end: {
            line: 221,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 219,
            column: 4
          },
          end: {
            line: 221,
            column: 5
          }
        }, {
          start: {
            line: 219,
            column: 4
          },
          end: {
            line: 221,
            column: 5
          }
        }],
        line: 219
      },
      "20": {
        loc: {
          start: {
            line: 229,
            column: 4
          },
          end: {
            line: 231,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 229,
            column: 4
          },
          end: {
            line: 231,
            column: 5
          }
        }, {
          start: {
            line: 229,
            column: 4
          },
          end: {
            line: 231,
            column: 5
          }
        }],
        line: 229
      },
      "21": {
        loc: {
          start: {
            line: 238,
            column: 4
          },
          end: {
            line: 240,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 238,
            column: 4
          },
          end: {
            line: 240,
            column: 5
          }
        }, {
          start: {
            line: 238,
            column: 4
          },
          end: {
            line: 240,
            column: 5
          }
        }],
        line: 238
      },
      "22": {
        loc: {
          start: {
            line: 243,
            column: 4
          },
          end: {
            line: 250,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 243,
            column: 4
          },
          end: {
            line: 250,
            column: 5
          }
        }, {
          start: {
            line: 243,
            column: 4
          },
          end: {
            line: 250,
            column: 5
          }
        }],
        line: 243
      },
      "23": {
        loc: {
          start: {
            line: 245,
            column: 8
          },
          end: {
            line: 246,
            column: 62
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 245,
            column: 9
          },
          end: {
            line: 245,
            column: 33
          }
        }, {
          start: {
            line: 245,
            column: 37
          },
          end: {
            line: 245,
            column: 61
          }
        }, {
          start: {
            line: 246,
            column: 9
          },
          end: {
            line: 246,
            column: 33
          }
        }, {
          start: {
            line: 246,
            column: 37
          },
          end: {
            line: 246,
            column: 61
          }
        }],
        line: 245
      },
      "24": {
        loc: {
          start: {
            line: 254,
            column: 6
          },
          end: {
            line: 256,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 254,
            column: 6
          },
          end: {
            line: 256,
            column: 7
          }
        }, {
          start: {
            line: 254,
            column: 6
          },
          end: {
            line: 256,
            column: 7
          }
        }],
        line: 254
      },
      "25": {
        loc: {
          start: {
            line: 254,
            column: 10
          },
          end: {
            line: 254,
            column: 62
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 254,
            column: 10
          },
          end: {
            line: 254,
            column: 34
          }
        }, {
          start: {
            line: 254,
            column: 38
          },
          end: {
            line: 254,
            column: 62
          }
        }],
        line: 254
      },
      "26": {
        loc: {
          start: {
            line: 270,
            column: 4
          },
          end: {
            line: 272,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 270,
            column: 4
          },
          end: {
            line: 272,
            column: 5
          }
        }, {
          start: {
            line: 270,
            column: 4
          },
          end: {
            line: 272,
            column: 5
          }
        }],
        line: 270
      },
      "27": {
        loc: {
          start: {
            line: 281,
            column: 6
          },
          end: {
            line: 283,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 281,
            column: 6
          },
          end: {
            line: 283,
            column: 7
          }
        }, {
          start: {
            line: 281,
            column: 6
          },
          end: {
            line: 283,
            column: 7
          }
        }],
        line: 281
      },
      "28": {
        loc: {
          start: {
            line: 281,
            column: 10
          },
          end: {
            line: 281,
            column: 62
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 281,
            column: 10
          },
          end: {
            line: 281,
            column: 20
          }
        }, {
          start: {
            line: 281,
            column: 24
          },
          end: {
            line: 281,
            column: 34
          }
        }, {
          start: {
            line: 281,
            column: 38
          },
          end: {
            line: 281,
            column: 48
          }
        }, {
          start: {
            line: 281,
            column: 52
          },
          end: {
            line: 281,
            column: 62
          }
        }],
        line: 281
      },
      "29": {
        loc: {
          start: {
            line: 293,
            column: 6
          },
          end: {
            line: 295,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 293,
            column: 6
          },
          end: {
            line: 295,
            column: 7
          }
        }, {
          start: {
            line: 293,
            column: 6
          },
          end: {
            line: 295,
            column: 7
          }
        }],
        line: 293
      },
      "30": {
        loc: {
          start: {
            line: 296,
            column: 6
          },
          end: {
            line: 298,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 296,
            column: 6
          },
          end: {
            line: 298,
            column: 7
          }
        }, {
          start: {
            line: 296,
            column: 6
          },
          end: {
            line: 298,
            column: 7
          }
        }],
        line: 296
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0,
      "23": 0,
      "24": 0,
      "25": 0,
      "26": 0,
      "27": 0,
      "28": 0,
      "29": 0,
      "30": 0,
      "31": 0,
      "32": 0,
      "33": 0,
      "34": 0,
      "35": 0,
      "36": 0,
      "37": 0,
      "38": 0,
      "39": 0,
      "40": 0,
      "41": 0,
      "42": 0,
      "43": 0,
      "44": 0,
      "45": 0,
      "46": 0,
      "47": 0,
      "48": 0,
      "49": 0,
      "50": 0,
      "51": 0,
      "52": 0,
      "53": 0,
      "54": 0,
      "55": 0,
      "56": 0,
      "57": 0,
      "58": 0,
      "59": 0,
      "60": 0,
      "61": 0,
      "62": 0,
      "63": 0,
      "64": 0,
      "65": 0,
      "66": 0,
      "67": 0,
      "68": 0,
      "69": 0,
      "70": 0,
      "71": 0,
      "72": 0,
      "73": 0,
      "74": 0,
      "75": 0,
      "76": 0,
      "77": 0,
      "78": 0,
      "79": 0,
      "80": 0,
      "81": 0,
      "82": 0,
      "83": 0,
      "84": 0,
      "85": 0,
      "86": 0,
      "87": 0,
      "88": 0,
      "89": 0,
      "90": 0,
      "91": 0,
      "92": 0,
      "93": 0,
      "94": 0,
      "95": 0,
      "96": 0,
      "97": 0,
      "98": 0,
      "99": 0,
      "100": 0,
      "101": 0,
      "102": 0,
      "103": 0,
      "104": 0,
      "105": 0,
      "106": 0,
      "107": 0,
      "108": 0,
      "109": 0,
      "110": 0,
      "111": 0,
      "112": 0,
      "113": 0,
      "114": 0,
      "115": 0,
      "116": 0,
      "117": 0,
      "118": 0,
      "119": 0,
      "120": 0,
      "121": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0,
      "23": 0,
      "24": 0,
      "25": 0,
      "26": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0, 0],
      "3": [0, 0],
      "4": [0, 0],
      "5": [0, 0],
      "6": [0, 0],
      "7": [0, 0],
      "8": [0, 0],
      "9": [0, 0],
      "10": [0, 0],
      "11": [0, 0],
      "12": [0, 0],
      "13": [0, 0],
      "14": [0, 0],
      "15": [0, 0],
      "16": [0, 0],
      "17": [0, 0],
      "18": [0, 0],
      "19": [0, 0],
      "20": [0, 0],
      "21": [0, 0],
      "22": [0, 0],
      "23": [0, 0, 0, 0],
      "24": [0, 0],
      "25": [0, 0],
      "26": [0, 0],
      "27": [0, 0],
      "28": [0, 0, 0, 0],
      "29": [0, 0],
      "30": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "106f2512b460b9a2154489996c028fb2dd27e1ae"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2rmfy6gvhj = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2rmfy6gvhj();

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



var VALID_SHIPS_SIZES = (cov_2rmfy6gvhj().s[0]++, [5, 4, 3, 2]);
var VALID_SHIPS_COUNT = (cov_2rmfy6gvhj().s[1]++, {
  5: 1,
  4: 1,
  3: 2,
  2: 1
});
cov_2rmfy6gvhj().s[2]++;
var playerView = function playerView(G, ctx, playerID) {
  cov_2rmfy6gvhj().f[0]++;
  var player = (cov_2rmfy6gvhj().s[3]++, parseInt(playerID, 10));
  var ships = (cov_2rmfy6gvhj().s[4]++, G.ships.filter(function (ship) {
    cov_2rmfy6gvhj().f[1]++;
    cov_2rmfy6gvhj().s[5]++;
    return (cov_2rmfy6gvhj().b[0][0]++, ship.player === player) || (cov_2rmfy6gvhj().b[0][1]++, ship.sunk);
  }));
  cov_2rmfy6gvhj().s[6]++;
  return _objectSpread({}, G, {
    ships: ships
  });
};

function setShips(G, ctx, ships) {
  cov_2rmfy6gvhj().f[2]++;
  var player = (cov_2rmfy6gvhj().s[7]++, parseInt(ctx.playerID, 10));
  var validation = (cov_2rmfy6gvhj().s[8]++, validateShips(ships, player));
  cov_2rmfy6gvhj().s[9]++;

  if (!validation.valid) {
    cov_2rmfy6gvhj().b[1][0]++;
    cov_2rmfy6gvhj().s[10]++;
    throw new Error(validation.error);
  } else {
    cov_2rmfy6gvhj().b[1][1]++;
  }

  cov_2rmfy6gvhj().s[11]++;
  return _objectSpread({}, G, {
    ships: [].concat(Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(G.ships), Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(ships))
  });
}

function salvo(G, ctx, x, y) {
  cov_2rmfy6gvhj().f[3]++;
  var player = (cov_2rmfy6gvhj().s[12]++, parseInt(ctx.playerID, 10));
  var shipIndex = (cov_2rmfy6gvhj().s[13]++, findShipWithCell(G.ships, {
    x: x,
    y: y
  }, player)); // Do not allow the same cells to be shot twice

  var uniqueMove = (cov_2rmfy6gvhj().s[14]++, G.salvos.filter(function (salvo) {
    cov_2rmfy6gvhj().f[4]++;
    cov_2rmfy6gvhj().s[15]++;
    return (cov_2rmfy6gvhj().b[2][0]++, salvo.player === player) && (cov_2rmfy6gvhj().b[2][1]++, salvo.cell.x === x) && (cov_2rmfy6gvhj().b[2][2]++, salvo.cell.y === y);
  }).length === 0);
  cov_2rmfy6gvhj().s[16]++;

  if (!uniqueMove) {
    cov_2rmfy6gvhj().b[3][0]++;
    cov_2rmfy6gvhj().s[17]++;
    return _objectSpread({}, G);
  } else {
    cov_2rmfy6gvhj().b[3][1]++;
  }

  cov_2rmfy6gvhj().s[18]++;

  if (shipIndex === -1) {
    cov_2rmfy6gvhj().b[4][0]++;
    cov_2rmfy6gvhj().s[19]++;
    // Miss
    return _objectSpread({}, G, {
      salvos: [].concat(Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(G.salvos), [{
        player: player,
        hit: false,
        cell: {
          x: x,
          y: y
        }
      }])
    });
  } else {
    cov_2rmfy6gvhj().b[4][1]++;
  }

  var ship = (cov_2rmfy6gvhj().s[20]++, G.ships[shipIndex]); // Hit

  var newShips = (cov_2rmfy6gvhj().s[21]++, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(G.ships));
  cov_2rmfy6gvhj().s[22]++;

  if (countShipHits(G.salvos, ship.id) + 1 === ship.cells.length) {
    cov_2rmfy6gvhj().b[5][0]++;
    cov_2rmfy6gvhj().s[23]++;
    newShips[shipIndex] = _objectSpread({}, newShips[shipIndex], {
      sunk: true
    });
  } else {
    cov_2rmfy6gvhj().b[5][1]++;
  }

  cov_2rmfy6gvhj().s[24]++;
  return _objectSpread({}, G, {
    ships: newShips,
    salvos: [].concat(Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(G.salvos), [{
      player: player,
      hit: true,
      cell: {
        x: x,
        y: y
      },
      hitShip: ship.id
    }])
  });
}

var SeabattleGame = (cov_2rmfy6gvhj().s[25]++, {
  name: 'seabattle',
  setup: function setup() {
    cov_2rmfy6gvhj().f[5]++;
    cov_2rmfy6gvhj().s[26]++;
    return {
      ships: [],
      salvos: []
    };
  },
  phases: {
    setup: {
      moves: {
        setShips: setShips
      },
      next: 'play',
      start: true,
      turn: {
        activePlayers: boardgame_io_core__WEBPACK_IMPORTED_MODULE_2__["ActivePlayers"].ALL_ONCE,
        onMove: function onMove(_, ctx) {
          cov_2rmfy6gvhj().f[6]++;
          cov_2rmfy6gvhj().s[27]++;

          if (ctx.activePlayers === null) {
            cov_2rmfy6gvhj().b[6][0]++;
            cov_2rmfy6gvhj().s[28]++;
            ctx.events.endPhase();
          } else {
            cov_2rmfy6gvhj().b[6][1]++;
          }
        }
      }
    },
    play: {
      moves: {
        salvo: salvo
      }
    }
  },
  endIf: function endIf(G, ctx) {
    cov_2rmfy6gvhj().f[7]++;
    cov_2rmfy6gvhj().s[29]++;

    if (ctx.phase === 'play') {
      cov_2rmfy6gvhj().b[7][0]++;
      cov_2rmfy6gvhj().s[30]++;

      if (checkAllShipsSunk(G.ships, 0)) {
        cov_2rmfy6gvhj().b[8][0]++;
        cov_2rmfy6gvhj().s[31]++;
        return {
          winner: '1'
        };
      } else {
        cov_2rmfy6gvhj().b[8][1]++;
      }

      cov_2rmfy6gvhj().s[32]++;

      if (checkAllShipsSunk(G.ships, 1)) {
        cov_2rmfy6gvhj().b[9][0]++;
        cov_2rmfy6gvhj().s[33]++;
        return {
          winner: '0'
        };
      } else {
        cov_2rmfy6gvhj().b[9][1]++;
      }
    } else {
      cov_2rmfy6gvhj().b[7][1]++;
    }
  },
  turn: {
    moveLimit: 1
  },
  playerView: playerView
}); // Helper function for generating random ships positioning.

function generateRandomShips(player) {
  cov_2rmfy6gvhj().f[8]++;
  var result;
  var shipID;
  cov_2rmfy6gvhj().s[34]++;

  do {
    cov_2rmfy6gvhj().s[35]++;
    result = [];
    cov_2rmfy6gvhj().s[36]++;

    var _iterator = _createForOfIteratorHelper(VALID_SHIPS_SIZES),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var shipSize = _step.value;
        var count = (cov_2rmfy6gvhj().s[37]++, VALID_SHIPS_COUNT[shipSize]);
        cov_2rmfy6gvhj().s[38]++;

        for (var i = (cov_2rmfy6gvhj().s[39]++, 0); i < count; i++) {
          cov_2rmfy6gvhj().s[40]++;
          shipID = shortid__WEBPACK_IMPORTED_MODULE_3___default.a.generate();
          cov_2rmfy6gvhj().s[41]++;
          result.push(randomlyGetShip(player, shipSize, shipID));
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } while (!validateShips(result, player).valid);

  cov_2rmfy6gvhj().s[42]++;
  return result;
} // Wheather a setup is valid or not.

function validateShips(ships, player) {
  cov_2rmfy6gvhj().f[9]++;
  var validations = (cov_2rmfy6gvhj().s[43]++, [validateShipsCount(ships), validateShipsContinuity(ships), validateShipsNotOutOfBounds(ships), validateShipsNotOverlapping(ships), validateShipsHaveUniqueIDs(ships)]);
  cov_2rmfy6gvhj().s[44]++;

  if (player !== undefined) {
    cov_2rmfy6gvhj().b[10][0]++;
    cov_2rmfy6gvhj().s[45]++;
    validations.push(validateShipsOwnership(player, ships));
  } else {
    cov_2rmfy6gvhj().b[10][1]++;
  }

  cov_2rmfy6gvhj().s[46]++;

  for (var _i = 0, _validations = validations; _i < _validations.length; _i++) {
    var validation = _validations[_i];
    cov_2rmfy6gvhj().s[47]++;

    if (!validation.valid) {
      cov_2rmfy6gvhj().b[11][0]++;
      cov_2rmfy6gvhj().s[48]++;
      return validation;
    } else {
      cov_2rmfy6gvhj().b[11][1]++;
    }
  }

  cov_2rmfy6gvhj().s[49]++;
  return {
    valid: true
  };
} // PRIVATE FUNCTIONS

function checkAllShipsSunk(ships, player) {
  cov_2rmfy6gvhj().f[10]++;
  cov_2rmfy6gvhj().s[50]++;

  var _iterator2 = _createForOfIteratorHelper(ships),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var ship = _step2.value;
      cov_2rmfy6gvhj().s[51]++;

      if ((cov_2rmfy6gvhj().b[13][0]++, ship.player === player) && (cov_2rmfy6gvhj().b[13][1]++, !ship.sunk)) {
        cov_2rmfy6gvhj().b[12][0]++;
        cov_2rmfy6gvhj().s[52]++;
        return false;
      } else {
        cov_2rmfy6gvhj().b[12][1]++;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  cov_2rmfy6gvhj().s[53]++;
  return true;
}

function randomlyGetShip(player, shipSize, id) {
  cov_2rmfy6gvhj().f[11]++;
  var cell = (cov_2rmfy6gvhj().s[54]++, {
    x: getRandomInt(10),
    y: getRandomInt(10)
  });
  var direction = (cov_2rmfy6gvhj().s[55]++, getRandomInt(2) === 1 ? (cov_2rmfy6gvhj().b[14][0]++, 'H') : (cov_2rmfy6gvhj().b[14][1]++, 'V'));
  var ship = (cov_2rmfy6gvhj().s[56]++, {
    player: player,
    cells: [],
    sunk: false,
    id: id
  });
  cov_2rmfy6gvhj().s[57]++;

  for (var i = (cov_2rmfy6gvhj().s[58]++, 0); i < shipSize; i++) {
    cov_2rmfy6gvhj().s[59]++;

    if (direction === 'H') {
      cov_2rmfy6gvhj().b[15][0]++;
      cov_2rmfy6gvhj().s[60]++;
      // Constant y
      ship.cells.push(_objectSpread({}, cell, {
        x: cell.x + i
      }));
    } else {
      cov_2rmfy6gvhj().b[15][1]++;
      cov_2rmfy6gvhj().s[61]++;
      // Constant x
      ship.cells.push(_objectSpread({}, cell, {
        y: cell.y + i
      }));
    }
  }

  cov_2rmfy6gvhj().s[62]++;
  return ship;
}

function getRandomInt(max) {
  cov_2rmfy6gvhj().f[12]++;
  cov_2rmfy6gvhj().s[63]++;
  return Math.random() * max << 0 << 0; // https://github.com/babel/minify/issues/904
}

function findShipWithCell(ships, cell, player) {
  cov_2rmfy6gvhj().f[13]++;
  cov_2rmfy6gvhj().s[64]++;
  return ships.findIndex(function (ship) {
    cov_2rmfy6gvhj().f[14]++;
    cov_2rmfy6gvhj().s[65]++;
    return (cov_2rmfy6gvhj().b[16][0]++, ship.cells.findIndex(function (c) {
      cov_2rmfy6gvhj().f[15]++;
      cov_2rmfy6gvhj().s[66]++;
      return (cov_2rmfy6gvhj().b[17][0]++, c.x === cell.x) && (cov_2rmfy6gvhj().b[17][1]++, c.y === cell.y);
    }) !== -1) && (cov_2rmfy6gvhj().b[16][1]++, ship.player !== player);
  });
}

function countShipHits(salvos, shipId) {
  cov_2rmfy6gvhj().f[16]++;
  cov_2rmfy6gvhj().s[67]++;
  return salvos.filter(function (s) {
    cov_2rmfy6gvhj().f[17]++;
    cov_2rmfy6gvhj().s[68]++;
    return s.hitShip === shipId;
  }).length;
}

function validateShipsCount(ships) {
  cov_2rmfy6gvhj().f[18]++;
  var shipsLength = (cov_2rmfy6gvhj().s[69]++, ships.map(function (ship) {
    cov_2rmfy6gvhj().f[19]++;
    cov_2rmfy6gvhj().s[70]++;
    return ship.cells.length;
  }));
  var count = (cov_2rmfy6gvhj().s[71]++, _objectSpread({}, VALID_SHIPS_COUNT));
  cov_2rmfy6gvhj().s[72]++;

  var _iterator3 = _createForOfIteratorHelper(shipsLength),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _length = _step3.value;
      cov_2rmfy6gvhj().s[73]++;

      if (!(_length in count)) {
        cov_2rmfy6gvhj().b[18][0]++;
        cov_2rmfy6gvhj().s[74]++;
        return {
          valid: false,
          error: "Invalid ship length: ".concat(_length)
        };
      } else {
        cov_2rmfy6gvhj().b[18][1]++;
      }

      cov_2rmfy6gvhj().s[75]++;
      count[_length]--;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  cov_2rmfy6gvhj().s[76]++;

  for (var _i2 = 0, _Object$values = Object.values(count); _i2 < _Object$values.length; _i2++) {
    var length = _Object$values[_i2];
    cov_2rmfy6gvhj().s[77]++;

    if (length !== 0) {
      cov_2rmfy6gvhj().b[19][0]++;
      cov_2rmfy6gvhj().s[78]++;
      return {
        valid: false,
        error: 'Invalid ships sizes.'
      };
    } else {
      cov_2rmfy6gvhj().b[19][1]++;
    }
  }

  cov_2rmfy6gvhj().s[79]++;
  return {
    valid: true
  };
}

function validateShipsOwnership(player, ships) {
  cov_2rmfy6gvhj().f[20]++;
  var owners = (cov_2rmfy6gvhj().s[80]++, ships.map(function (ship) {
    cov_2rmfy6gvhj().f[21]++;
    cov_2rmfy6gvhj().s[81]++;
    return ship.player;
  }));
  cov_2rmfy6gvhj().s[82]++;

  var _iterator4 = _createForOfIteratorHelper(owners),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var owner = _step4.value;
      cov_2rmfy6gvhj().s[83]++;

      if (owner !== player) {
        cov_2rmfy6gvhj().b[20][0]++;
        cov_2rmfy6gvhj().s[84]++;
        return {
          valid: false,
          error: "Invalid player owner: ".concat(owner, " should be: ").concat(player)
        };
      } else {
        cov_2rmfy6gvhj().b[20][1]++;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  cov_2rmfy6gvhj().s[85]++;
  return {
    valid: true
  };
}

function validateShipsContinuity(ships) {
  cov_2rmfy6gvhj().f[22]++;
  cov_2rmfy6gvhj().s[86]++;

  var _iterator5 = _createForOfIteratorHelper(ships),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var ship = _step5.value;
      cov_2rmfy6gvhj().s[87]++;

      if (ship.cells.length < 2) {
        cov_2rmfy6gvhj().b[21][0]++;
        cov_2rmfy6gvhj().s[88]++;
        continue;
      } else {
        cov_2rmfy6gvhj().b[21][1]++;
      }

      var lastICell = (cov_2rmfy6gvhj().s[89]++, ship.cells[0]);
      var vector = (cov_2rmfy6gvhj().s[90]++, getCellVector(ship.cells[1], ship.cells[0]));
      cov_2rmfy6gvhj().s[91]++;

      if (!((cov_2rmfy6gvhj().b[23][0]++, Math.abs(vector.x) === 1) && (cov_2rmfy6gvhj().b[23][1]++, Math.abs(vector.y) === 0) || (cov_2rmfy6gvhj().b[23][2]++, Math.abs(vector.x) === 0) && (cov_2rmfy6gvhj().b[23][3]++, Math.abs(vector.y) === 1))) {
        cov_2rmfy6gvhj().b[22][0]++;
        cov_2rmfy6gvhj().s[92]++;
        return {
          valid: false,
          error: "IShip is not spaced right!"
        };
      } else {
        cov_2rmfy6gvhj().b[22][1]++;
      }

      cov_2rmfy6gvhj().s[93]++;

      for (var i = (cov_2rmfy6gvhj().s[94]++, 1); i < ship.cells.length; i++) {
        var cell = (cov_2rmfy6gvhj().s[95]++, ship.cells[i]);
        var newVector = (cov_2rmfy6gvhj().s[96]++, getCellVector(cell, lastICell));
        cov_2rmfy6gvhj().s[97]++;

        if ((cov_2rmfy6gvhj().b[25][0]++, newVector.x !== vector.x) || (cov_2rmfy6gvhj().b[25][1]++, newVector.y !== vector.y)) {
          cov_2rmfy6gvhj().b[24][0]++;
          cov_2rmfy6gvhj().s[98]++;
          return {
            valid: false,
            error: "IShip is not continuous!"
          };
        } else {
          cov_2rmfy6gvhj().b[24][1]++;
        }

        cov_2rmfy6gvhj().s[99]++;
        lastICell = cell;
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  cov_2rmfy6gvhj().s[100]++;
  return {
    valid: true
  };
}

function getCellVector(a, b) {
  cov_2rmfy6gvhj().f[23]++;
  cov_2rmfy6gvhj().s[101]++;
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}

function validateShipsHaveUniqueIDs(ships) {
  cov_2rmfy6gvhj().f[24]++;
  var usedIDs = (cov_2rmfy6gvhj().s[102]++, {});
  cov_2rmfy6gvhj().s[103]++;

  var _iterator6 = _createForOfIteratorHelper(ships),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var ship = _step6.value;
      cov_2rmfy6gvhj().s[104]++;

      if (usedIDs[ship.id]) {
        cov_2rmfy6gvhj().b[26][0]++;
        cov_2rmfy6gvhj().s[105]++;
        return {
          valid: false,
          error: "IShip IDs are not unique!"
        };
      } else {
        cov_2rmfy6gvhj().b[26][1]++;
      }

      cov_2rmfy6gvhj().s[106]++;
      usedIDs[ship.id] = true;
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  cov_2rmfy6gvhj().s[107]++;
  return {
    valid: true
  };
}

function validateShipsNotOutOfBounds(ships) {
  cov_2rmfy6gvhj().f[25]++;
  cov_2rmfy6gvhj().s[108]++;

  var _iterator7 = _createForOfIteratorHelper(ships),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var ship = _step7.value;
      cov_2rmfy6gvhj().s[109]++;

      var _iterator8 = _createForOfIteratorHelper(ship.cells),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var cell = _step8.value;
          cov_2rmfy6gvhj().s[110]++;

          if ((cov_2rmfy6gvhj().b[28][0]++, cell.x < 0) || (cov_2rmfy6gvhj().b[28][1]++, cell.x > 9) || (cov_2rmfy6gvhj().b[28][2]++, cell.y < 0) || (cov_2rmfy6gvhj().b[28][3]++, cell.y > 9)) {
            cov_2rmfy6gvhj().b[27][0]++;
            cov_2rmfy6gvhj().s[111]++;
            return {
              valid: false,
              error: "IShip out of bounds!"
            };
          } else {
            cov_2rmfy6gvhj().b[27][1]++;
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  cov_2rmfy6gvhj().s[112]++;
  return {
    valid: true
  };
}

function validateShipsNotOverlapping(ships) {
  cov_2rmfy6gvhj().f[26]++;
  var cellsUsed = (cov_2rmfy6gvhj().s[113]++, {});
  cov_2rmfy6gvhj().s[114]++;

  var _iterator9 = _createForOfIteratorHelper(ships),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var ship = _step9.value;
      cov_2rmfy6gvhj().s[115]++;

      var _iterator10 = _createForOfIteratorHelper(ship.cells),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var cell = _step10.value;
          cov_2rmfy6gvhj().s[116]++;

          if (!(cell.x in cellsUsed)) {
            cov_2rmfy6gvhj().b[29][0]++;
            cov_2rmfy6gvhj().s[117]++;
            cellsUsed[cell.x] = {};
          } else {
            cov_2rmfy6gvhj().b[29][1]++;
          }

          cov_2rmfy6gvhj().s[118]++;

          if (cellsUsed[cell.x][cell.y]) {
            cov_2rmfy6gvhj().b[30][0]++;
            cov_2rmfy6gvhj().s[119]++;
            return {
              valid: false,
              error: "Overlapping ships!"
            };
          } else {
            cov_2rmfy6gvhj().b[30][1]++;
          }

          cov_2rmfy6gvhj().s[120]++;
          cellsUsed[cell.x][cell.y] = true;
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  cov_2rmfy6gvhj().s[121]++;
  return {
    valid: true
  };
}

/***/ }),

/***/ "./src/games/seabattle/media/SvgBackground.tsx":
/*!*****************************************************!*\
  !*** ./src/games/seabattle/media/SvgBackground.tsx ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_2p9i4h1iij() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgBackground.tsx";
  var hash = "d0e5d1cc0ed793523f09e78db4da94c7f7ac8e71";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgBackground.tsx",
    statementMap: {
      "0": {
        start: {
          line: 2,
          column: 16
        },
        end: {
          line: 14,
          column: 4
        }
      },
      "1": {
        start: {
          line: 3,
          column: 2
        },
        end: {
          line: 14,
          column: 4
        }
      },
      "2": {
        start: {
          line: 4,
          column: 14
        },
        end: {
          line: 4,
          column: 20
        }
      },
      "3": {
        start: {
          line: 5,
          column: 14
        },
        end: {
          line: 5,
          column: 27
        }
      },
      "4": {
        start: {
          line: 6,
          column: 21
        },
        end: {
          line: 8,
          column: 5
        }
      },
      "5": {
        start: {
          line: 7,
          column: 6
        },
        end: {
          line: 7,
          column: 30
        }
      },
      "6": {
        start: {
          line: 9,
          column: 4
        },
        end: {
          line: 13,
          column: 6
        }
      },
      "7": {
        start: {
          line: 15,
          column: 22
        },
        end: {
          line: 40,
          column: 1
        }
      },
      "8": {
        start: {
          line: 16,
          column: 2
        },
        end: {
          line: 39,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 2,
            column: 16
          },
          end: {
            line: 2,
            column: 17
          }
        },
        loc: {
          start: {
            line: 3,
            column: 2
          },
          end: {
            line: 14,
            column: 4
          }
        },
        line: 3
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 3,
            column: 34
          },
          end: {
            line: 3,
            column: 35
          }
        },
        loc: {
          start: {
            line: 3,
            column: 49
          },
          end: {
            line: 14,
            column: 3
          }
        },
        line: 3
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 6,
            column: 21
          },
          end: {
            line: 6,
            column: 22
          }
        },
        loc: {
          start: {
            line: 6,
            column: 27
          },
          end: {
            line: 8,
            column: 5
          }
        },
        line: 6
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 15,
            column: 22
          },
          end: {
            line: 15,
            column: 23
          }
        },
        loc: {
          start: {
            line: 16,
            column: 2
          },
          end: {
            line: 39,
            column: 6
          }
        },
        line: 16
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0
    },
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "d0e5d1cc0ed793523f09e78db4da94c7f7ac8e71"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2p9i4h1iij = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2p9i4h1iij();

cov_2p9i4h1iij().s[0]++;

var squares = function squares(props) {
  cov_2p9i4h1iij().f[0]++;
  cov_2p9i4h1iij().s[1]++;
  return Array.from({
    length: 100
  }).map(function (unused, i) {
    cov_2p9i4h1iij().f[1]++;
    var x = (cov_2p9i4h1iij().s[2]++, i % 10);
    var y = (cov_2p9i4h1iij().s[3]++, i / 10 << 0);
    cov_2p9i4h1iij().s[4]++;

    var _onClick = function _onClick() {
      cov_2p9i4h1iij().f[2]++;
      cov_2p9i4h1iij().s[5]++;
      props.onClick({
        x: x,
        y: y
      });
    };

    cov_2p9i4h1iij().s[6]++;
    return __jsx("g", {
      key: i,
      onClick: _onClick,
      transform: "translate(".concat(x, ", ").concat(y, ")")
    }, __jsx("rect", {
      x: 0,
      y: 0,
      fill: "red",
      fillOpacity: "0",
      width: "1",
      height: "1",
      stroke: "white",
      strokeWidth: 0.005
    }));
  });
};

cov_2p9i4h1iij().s[7]++;

var SvgBackground = function SvgBackground(props) {
  cov_2p9i4h1iij().f[3]++;
  cov_2p9i4h1iij().s[8]++;
  return __jsx("g", null, "// .svg starts here", __jsx("defs", null, __jsx("linearGradient", {
    id: "background_svg__a"
  }, __jsx("stop", {
    offset: 0,
    stopColor: "#203f5c"
  }), __jsx("stop", {
    offset: 0.744,
    stopColor: "#00152a"
  }), __jsx("stop", {
    offset: 1,
    stopColor: "#020c16"
  })), __jsx("radialGradient", {
    xlinkHref: "#background_svg__a",
    id: "background_svg__b",
    cx: 5,
    cy: 5,
    fx: 5,
    fy: 5,
    r: 5,
    gradientUnits: "userSpaceOnUse",
    spreadMethod: "pad"
  })), __jsx("path", {
    fill: "url(#background_svg__b)",
    fillRule: "evenodd",
    d: "M0 0h10v10H0z"
  }), "// .svg ends here", squares(props));
};

/* harmony default export */ __webpack_exports__["default"] = (SvgBackground);

/***/ }),

/***/ "./src/games/seabattle/media/SvgHit.tsx":
/*!**********************************************!*\
  !*** ./src/games/seabattle/media/SvgHit.tsx ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_2euu13v2aj() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgHit.tsx";
  var hash = "529025ebc81d8eed0e94217804910995e6f8f6e3";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgHit.tsx",
    statementMap: {
      "0": {
        start: {
          line: 2,
          column: 15
        },
        end: {
          line: 6,
          column: 1
        }
      },
      "1": {
        start: {
          line: 3,
          column: 2
        },
        end: {
          line: 5,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 2,
            column: 15
          },
          end: {
            line: 2,
            column: 16
          }
        },
        loc: {
          start: {
            line: 3,
            column: 2
          },
          end: {
            line: 5,
            column: 6
          }
        },
        line: 3
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0
    },
    f: {
      "0": 0
    },
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "529025ebc81d8eed0e94217804910995e6f8f6e3"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2euu13v2aj = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2euu13v2aj();

cov_2euu13v2aj().s[0]++;

var SvgHit = function SvgHit() {
  cov_2euu13v2aj().f[0]++;
  cov_2euu13v2aj().s[1]++;
  return __jsx("g", null, __jsx("circle", {
    cx: "0.5",
    cy: "0.5",
    r: "0.2",
    fill: "red",
    stroke: "white",
    strokeWidth: "0.05"
  }));
};

/* harmony default export */ __webpack_exports__["default"] = (SvgHit);

/***/ }),

/***/ "./src/games/seabattle/media/SvgMiss.tsx":
/*!***********************************************!*\
  !*** ./src/games/seabattle/media/SvgMiss.tsx ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_2bhfyogdqi() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgMiss.tsx";
  var hash = "4195a8af26a68630fa313b7d7ab0dde5e591ca09";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgMiss.tsx",
    statementMap: {
      "0": {
        start: {
          line: 2,
          column: 16
        },
        end: {
          line: 7,
          column: 1
        }
      },
      "1": {
        start: {
          line: 3,
          column: 2
        },
        end: {
          line: 6,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 2,
            column: 16
          },
          end: {
            line: 2,
            column: 17
          }
        },
        loc: {
          start: {
            line: 3,
            column: 2
          },
          end: {
            line: 6,
            column: 6
          }
        },
        line: 3
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0
    },
    f: {
      "0": 0
    },
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "4195a8af26a68630fa313b7d7ab0dde5e591ca09"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2bhfyogdqi = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2bhfyogdqi();

cov_2bhfyogdqi().s[0]++;

var SvgMiss = function SvgMiss() {
  cov_2bhfyogdqi().f[0]++;
  cov_2bhfyogdqi().s[1]++;
  return __jsx("g", null, __jsx("line", {
    x1: "0.2",
    y1: "0.2",
    x2: "0.8",
    y2: "0.8",
    stroke: "white",
    strokeWidth: "0.05"
  }), __jsx("line", {
    x1: "0.8",
    y1: "0.2",
    x2: "0.2",
    y2: "0.8",
    stroke: "white",
    strokeWidth: "0.05"
  }));
};

/* harmony default export */ __webpack_exports__["default"] = (SvgMiss);

/***/ }),

/***/ "./src/games/seabattle/media/SvgShip2.tsx":
/*!************************************************!*\
  !*** ./src/games/seabattle/media/SvgShip2.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_13o9pwlb6() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgShip2.tsx";
  var hash = "edd377bc9dce13249cd9209ef9a697bdee52b037";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgShip2.tsx",
    statementMap: {
      "0": {
        start: {
          line: 4,
          column: 17
        },
        end: {
          line: 163,
          column: 1
        }
      },
      "1": {
        start: {
          line: 5,
          column: 2
        },
        end: {
          line: 162,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 4,
            column: 17
          },
          end: {
            line: 4,
            column: 18
          }
        },
        loc: {
          start: {
            line: 5,
            column: 2
          },
          end: {
            line: 162,
            column: 6
          }
        },
        line: 5
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0
    },
    f: {
      "0": 0
    },
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "edd377bc9dce13249cd9209ef9a697bdee52b037"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_13o9pwlb6 = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_13o9pwlb6();

/* tslint:disable */

cov_13o9pwlb6().s[0]++;

var SvgShip2 = function SvgShip2() {
  cov_13o9pwlb6().f[0]++;
  cov_13o9pwlb6().s[1]++;
  return __jsx("g", null, __jsx("path", {
    d: "M.003.137v.691s.686.088.999.083c.565-.009.997-.237.995-.438C1.995.264 1.552.044 1.002.04.688.038.003.137.003.137z",
    fill: "#595959"
  }), __jsx("clipPath", {
    id: "ship2_svg__a"
  }, __jsx("path", {
    d: "M2.996 50.016V301.03s339.02 31.748 494 30c279.24-3.15 493.017-85.958 492-159.008-1.055-75.773-220.203-155.563-492-157.008-155.103-.825-494 35.002-494 35.002z"
  })), __jsx("g", {
    clipPath: "url(#ship2_svg__a)",
    transform: "matrix(.00202 0 0 .00276 -.003 -.001)"
  }, __jsx("path", {
    d: "M616 15H234v318.016h382C650.44 232.188 647.894 91.53 616 15z",
    fill: "gray",
    stroke: "#737373",
    strokeWidth: 5
  }), __jsx("path", {
    d: "M1.996 18.014h243V326.03h-243z",
    fill: "#999"
  }), __jsx("clipPath", {
    id: "ship2_svg__b"
  }, __jsx("path", {
    d: "M1.996 18.014h243V326.03h-243z"
  })), __jsx("g", {
    clipPath: "url(#ship2_svg__b)"
  }, __jsx("path", {
    d: "M247.086 24.95L-8.69 303.286l7.36 6.767L254.45 31.719l-7.364-6.767z",
    fill: "#ebebeb"
  }), __jsx("path", {
    d: "M-10.004 44.88l252.68 281.15 7.436-6.685L-2.566 38.195l-7.438 6.684z",
    fill: "#ebebeb"
  }), __jsx("ellipse", {
    cx: 113.231,
    cy: 175.778,
    rx: 65.769,
    ry: 50.172,
    fill: "none",
    stroke: "#fff",
    strokeWidth: 10
  }), __jsx("path", {
    d: "M206.5 6h10v375.02h-10z",
    fill: "#ffd200"
  })), __jsx("path", {
    d: "M374 34L267 46l-3 256 116 10 35-15-1.926-252L374 34z",
    fill: "#999",
    stroke: "#a6a6a6",
    strokeWidth: 4
  })), __jsx("g", {
    fill: "#f2f2f2",
    stroke: "#ccc",
    strokeWidth: 2,
    strokeLinecap: "butt",
    strokeLinejoin: "miter"
  }, __jsx("path", {
    d: "M608.196 327.92a9.635 9.635 0 0 0-8.598-10.57l-50.733-5.21c-5.292-.545-10.023 3.305-10.567 8.597-.544 5.293 3.306 10.024 8.598 10.568l50.733 5.212c5.29.544 10.023-3.306 10.566-8.598z",
    transform: "matrix(.00202 0 0 .00276 -.003 -.001)"
  }), __jsx("path", {
    d: "M609.702 313.263c.544-5.293-3.306-10.024-8.598-10.568l-50.733-5.212c-5.29-.544-10.023 3.306-10.566 8.598a9.635 9.635 0 0 0 8.598 10.57l50.733 5.21c5.292.545 10.023-3.305 10.567-8.597z",
    transform: "matrix(.00202 0 0 .00276 -.003 -.001)"
  })), __jsx("g", {
    fill: "#f2f2f2",
    stroke: "#ccc",
    strokeWidth: 2,
    strokeLinecap: "butt",
    strokeLinejoin: "miter"
  }, __jsx("path", {
    d: "M607.95 12.65c.544 5.292-3.306 10.023-8.598 10.567L548.62 28.43a9.636 9.636 0 0 1-10.57-8.6c-.543-5.29 3.307-10.023 8.6-10.566l50.732-5.213a9.635 9.635 0 0 1 10.568 8.6z",
    transform: "matrix(.00202 0 0 .00276 -.003 -.001)"
  }), __jsx("path", {
    d: "M609.456 27.306c.543 5.292-3.306 10.023-8.6 10.567l-50.732 5.213c-5.292.543-10.023-3.306-10.567-8.6-.544-5.29 3.306-10.022 8.598-10.566l50.733-5.213a9.634 9.634 0 0 1 10.568 8.6z",
    transform: "matrix(.00202 0 0 .00276 -.003 -.001)"
  })), __jsx("ellipse", {
    cx: 1.577,
    cy: 0.48,
    rx: 0.215,
    ry: 0.223,
    fill: "none",
    stroke: "#999",
    strokeWidth: 0.012
  }), __jsx("ellipse", {
    cx: 1.571,
    cy: 0.479,
    rx: 0.124,
    ry: 0.171,
    fill: "#999"
  }), __jsx("path", {
    d: "M1.528.67C1.456.56 1.456.379 1.53.286l.147.098-.001.193-.148.095",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship2_svg__c"
  }, __jsx("path", {
    d: "M756.974 243.824c-35.244-40.175-35.723-106.15 1.063-140l72.69 35.56-.532 70-73.22 34.44"
  })), __jsx("g", {
    clipPath: "url(#ship2_svg__c)",
    transform: "matrix(.00202 0 0 .00276 -.003 -.001)"
  }, __jsx("path", {
    d: "M835.924 166.586l-60.796-.467-.114 14.998 60.796.468.114-15z",
    fill: "#4d4d4d"
  }), __jsx("path", {
    d: "M838.787 184.61l-66.796-.515.16-21h.002l66.795.514-.16 20.998zm-2.977-3.024l.114-15-60.796-.467-.114 14.998 60.796.468z",
    fill: "#b3b3b3"
  })), __jsx("path", {
    d: "M1.528.67C1.456.56 1.456.379 1.53.286l.147.098-.001.193-.148.095",
    fill: "none",
    stroke: "#e6e6e6",
    strokeWidth: 0.007
  }), __jsx("path", {
    d: "M1.896.472L1.57.465v.024l.326-.001V.472z",
    fill: "#e6e6e6"
  }), __jsx("ellipse", {
    cx: 1.865,
    cy: 0.391,
    rx: 0.021,
    ry: 0.029,
    fill: "#404040"
  }), __jsx("path", {
    d: "M1.865.425H1.86V.423h-.003L1.856.422h-.001V.421h-.002V.42h-.001V.42h-.001L1.85.418 1.85.417V.416h-.001V.415h-.001V.414h-.001V.413L1.845.412V.411L1.844.41V.41L1.843.408V.406h-.001V.403h-.001V.4L1.84.4V.38h.001V.376l.001-.001V.373h.001V.371h.001V.37h.001V.368h.001V.367h.001V.366L1.85.365 1.85.364l.001-.001h.001V.362h.001V.361h.001L1.856.36h.001L1.858.36h.002L1.86.358H1.872l.001.001h.001l.001.001h.001v.001h.001v.001h.001l.001.001.001.001h.001v.002h.001v.001h.001V.37l.001.001v.001h.001v.002h.001v.002l.001.001v.002l.001.001v.003h.001V.404l-.001.001v.002h-.001V.41h-.001V.41l-.001.001v.001l-.001.001v.001h-.001v.001H1.88v.001L1.88.418v.001h-.001L1.877.42 1.876.42h-.001v.001h-.002v.001h-.002v.001H1.87l-.001.001h-.004zm0-.008h.003V.415h.002V.414h.002V.413h.001l.001-.001.001-.001.001-.001V.41h.001V.408h.001V.406h.001V.405L1.88.404V.402h.001V.4l.001-.001V.381H1.88V.378H1.88V.376h-.001V.375L1.877.374V.373h-.001V.372h-.001V.371h-.001V.37h-.001V.37h-.002V.368H1.87L1.87.367h-.003V.366H1.86v.001h-.002V.37h-.002V.37h-.001v.001h-.001v.001h-.001v.001h-.001v.002H1.85v.001H1.85v.002h-.001v.003h-.001v.003h-.001V.402l.001.001v.002h.001v.002h.001v.002h.001V.41h.001V.41h.001v.001l.001.001h.001v.001h.001v.001h.002v.001h.002v.001h.004z",
    fill: "#c69264"
  }), __jsx("ellipse", {
    cx: 1.865,
    cy: 0.562,
    rx: 0.021,
    ry: 0.029,
    fill: "#404040"
  }), __jsx("path", {
    d: "M1.865.595h-.007V.593h-.002V.592h-.002V.591h-.001V.59h-.001V.59H1.85L1.85.588V.587h-.001V.586h-.001V.585h-.001V.583h-.001V.582L1.844.581V.58L1.843.58V.577h-.001V.574h-.001V.57H1.84V.55h.001V.547l.001-.001V.544h.001V.542h.001V.541L1.847.54V.54h.001V.538h.001V.537L1.85.536 1.85.535l.001-.001h.001V.533h.001V.532h.001V.531h.002V.53h.003V.53H1.873v.001h.002v.001h.001v.001h.001l.001.001h.001v.001h.001v.001h.001v.001l.001.001V.54h.001V.54l.001.001v.001h.001v.002h.001v.002h.001V.55h.001v.004h.001V.575h-.001v.003h-.001V.58L1.884.58v.001l-.001.001v.001l-.001.001v.001h-.001v.001H1.88v.001H1.88v.001L1.878.59 1.877.59h-.001v.001h-.001v.001h-.002v.001h-.002v.001h-.003v.001h-.004zm0-.008h.005V.585h.002V.584h.001V.583h.001V.582h.001V.581h.001V.58h.001V.58h.001V.577h.001V.575h.001V.573h.001V.57h.001V.552H1.88V.55H1.88V.547h-.001V.546L1.877.545V.544h-.001V.543h-.001V.542h-.001V.541h-.001V.54h-.001L1.871.54H1.87V.538h-.003V.537H1.86L1.858.54h-.001L1.856.54h-.001v.001h-.001v.001h-.001v.001h-.001v.001h-.001v.001L1.85.547v.001H1.85V.55h-.001v.002l-.001.001v.003h-.001V.573l.001.001v.002h.001v.002h.001V.58h.001V.58h.001v.001h.001v.001h.001v.001h.001v.001h.001v.001h.002v.001h.002l.001.001h.003z",
    fill: "#c69264"
  }), __jsx("path", {
    d: "M.662.321h.166v.295H.662z",
    fill: "#737373"
  }), __jsx("path", {
    d: "M1.033.868l-.2-.01v-.76l.2-.012.1.222V.62l-.1.25z",
    fill: "#a6a6a6"
  }), __jsx("clipPath", {
    id: "ship2_svg__d"
  }, __jsx("path", {
    d: "M512.173 315.35L413 312l.074-276 99.1-4.384L562 112.2v112.914l-49.827 90.235z"
  })), __jsx("g", {
    clipPath: "url(#ship2_svg__d)",
    transform: "matrix(.00202 0 0 .0025 -.019 .03)",
    fontSize: 106.659,
    fontWeight: 700,
    fontFamily: "Menlo"
  }, __jsx("text", {
    x: 505.091,
    y: 154.469,
    transform: "rotate(90 491.959 104.665)",
    fill: "#666"
  }, '7', __jsx("tspan", {
    x: 564.876,
    y: 154.469
  }, '3')), __jsx("text", {
    x: 508.9,
    y: 150.673,
    transform: "rotate(90 495.768 100.868)",
    fill: "#f2f2f2"
  }, '7', __jsx("tspan", {
    x: 568.685,
    y: 150.673
  }, '3'))), __jsx("path", {
    d: "M1.039.88L.832.874V.085L1.04.073l.105.231v.32L1.039.88zM.832.86l.2.009.101-.249V.308l-.1-.222-.2.012v.76z",
    fill: "#e6e6e6",
    fillRule: "nonzero"
  }), __jsx("path", {
    d: "M411.147 149.23c11.726 11.727 11.726 30.738 0 42.464-11.726 11.725-30.737 11.725-42.463 0-11.725-11.726-11.725-30.737 0-42.463 11.726-11.724 30.737-11.724 42.463 0z",
    fill: "#b3b3b3",
    stroke: "#ccc",
    strokeWidth: 2,
    strokeLinecap: "butt",
    strokeLinejoin: "miter",
    transform: "matrix(.00203 0 0 .00232 -.004 .075)"
  }), __jsx("path", {
    d: "M.86.556a.01.01 0 0 0 0-.013L.733.398a.007.007 0 0 0-.01 0L.71.41a.01.01 0 0 0 0 .013l.127.145a.007.007 0 0 0 .01 0L.86.556z",
    fill: "gray"
  }), __jsx("path", {
    d: "M426.684 201.694a3.915 3.915 0 0 0 0-5.538l-62.462-62.462a3.915 3.915 0 0 0-5.538 0l-5.537 5.537a3.917 3.917 0 0 0 0 5.54l62.462 62.46a3.913 3.913 0 0 0 5.537 0l5.537-5.536z",
    fill: "#f2f2f2",
    stroke: "#ccc",
    strokeWidth: 2,
    strokeLinecap: "butt",
    strokeLinejoin: "miter",
    transform: "matrix(.00203 0 0 .00232 -.004 .075)"
  }), __jsx("ellipse", {
    cx: 0.582,
    cy: 0.475,
    rx: 0.094,
    ry: 0.313,
    fill: "#333"
  }), __jsx("clipPath", {
    id: "ship2_svg__e"
  }, __jsx("ellipse", {
    cx: 289.516,
    cy: 172.707,
    rx: 46.484,
    ry: 113.707
  })), __jsx("g", {
    clipPath: "url(#ship2_svg__e)",
    transform: "matrix(.00202 0 0 .00276 -.003 -.001)",
    fill: "#4d4d4d"
  }, __jsx("path", {
    d: "M369.347 167.962l-110.31-110.31-18.384 18.386 110.31 110.31 18.384-18.386zm-20 50l-110.31-110.31-18.384 18.386 110.31 110.31 18.384-18.386zm-10 60l-110.31-110.31-18.384 18.386 110.31 110.31 18.384-18.386z"
  })), __jsx("ellipse", {
    cx: 0.582,
    cy: 0.475,
    rx: 0.094,
    ry: 0.313,
    fill: "none",
    stroke: "#4d4d4d",
    strokeWidth: 0.024
  }), __jsx("g", null, __jsx("path", {
    d: "M347.41 350.742c-19.263-9.002-27.58-31.916-18.578-51.18 9.002-19.263 31.916-27.58 51.18-18.578 19.262 9.002 27.58 31.916 18.578 51.18-9.003 19.262-31.917 27.58-51.18 18.578z",
    fill: "#f2f2f2",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00203 0 0 .00217 -.006 .211)"
  }), __jsx("path", {
    d: "M.706.995L.716 1 .75.92.74.916l-.034.08zM.67.977L.68.98.713.903.703.898.67.977z",
    fill: "#737373"
  })), __jsx("g", null, __jsx("path", {
    d: "M354.57 11.176c20.54-5.504 41.65 6.685 47.153 27.223 5.504 20.538-6.685 41.65-27.223 47.152-20.54 5.503-41.65-6.685-47.153-27.224-5.503-20.538 6.685-41.65 27.224-47.152z",
    fill: "#f2f2f2",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00203 0 0 .00209 -.007 0)"
  }), __jsx("path", {
    d: "M.695.01l-.01.003.021.08.01-.002-.021-.08zM.735 0l-.01.002.02.081.01-.003L.735 0z",
    fill: "#737373"
  })));
};

/* harmony default export */ __webpack_exports__["default"] = (SvgShip2);

/***/ }),

/***/ "./src/games/seabattle/media/SvgShip3.tsx":
/*!************************************************!*\
  !*** ./src/games/seabattle/media/SvgShip3.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_1xhw0lqvmb() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgShip3.tsx";
  var hash = "0aed86e4115ae39fd9946baa55c02ca255c77b3d";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgShip3.tsx",
    statementMap: {
      "0": {
        start: {
          line: 4,
          column: 17
        },
        end: {
          line: 249,
          column: 1
        }
      },
      "1": {
        start: {
          line: 5,
          column: 2
        },
        end: {
          line: 248,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 4,
            column: 17
          },
          end: {
            line: 4,
            column: 18
          }
        },
        loc: {
          start: {
            line: 5,
            column: 2
          },
          end: {
            line: 248,
            column: 6
          }
        },
        line: 5
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0
    },
    f: {
      "0": 0
    },
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "0aed86e4115ae39fd9946baa55c02ca255c77b3d"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_1xhw0lqvmb = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_1xhw0lqvmb();

/* tslint:disable */

cov_1xhw0lqvmb().s[0]++;

var SvgShip3 = function SvgShip3() {
  cov_1xhw0lqvmb().f[0]++;
  cov_1xhw0lqvmb().s[1]++;
  return __jsx("g", null, __jsx("path", {
    d: "M1.5 0c.827 0 1.497.29 1.497.47S2.327.941 1.5.941C.89.941.244.852.117.763-.009.673.003.538.003.47c0-.087-.01-.255.12-.325C.255.075.951 0 1.5 0z",
    fill: "#595959"
  }), __jsx("clipPath", {
    id: "ship3_svg__a"
  }, __jsx("path", {
    d: "M750.5 3C1163.33 3 1498 108.926 1498 174.5S1163.33 346 750.5 346c-304.884 0-627.266-32.35-690.5-65-63.234-32.65-57-81.733-57-106.5C3 142.738-2.593 81.51 63 56 128.593 30.49 476.103 3 750.5 3z"
  })), __jsx("g", {
    clipPath: "url(#ship3_svg__a)",
    transform: "matrix(.002 0 0 .00274 -.003 -.008)"
  }, __jsx("ellipse", {
    cx: 980.653,
    cy: 176.066,
    rx: 97.941,
    ry: 70.982,
    fill: "none",
    stroke: "#dc504b",
    strokeWidth: 3.838,
    strokeDasharray: "38.38093721 38.38093721 0 0"
  }), __jsx("ellipse", {
    cx: 275.069,
    cy: 178.8,
    rx: 79.996,
    ry: 57.748,
    fill: "none",
    stroke: "#999",
    strokeWidth: 4.798
  }), __jsx("path", {
    d: "M816-4L382 7l-39 107v120l39 107 434 13 92-145v-73L816-4z",
    fill: "gray",
    stroke: "#a6a6a6",
    strokeWidth: 4
  }), __jsx("path", {
    d: "M202.18 277.626a5.362 5.362 0 0 0-1.963-7.327l-108.39-62.58a5.362 5.362 0 0 0-7.327 1.963L71.72 231.82a5.362 5.362 0 0 0 1.963 7.326l108.39 62.58a5.366 5.366 0 0 0 7.327-1.964l12.78-22.136zm0-210.806a5.362 5.362 0 0 1-1.963 7.326l-108.39 62.58a5.366 5.366 0 0 1-7.327-1.964l-12.78-22.136a5.362 5.362 0 0 1 1.963-7.327l108.39-62.58a5.362 5.362 0 0 1 7.327 1.963l12.78 22.136z",
    fill: "#999",
    stroke: "#a6a6a6",
    strokeWidth: 4
  })), __jsx("path", {
    d: "M1.13.354C1.13.346 1.13.34 1.128.34h-.13C.995.34.993.346.993.354v.252c0 .008.002.014.004.014h.13c.002 0 .004-.006.004-.014V.354z",
    fill: "#595959"
  }), __jsx("path", {
    d: "M.997.62H.995V.618H.994V.616H.993V.612L.992.611V.344L.995.343V.341h.001V.34h.133v.001h.001v.003h.001v.272h-.001V.62h-.002V.62h-.13zm.006-.014h.118V.354h-.118v.252z",
    fill: "#bfbfbf"
  }), __jsx("ellipse", {
    cx: 2.76,
    cy: 0.413,
    rx: 0.021,
    ry: 0.029,
    fill: "#404040"
  }), __jsx("path", {
    d: "M2.76.446h-.004L2.754.444h-.002V.443H2.75V.442H2.75L2.748.441h-.001V.44h-.001V.44h-.001V.438h-.001V.437h-.001V.436L2.742.435V.434h-.001V.433L2.74.432V.431L2.74.43V.428h-.001V.425h-.001V.422L2.736.421V.4L2.739.4V.397L2.74.396V.394h.001V.392h.001V.391L2.743.39V.39h.001V.388h.001V.387l.001-.001.001-.001.001-.001.001-.001h.001V.382h.002V.381h.002V.38h.003V.38H2.767l.001.001h.001l.001.001h.001v.001h.001l.001.001h.001v.001h.001v.001h.001v.001h.001V.39h.001V.39h.001v.001l.001.001v.001l.001.001v.001l.001.001v.002L2.783.4v.003h.001v.006h.001V.423l-.001.001v.003h-.001v.002L2.78.43v.002H2.78v.001l-.001.001v.001l-.001.001v.001h-.001v.001h-.001v.001h-.001V.44L2.773.44h-.001v.001h-.001v.001H2.77v.001h-.001l-.001.001h-.002v.001H2.76zm0-.01h.006V.434h.002V.433h.001V.432h.001V.431h.001V.43h.001V.43h.001V.427h.001V.426h.001V.424l.001-.001V.421L2.778.42V.416l.001-.001V.403h-.001V.4h-.001V.398h-.001V.396h-.001V.395h-.001V.393h-.001V.392H2.77V.391H2.77V.39h-.002V.39h-.001L2.765.388h-.002L2.762.387h-.008V.39h-.002V.39h-.001v.001H2.75v.001H2.75l-.001.001-.001.001v.001h-.001v.002h-.001v.001L2.744.4v.002h-.001v.003h-.001V.423l.001.001v.002h.001v.002h.001v.001l.001.001V.43h.001v.001h.001v.001h.001v.001h.001v.001h.002v.001h.002v.001h.005z",
    fill: "#c69264"
  }), __jsx("ellipse", {
    cx: 2.76,
    cy: 0.55,
    rx: 0.021,
    ry: 0.029,
    fill: "#404040"
  }), __jsx("path", {
    d: "M2.76.583h-.005V.581h-.002L2.751.58H2.75V.58h-.002V.578h-.001V.577h-.001V.576h-.001V.575h-.001V.574h-.001V.573L2.742.572V.571h-.001V.57L2.74.57V.568H2.74V.566L2.738.565V.563L2.737.562V.56L2.736.558V.537l.001-.001V.534L2.74.533V.531h.001V.53h.001V.528h.001V.526h.001V.525h.001V.524h.001V.523h.001V.522l.001-.001h.001V.52h.001L2.75.52h.001V.518h.002V.517h.004V.516H2.767v.001h.002V.52h.002V.52h.001v.001h.001l.001.001h.001v.001h.001v.001l.001.001v.001h.001v.001h.001V.53h.001v.002h.001v.002h.001v.002l.001.001V.54h.001v.006h.001V.56L2.782.56v.003h-.001v.003H2.78v.002H2.78V.57h-.001v.001l-.001.001v.001h-.001v.001h-.001v.001l-.001.001-.001.001-.001.001h-.001V.58H2.77L2.77.58h-.001v.001h-.002l-.001.001h-.004L2.76.584zm0-.009h.004l.001-.001h.001l.001-.001h.001V.57h.001L2.77.57l.001-.001V.567h.001V.566h.001V.565l.001-.001V.563h.001V.561L2.777.56V.558l.001-.001V.553l.001-.001V.541L2.776.54V.538L2.775.537V.535h-.001V.533h-.001V.532h-.001V.531L2.771.53V.53H2.77L2.77.528 2.768.527h-.001V.526h-.002V.525h-.003L2.761.524h-.007v.001h-.001l-.001.001h-.001v.001H2.75V.53H2.75V.53h-.001v.001h-.001v.001h-.001v.002h-.001v.002h-.001v.002h-.001v.003h-.001V.56h.001v.002h.001v.002h.001v.002h.001v.001h.001v.001h.001V.57h.001V.57h.001v.001h.001l.001.001h.002v.001h.004v.001h.001z",
    fill: "#c69264"
  }), __jsx("ellipse", {
    cx: 1.961,
    cy: 0.48,
    rx: 0.123,
    ry: 0.17,
    fill: "#999"
  }), __jsx("path", {
    d: "M1.918.67c-.07-.11-.072-.29.002-.383l.145.097v.192l-.147.095",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship3_svg__b"
  }, __jsx("path", {
    d: "M958.916 247.542c-35.244-40.175-35.723-106.15 1.063-140l72.69 35.56-.53 70-73.224 34.44"
  })), __jsx("g", {
    clipPath: "url(#ship3_svg__b)",
    transform: "matrix(.002 0 0 .00274 -.003 -.008)"
  }, __jsx("path", {
    d: "M1037.87 170.304l-60.8-.467-.114 15 60.794.467.12-15z",
    fill: "#4d4d4d"
  }), __jsx("path", {
    d: "M1040.73 188.327l-66.797-.514.16-21 66.797.514-.16 21zm-2.98-3.023l.12-15-60.8-.467-.114 15 60.794.467z",
    fill: "#b3b3b3"
  })), __jsx("path", {
    d: "M1.918.67c-.07-.11-.072-.29.002-.383l.145.097v.192l-.147.095",
    fill: "none",
    stroke: "#e6e6e6",
    strokeWidth: 0.007
  }), __jsx("path", {
    d: "M2.282.473L1.96.466V.49l.322-.001V.472z",
    fill: "#e6e6e6"
  }), __jsx("ellipse", {
    cx: 2.458,
    cy: 0.486,
    rx: 0.16,
    ry: 0.16,
    fill: "none",
    stroke: "#999",
    strokeWidth: 0.011
  }), __jsx("ellipse", {
    cx: 2.454,
    cy: 0.477,
    rx: 0.092,
    ry: 0.127,
    fill: "#999"
  }), __jsx("path", {
    d: "M2.372.416V.402h-.001V.384h.001V.368l.02.017.213.004c.002 0 .006.004.006.006S2.607.4 2.605.4h-.213l-.02.014z",
    fill: "#fff"
  }), __jsx("clipPath", {
    id: "ship3_svg__c"
  }, __jsx("path", {
    d: "M1185.9 154.545l-.08-5.068h-.82v-6.408h.92l.08-6.07 9.9 6.275s88.58.878 106.1 1.5c1.24.043 3 1.483 3 2.225s-1.76 2.196-3 2.226c-17.52.414-106.1.26-106.1.26l-10 5.06z"
  })), __jsx("g", {
    clipPath: "url(#ship3_svg__c)",
    transform: "matrix(.002 0 0 .00274 -.003 -.008)"
  }, __jsx("path", {
    d: "M1285 144h21v6h-21z",
    fill: "#e2201f",
    stroke: "#999",
    strokeWidth: 2
  })), __jsx("path", {
    d: "M2.372.591V.577h-.001V.56h.001V.543l.02.017.213.004c.002 0 .006.004.006.006s-.004.006-.006.006l-.213.001-.02.014z",
    fill: "#fff"
  }), __jsx("clipPath", {
    id: "ship3_svg__d"
  }, __jsx("path", {
    d: "M1185.9 218.545l-.08-5.068h-.82v-6.408h.92l.08-6.07 9.9 6.275s88.58.878 106.1 1.5c1.24.043 3 1.483 3 2.225s-1.76 2.196-3 2.226c-17.52.414-106.1.26-106.1.26l-10 5.06z"
  })), __jsx("g", {
    clipPath: "url(#ship3_svg__d)",
    transform: "matrix(.002 0 0 .00274 -.003 -.008)"
  }, __jsx("path", {
    d: "M1285 208h21v6h-21z",
    fill: "#e2201f",
    stroke: "#999",
    strokeWidth: 2
  })), __jsx("path", {
    d: "M2.465.542V.59h-.062V.537C2.386.527 2.375.506 2.375.48c0-.026.011-.048.028-.057V.37h.062v.048h.031c.025 0 .045.028.045.062s-.02.062-.045.062h-.031z",
    fill: "#ccc",
    stroke: "#e6e6e6",
    strokeWidth: 0.007
  }), __jsx("ellipse", {
    cx: 0.549,
    cy: 0.477,
    rx: 0.092,
    ry: 0.127,
    fill: "#999"
  }), __jsx("path", {
    d: "M.63.416V.402h.002V.384H.63V.368L.61.385.398.389C.395.389.392.393.392.395S.395.4.398.4H.61l.02.014z",
    fill: "#fff"
  }), __jsx("clipPath", {
    id: "ship3_svg__e"
  }, __jsx("path", {
    d: "M316.046 154.545l.078-5.068h.818v-6.408h-.922l-.078-6.07-9.903 6.275s-88.582.878-106.098 1.5c-1.244.043-3 1.483-3 2.225s1.755 2.196 3 2.226c17.516.414 106.097.26 106.097.26l10.006 5.06z"
  })), __jsx("g", {
    clipPath: "url(#ship3_svg__e)",
    transform: "matrix(.002 0 0 .00274 -.003 -.008)"
  }, __jsx("path", {
    d: "M195.942 144h21v6h-21z",
    fill: "#e2201f",
    stroke: "#999",
    strokeWidth: 2
  })), __jsx("path", {
    d: "M.63.591V.577h.002V.56H.63V.543L.61.56.398.564C.395.564.392.568.392.57s.003.006.006.006L.61.577l.02.014z",
    fill: "#fff"
  }), __jsx("clipPath", {
    id: "ship3_svg__f"
  }, __jsx("path", {
    d: "M316.046 218.545l.078-5.068h.818v-6.408h-.922l-.078-6.07-9.903 6.275s-88.582.878-106.098 1.5c-1.244.043-3 1.483-3 2.225s1.755 2.196 3 2.226c17.516.414 106.097.26 106.097.26l10.006 5.06z"
  })), __jsx("g", {
    clipPath: "url(#ship3_svg__f)",
    transform: "matrix(.002 0 0 .00274 -.003 -.008)"
  }, __jsx("path", {
    d: "M195.942 208h21v6h-21z",
    fill: "#e2201f",
    stroke: "#999",
    strokeWidth: 2
  })), __jsx("path", {
    d: "M.538.542V.59H.6V.537C.616.527.628.506.628.48.628.454.616.432.6.423V.37H.538v.048H.507C.482.418.462.446.462.48s.02.062.045.062h.031z",
    fill: "#ccc",
    stroke: "#e6e6e6",
    strokeWidth: 0.007
  }), __jsx("path", {
    d: "M1.082.877a.158.158 0 0 0-.088-.06A1.224 1.224 0 0 0 .845.795C.838.794.831.801.83.811L.825.867c0 .01.005.02.013.02 0 0 .094.022.148.024.055.002.096-.03.096-.034z",
    fill: "#c69264",
    stroke: "#e6e6e6",
    strokeWidth: 0.009
  }), __jsx("path", {
    d: "M.986.894C1.01.9 1.016.84.991.834L.85.813C.845.812.842.815.842.82L.838.862c0 .005.002.009.006.01l.142.023z",
    fill: "#968474",
    stroke: "#595959",
    strokeWidth: 0.002
  }), __jsx("path", {
    d: "M1.079.089a.157.157 0 0 1-.088.06C.938.162.842.171.842.171.835.173.828.165.827.156L.822.1c0-.01.005-.02.012-.021 0 0 .095-.022.15-.024.054-.002.094.03.095.034z",
    fill: "#c69264",
    stroke: "#e6e6e6",
    strokeWidth: 0.009
  }), __jsx("path", {
    d: "M.983.073c.023-.006.03.053.005.058L.845.154C.842.154.84.151.84.146L.835.104C.835.1.837.095.84.094L.983.071z",
    fill: "#968474",
    stroke: "#595959",
    strokeWidth: 0.002
  }), __jsx("path", {
    d: "M1.055.28c0-.013-.005-.022-.012-.022h-.36c-.006 0-.01.01-.01.021v.397c0 .011.004.02.01.02h.36c.007 0 .012-.01.012-.02V.279z",
    fill: "#595959"
  }), __jsx("path", {
    d: "M.727.697H.681V.695H.68V.694H.678L.677.693V.692H.676V.691H.675V.69H.674V.687L.673.686V.683H.672V.268L.675.267V.265h.001V.263h.001V.261h.001V.26h.001V.26H.68L.68.258h.002V.257h.364l.001.001h.001V.26h.001v.001l.001.001v.001h.001v.002h.001v.002h.001v.004h.001V.687h-.001V.69h-.001v.002H1.05v.001H1.05v.001l-.001.001h-.001v.001h-.001v.001h-.32zM.684.683h.359V.68h.001V.271h-.36v.001H.682V.683h.001v.001z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1.055.28c0-.013-.005-.022-.012-.022H.74v.088H.672v.266H.74v.085h.303c.007 0 .012-.01.012-.022V.28z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M.75.683h.293V.68h.001V.271H.75v.087H.682v.239H.75v.085zM.74.697V.612H.672V.346H.74V.258h.306V.26h.002V.26h.001v.001l.001.001v.001h.001v.002h.001v.002l.001.001v.003h.001V.687h-.001V.69h-.001v.002H1.05v.001H1.05v.002h-.001l-.001.001h-.001v.001H.74z",
    fill: "#d9d9d9"
  }), __jsx("path", {
    d: "M1.606.016H1.17v.908h.435l.026-.083V.103L1.606.016z",
    fill: "#595959"
  }), __jsx("path", {
    d: "M1.17.924V.016h.436l.026.087v.738l-.026.083H1.17zm.01-.013H1.6l.023-.072V.106L1.599.03H1.18v.88z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1.564.282h-.045V.154H1.17v.658h.35V.699h.044l.038-.04V.32L1.564.281z",
    fill: "#8c8c8c"
  }), __jsx("path", {
    d: "M1.18.798h.33V.686h.05l.031-.034V.325l-.03-.03h-.052V.168H1.18v.631zm.34.014h-.35V.154h.35v.128h.044l.038.036V.66L1.564.7h-.045v.113z",
    fill: "#d9d9d9"
  }), __jsx("path", {
    d: "M1.32.31h.131v.337H1.32z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1.32.647V.31h.131v.337H1.32zm.01-.013h.111v-.31H1.33v.31z",
    fill: "#d9d9d9"
  }), __jsx("path", {
    d: "M1.487.807c0-.02-.012-.036-.026-.036H1.29c-.014 0-.026.016-.026.036 0 .02.012.035.026.035h.172c.014 0 .026-.016.026-.035zm0-.648c0-.02-.012-.036-.026-.036H1.29c-.014 0-.026.016-.026.036 0 .02.012.036.026.036h.172c.014 0 .026-.016.026-.036z",
    fill: "#f2f2f2"
  }), __jsx("path", {
    d: "M1.129.181h.174l.043.08v.457l-.037.064h-.18L1.093.718V.26l.036-.08z",
    fill: "#b3b3b3"
  }), __jsx("path", {
    d: "M1.129.782L1.093.718V.26l.036-.08h.174l.043.08v.457l-.037.064h-.18zm.005-.014h.17l.032-.055V.265l-.038-.07h-.164l-.031.07v.448l.03.055z",
    fill: "#d9d9d9"
  }), __jsx("path", {
    d: "M1.345.392h-.168L1.153.42v.129l.024.03h.168V.392z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1.455.483c0-.034-.02-.06-.044-.06h-.178c-.024 0-.044.026-.044.06 0 .033.02.06.044.06h.178c.025 0 .044-.027.044-.06z",
    fill: "#ccc"
  }), __jsx("path", {
    d: "M1.233.54h.178l.001-.001h.006L1.42.537h.002l.001-.001h.002V.535h.002V.534h.002V.533h.001V.532h.002V.531h.001V.53h.001V.53h.001V.528h.001V.527h.001V.526h.001V.525h.001V.524h.001V.522h.001V.521h.001V.52h.001V.518h.001V.516h.001V.515l.001-.001V.513l.001-.001V.51h.001V.508l.001-.001V.505L1.45.504V.501h.001V.497l.001-.001V.49L1.453.49V.468H1.45V.464L1.45.463V.46h-.001V.457h-.001V.455L1.446.454V.452h-.001V.45h-.001V.448h-.001V.447L1.442.446V.445h-.001V.444L1.44.443V.442H1.44V.441h-.001V.44L1.437.44V.438h-.001V.437h-.001V.436h-.001V.435h-.001L1.432.434 1.431.433H1.43V.432H1.43L1.428.431h-.001V.43h-.002V.43h-.002V.428h-.002L1.42.427h-.003V.426h-.194v.001H1.22V.43h-.002V.43h-.002v.001h-.001l-.001.001h-.001v.001h-.001v.001h-.001v.001H1.21v.001H1.21v.001h-.001v.001h-.001V.44h-.001V.44h-.001v.001h-.001v.001h-.001v.002h-.001v.001h-.001v.002H1.2V.45H1.2V.45l-.001.001v.001l-.001.001v.002h-.001v.003h-.001v.003h-.001v.003l-.001.001V.47L1.192.47v.008h-.001V.496h.001V.5h.001v.003l.001.001v.002l.001.001V.51h.001v.002l.001.001v.001L1.2.515v.001L1.2.517v.001l.001.001V.52h.001V.52l.001.001v.001h.001v.001l.001.001.001.001v.001h.001v.001h.001v.001h.001V.53h.001V.53h.001l.001.001h.001v.001h.001v.001h.001l.001.001h.001v.001h.002v.001h.002l.001.001h.002l.001.001h.005V.54h.003zm0 .008h-.008V.546h-.003V.545H1.22L1.218.544h-.002V.543h-.002V.542h-.001V.541h-.002V.54H1.21V.54H1.21L1.208.538h-.001V.537h-.001V.536h-.001V.535h-.001V.534h-.001V.533L1.202.532 1.201.531V.53H1.2V.53H1.2V.528L1.198.527V.526h-.001V.525L1.196.524V.523h-.001V.521h-.001V.52h-.001V.517h-.001V.515h-.001V.512H1.19V.51H1.19V.506h-.001V.502h-.001V.497h-.001V.487h-.001V.47h.001V.464h.001V.46h.001V.457h.001V.454h.001V.451h.001V.45h.001V.447h.001V.445h.001V.443h.001V.442l.001-.001V.44h.001V.44L1.2.438V.437H1.2V.436h.001V.435l.001-.001V.433h.001V.432h.001V.431h.001V.43h.001V.43h.001V.428h.001V.427h.002V.426h.001V.425h.001l.001-.001h.001V.423h.002V.422h.002V.421h.002L1.222.42h.003V.42h.005L1.23.418h.189V.42h.003l.001.001h.002v.001h.002v.001h.002v.001h.001l.001.001h.001v.001h.001l.001.001h.001v.001h.001V.43h.001V.43h.001v.001h.001v.001h.001v.001h.001v.001h.001v.001l.001.001v.001h.001v.001h.001V.44l.001.001v.001h.001v.002h.001v.001l.001.001v.001l.001.001v.001l.001.001v.002h.001v.002h.001v.003h.001V.46h.001v.004h.001v.004l.001.001v.007h.001V.499h-.001v.005h-.001v.003l-.001.001V.51h-.001v.002l-.001.001v.002h-.001v.002L1.45.519V.52L1.45.52v.001l-.001.001v.001h-.001v.002h-.001v.001h-.001v.002h-.001V.53L1.443.53l-.001.001v.001h-.001v.001H1.44v.001H1.44v.001h-.001v.001h-.001v.001h-.001v.001h-.001V.54h-.001L1.433.54h-.001v.001h-.001v.001H1.43v.001h-.002v.001h-.002v.001h-.002l-.001.001H1.42v.001h-.005l-.001.001h-.181z",
    fill: "#999"
  }), __jsx("path", {
    d: "M1.037.477c0-.033-.02-.06-.044-.06h-.11c-.025 0-.045.027-.045.06 0 .034.02.06.045.06h.11c.024 0 .044-.026.044-.06z",
    fill: "#ccc"
  }), __jsx("path", {
    d: "M.883.534h.115V.532h.004V.531h.002L1.006.53h.002V.53h.001L1.01.528h.001V.527h.002V.526h.001V.525h.001V.524h.001V.523h.001V.522h.001V.521h.001V.52h.001V.52h.001V.518h.001V.516h.001V.515h.001V.513h.001V.512l.001-.001V.51h.001V.508h.001V.506l.001-.001V.503h.001V.501L1.03.5V.497h.001V.493h.001V.488l.001-.001V.461h-.001V.457L1.03.456V.454L1.03.453V.451h-.001V.448h-.001V.446h-.001V.444h-.001V.442h-.001V.441L1.023.44V.44h-.001V.438L1.021.437V.436H1.02V.435H1.02V.434h-.001V.433L1.017.432 1.016.431 1.015.43h-.001V.43h-.001V.428h-.001V.427h-.001V.426H1.01V.425h-.001L1.007.424h-.002V.423h-.002V.422H1V.421H.994V.42H.874v.001H.871v.001H.87v.001H.867v.001H.865v.001H.864v.001H.862v.001H.861V.43H.86V.43H.86v.001H.858v.001H.857v.001H.856v.001H.855v.001H.854v.001H.853v.002H.852V.44H.851v.002H.85v.001L.85.444v.001H.848v.002L.847.448v.001L.846.45v.002H.845v.003H.844v.003H.843v.004H.842v.006H.841V.493h.001v.004l.001.001V.5L.846.5v.003h.001v.002h.001v.002l.001.001V.51H.85v.002H.85v.002h.001v.001l.001.001v.001h.001v.001h.001V.52h.001V.52h.001v.001h.001v.001h.001v.001H.86v.001H.86v.001h.001v.001h.002v.001h.001v.001h.001L.867.53h.001L.869.53H.87L.87.532h.002v.001h.003l.001.001h.006zm0 .009H.875V.541H.872L.871.54H.87V.54H.867L.866.538H.865L.864.537H.863V.536H.861V.535H.86V.534H.86L.858.533H.857V.532H.856V.531H.855V.53H.854V.53H.853V.528H.852V.527H.851V.526L.85.525V.524H.85V.523H.848V.522L.847.521V.52H.846V.52L.845.518V.517L.844.516V.515H.843V.513H.842V.511L.841.51V.508H.84V.506L.84.505V.503L.838.502V.5H.837V.494H.836V.488H.835V.462L.838.461V.457L.839.456V.454L.84.453V.45H.84V.447h.001V.445h.001V.443L.844.442V.441L.845.44V.44h.001V.437h.001V.436L.848.435V.434h.001V.432H.85V.431H.85V.43L.852.43.853.428V.427h.001L.855.426V.425h.001V.424h.001L.858.423.859.422H.86V.421H.86V.42h.001L.863.42h.001V.418h.002V.417h.001L.868.416H.87V.415h.003V.414h.004V.413h.126v.001h.003v.001h.002v.001h.002v.001h.002V.42h.002V.42h.001v.001h.001l.001.001h.001v.001h.001v.001h.001v.001h.001v.001h.001v.001h.001v.001h.001V.43l.001.001v.001h.001v.001h.001v.001l.001.001v.001h.001v.001l.001.001v.001h.001V.44h.001v.002h.001v.002l.001.001v.002h.001V.45h.001v.003l.001.001v.002l.001.001V.46h.001v.005l.001.001V.496h-.001V.5L1.036.5v.002l-.001.001v.003h-.001v.002h-.001v.003h-.001v.002h-.001v.002H1.03v.002H1.03v.001L1.028.52V.52l-.001.001v.001h-.001v.001h-.001v.001l-.001.001v.001h-.001v.001h-.001v.001h-.001V.53H1.02V.53H1.02v.001h-.001v.001h-.001v.001h-.001v.001h-.001l-.001.001h-.001v.001h-.001l-.001.001H1.01v.001h-.002V.54h-.002V.54h-.003v.001H1L1 .543H.882z",
    fill: "#999"
  }), __jsx("path", {
    d: "M.718.414h.094v.13H.718z",
    fill: "#ccc"
  }), __jsx("path", {
    d: "M.721.54H.81V.417H.721V.54zM.715.547V.411h.1v.137h-.1z",
    fill: "#999"
  }), __jsx("path", {
    d: "M1.379.483c0-.021-.013-.039-.028-.039h-.114c-.015 0-.028.018-.028.039s.013.039.028.039h.114c.015 0 .028-.018.028-.04z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1.237.521H1.23V.52h-.002V.518h-.002V.517h-.001L1.223.516h-.001V.515h-.001V.514H1.22V.513H1.22V.512h-.001V.511h-.001V.51L1.216.51V.508h-.001V.506h-.001V.505L1.213.504V.503L1.212.502V.5h-.001V.497H1.21V.493H1.21V.485h-.001V.473L1.21.472V.468h.001V.465h.001V.463l.001-.001V.461L1.215.46V.46h.001V.457h.001V.456l.001-.001.001-.001V.453h.001V.452h.001V.451h.001V.45h.001V.45h.001l.001-.001.001-.001h.001l.001-.001h.001L1.23.445h.002l.001-.001h.126v.001h.002v.001h.002v.001h.001l.001.001.001.001h.001v.001h.001v.001h.001v.001h.001v.001l.001.001v.001h.001v.001l.001.001V.46h.001v.002h.001v.002h.001v.003h.001V.47h.001v.004l.001.001V.496l-.001.001V.5h-.001v.002l-.001.001v.002h-.001v.002h-.001v.001l-.001.001V.51H1.37V.51H1.37v.001l-.001.001-.001.001v.001h-.001l-.001.001-.001.001h-.001v.001h-.001v.001H1.36V.52h-.002V.52h-.003l-.001.001H1.236zm0-.013h.117V.506h.003V.505h.001V.504h.001L1.36.503h.001V.502h.001V.501L1.364.5V.5h.001V.497h.001V.496l.001-.001V.493h.001V.49h.001V.472h-.001V.47h-.001V.468L1.364.467V.466h-.001V.465L1.362.464V.463h-.001V.462H1.36V.461H1.36L1.358.46h-.001V.46h-.002V.458H1.23V.46h-.002v.001h-.001v.001h-.001v.001h-.001v.001h-.001v.001h-.001v.002h-.001v.001L1.221.47v.002H1.22v.003H1.22V.48h-.001V.49l.001.001v.003h.001v.002h.001v.002h.001V.5h.001v.001h.001v.001h.001v.001h.001v.001h.001v.001h.002v.001h.002v.001h.005z",
    fill: "#d9d9d9"
  }), __jsx("ellipse", {
    cx: 1.414,
    cy: 0.481,
    rx: 0.033,
    ry: 0.045,
    fill: "#f2f2f2"
  }), __jsx("path", {
    d: "M1.381.368c0-.014-.008-.025-.018-.025h-.162c-.01 0-.018.011-.018.025 0 .013.008.024.018.024h.162c.01 0 .018-.01.018-.024zM1.38.612c0-.014-.008-.025-.018-.025H1.2c-.01 0-.018.011-.018.025 0 .013.008.024.018.024h.162c.01 0 .018-.01.018-.024zM.987.73V.86C.986.871.97.87.969.861V.76H.866v.094C.865.862.85.862.848.854V.727h.139V.73zm0-.502V.096C.986.087.97.088.969.096v.102H.866V.103C.865.095.85.095.848.103V.23h.139V.227z",
    fill: "#d9d9d9"
  }), __jsx("path", {
    d: "M1.265.09c0-.02-.012-.035-.026-.035-.015 0-.026.016-.026.036v.767c0 .02.011.036.026.036.014 0 .026-.016.026-.036V.091z",
    fill: "#ccc"
  }), __jsx("path", {
    d: "M1.239.898h-.007V.896H1.23L1.228.895h-.001L1.226.894h-.001V.893h-.001L1.223.892 1.222.891 1.221.89 1.22.89 1.22.888V.887h-.001V.886h-.001V.885L1.216.884V.883h-.001V.881h-.001V.88h-.001V.877h-.001V.874L1.211.873V.87H1.21V.864H1.21V.08l.001-.001V.075h.001V.072h.001V.07h.001V.067h.001V.066l.001-.001V.064h.001V.063l.001-.001V.061h.001V.06h.001V.06l.001-.001h.001V.057h.001V.056h.001V.055h.001V.054h.002V.053h.001L1.23.052h.002V.051h.004V.05H1.246l.001.001h.002v.001h.002v.001h.001l.001.001h.001v.001h.001v.001h.001v.001h.001V.06h.001V.06h.001v.001h.001v.001l.001.001v.001l.001.001v.001h.001v.002h.001V.07h.001v.002l.001.001v.002l.001.001V.08l.001.001v.007h.001v.781h-.001v.004l-.001.001v.002l-.001.001v.002h-.001V.88l-.001.001v.001h-.001v.002H1.26v.001L1.26.887v.001h-.001v.001h-.001V.89h-.001V.89h-.001v.001h-.001v.001h-.001v.001h-.001v.001H1.25v.001H1.25l-.001.001h-.002v.001h-.003v.001h-.005zm0-.009h.006V.887h.002V.886h.002V.885h.001V.884h.001V.883h.001l.001-.001V.881h.001V.88h.001V.88l.001-.001V.877h.001V.875h.001V.873h.001V.871L1.26.87V.867h.001V.86h.001V.08H1.26V.077L1.26.076V.074h-.001V.072L1.257.071V.07h-.001V.068h-.001V.067L1.254.066 1.253.065V.064h-.001V.063h-.001V.062H1.25V.061h-.001V.06h-.002V.06h-.002V.058H1.231V.06H1.23v.001h-.001l-.001.001h-.001v.001h-.001v.001h-.001v.001h-.001v.001l-.001.001v.001h-.001V.07H1.22v.002H1.22v.002h-.001v.002l-.001.001V.08h-.001v.005h-.001v.783l.001.001v.003h.001v.002l.001.001v.001l.001.001v.001h.001V.88h.001V.88h.001v.001l.001.001.001.001v.001h.001l.001.001h.001v.001h.001l.001.001h.001l.001.001h.002l.001.001h.003z",
    fill: "#999"
  }), __jsx("path", {
    d: "M1.013.206C1.013.186 1 .17.987.17.972.17.96.186.96.206v.543c0 .02.012.036.027.036.014 0 .026-.016.026-.036V.206z",
    fill: "#ccc"
  }), __jsx("path", {
    d: "M.987.789H.981L.98.787H.978V.786H.976L.975.785H.974V.784H.972V.783H.971V.782H.97V.781H.97V.78H.968V.78H.967V.778H.966V.777L.965.776V.775H.964V.774H.963V.772H.962V.77H.961V.768H.96V.765H.96V.762L.958.761V.757H.957V.193L.96.192V.19H.96V.186h.001V.184L.963.183V.182L.964.181V.18h.001V.18L.966.178V.177h.001V.176L.968.175h.001V.174L.97.173.97.172.972.171h.001V.17h.001V.17h.002V.168h.002V.167H.98V.166h.005L.986.165h.007l.001.001h.002v.001h.002V.17H1V.17H1v.001h.001v.001h.001l.001.001h.001v.001l.001.001v.001h.001v.001h.001v.001l.001.001V.18h.001v.002h.001v.002h.001v.002h.001v.002l.001.001v.003h.001v.004l.001.001V.762l-.001.001v.003h-.001v.002l-.001.001V.77H1.01v.002H1.01v.001l-.001.001v.001l-.001.001v.001h-.001v.001h-.001V.78h-.001V.78h-.001v.001h-.001v.001h-.001v.001H1v.001H1L.998.786H.997L.996.787H.995L.994.788H.992L.991.789H.986zm0-.01h.006V.777h.002L.997.776h.001V.775h.001V.774H1V.773H1V.772h.001V.771h.001V.77h.001V.768h.001V.767l.001-.001V.765h.001V.763l.001-.001V.76L1.009.76V.756L1.01.755V.193h-.001V.19h-.001V.188h-.001V.186L1.004.185V.184h-.001V.182h-.001V.181h-.001V.18H1V.18H1V.178H.998V.177H.997V.176H.995V.175H.993V.174H.991L.99.173H.98v.001H.977v.001H.975v.001H.974v.001H.973V.18H.972V.18H.971v.001H.97v.001L.97.184v.001H.968v.001L.967.187v.001L.966.189V.19H.965v.003H.964v.004H.963V.76h.001v.003h.001v.002l.001.001v.001h.001v.002H.97V.77H.97v.001h.001v.001h.001v.001h.001v.001h.001v.001h.001v.001h.002v.001h.001L.98.779h.002V.78h.005z",
    fill: "#999"
  }), __jsx("path", {
    d: "M.86.35c.03 0 .055.057.055.127S.89.605.859.605C.83.605.864.548.864.477.864.407.83.35.86.35z",
    fill: "#f2f2f2"
  }), __jsx("path", {
    d: "M371 178l18-25v50l-18-25z",
    fill: "none",
    stroke: "#f2f2f2",
    strokeWidth: 3,
    strokeLinecap: "butt",
    strokeLinejoin: "bevel",
    transform: "matrix(.002 0 0 .00274 -.003 -.008)"
  }), __jsx("path", {
    d: "M.771.403c.01 0 .02.035.02.078C.79.525.78.56.77.56V.403z",
    fill: "#ebebeb"
  }));
};

/* harmony default export */ __webpack_exports__["default"] = (SvgShip3);

/***/ }),

/***/ "./src/games/seabattle/media/SvgShip4.tsx":
/*!************************************************!*\
  !*** ./src/games/seabattle/media/SvgShip4.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_16giunf70e() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgShip4.tsx";
  var hash = "78f83c84f7112777d202264d809bae9f9029c08e";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgShip4.tsx",
    statementMap: {
      "0": {
        start: {
          line: 4,
          column: 17
        },
        end: {
          line: 424,
          column: 1
        }
      },
      "1": {
        start: {
          line: 5,
          column: 2
        },
        end: {
          line: 423,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 4,
            column: 17
          },
          end: {
            line: 4,
            column: 18
          }
        },
        loc: {
          start: {
            line: 5,
            column: 2
          },
          end: {
            line: 423,
            column: 6
          }
        },
        line: 5
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0
    },
    f: {
      "0": 0
    },
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "78f83c84f7112777d202264d809bae9f9029c08e"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_16giunf70e = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_16giunf70e();

/* tslint:disable */

cov_16giunf70e().s[0]++;

var SvgShip4 = function SvgShip4() {
  cov_16giunf70e().f[0]++;
  cov_16giunf70e().s[1]++;
  return __jsx("g", null, __jsx("path", {
    d: "M3.997.501c-.001-.093-.309-.199-.65-.24C2.874.203 2.276.033 1.974.039 1.578.046-.002.139.003.496c.005.356 1.58.45 1.98.45.312 0 .89-.15 1.357-.216.334-.047.658-.136.657-.229z",
    fill: "#595959"
  }), __jsx("clipPath", {
    id: "ship4_svg__a"
  }, __jsx("path", {
    d: "M1980 221c-.61-41-152.92-87.6-322-106-233.6-25.42-529.31-100.304-679.004-97.882-196.293 3.175-978.35 44.245-976 201.48C5.346 375.83 784.87 417 982.996 417c154.674 0 440.884-66.063 672.004-95 165.26-20.692 325.61-60.262 325-101z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__a)",
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }, __jsx("path", {
    d: "M1762-7h215.998v434H1762z",
    fill: "#968474"
  }), __jsx("path", {
    d: "M212.998 83h-213v266h213c-17.77-72.623-20.377-181.986 0-266z",
    fill: "#404040"
  })), __jsx("path", {
    d: "M3.312.314c.064.095.06.275 0 .375",
    fill: "none",
    stroke: "#999",
    strokeWidth: 0.013
  }), __jsx("path", {
    d: "M3.835.57L3.77.56l-.004.004-.001.014.003.005.064.009.003-.023z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__b"
  }, __jsx("path", {
    d: "M1899.71 251.07l-32.17-3.86-1.83 1.796-.71 5.957 1.75 2.224 31.77 3.813 1.19-9.93z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__b)",
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }, __jsx("path", {
    d: "M1899.95 249.085l-3.97-.476-1.67 13.9 3.97.476 1.67-13.9z",
    fill: "#595959"
  })), __jsx("path", {
    d: "M3.833.424l-.065.01L3.764.43 3.763.417l.003-.005.064-.01.003.022z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__c"
  }, __jsx("path", {
    d: "M1898.79 186.9l-32.08 4.585-1.86-1.754-.85-5.94 1.7-2.26 31.67-4.53 1.42 9.9z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__c)",
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }, __jsx("path", {
    d: "M1899.07 188.88l-3.96.565-1.98-13.86 3.96-.565 1.98 13.86z",
    fill: "#595959"
  })), __jsx("ellipse", {
    cx: 3.653,
    cy: 0.446,
    rx: 0.021,
    ry: 0.024,
    fill: "#404040"
  }), __jsx("path", {
    d: "M3.653.473h-.005L3.646.471h-.002L3.643.47h-.002V.47H3.64V.468h-.002V.467h-.001V.466h-.001V.465h-.001V.464h-.001V.463h-.001V.461h-.001V.46L3.631.46V.458L3.63.457V.455H3.63V.452L3.628.451V.436L3.63.435V.433h.001V.431h.001V.43h.001V.428h.001V.427h.001V.426h.001V.425l.001-.001h.001V.423h.001V.422h.001l.001-.001h.001V.42h.003V.42h.003L3.65.418H3.66V.42h.003v.001h.001l.001.001h.001v.001h.001v.001h.001l.001.001.001.001v.001h.001v.001h.001V.43h.001v.002h.001v.002h.001v.002h.001v.003l.001.001V.456h-.001v.003h-.001V.46h-.001v.001h-.001v.002H3.67v.001H3.67v.001h-.001v.001h-.001v.001h-.001v.001h-.001L3.664.47h-.001L3.662.47h-.001v.001h-.003v.001h-.006zm0-.007h.004V.464h.002L3.66.463h.001V.462h.001l.001-.001h.001V.46h.001V.46h.001V.457h.001V.456h.001V.454L3.67.453V.451h.001V.436h-.001V.434h-.001V.433L3.666.432V.431h-.001V.43h-.001V.43h-.001V.428h-.001L3.661.427H3.66V.426h-.002V.425h-.005V.424h-.006l-.001.001h-.002v.001h-.001v.001h-.002V.43H3.64V.43H3.64v.001h-.001v.002h-.001v.001h-.001v.002l-.001.001V.44h-.001V.454h.001v.002l.001.001v.001h.001v.001L3.64.46V.46h.001v.001h.001l.001.001h.001v.001h.001l.001.001h.002v.001h.005z",
    fill: "#c69264"
  }), __jsx("ellipse", {
    cx: 3.653,
    cy: 0.559,
    rx: 0.021,
    ry: 0.024,
    fill: "#404040"
  }), __jsx("path", {
    d: "M3.653.586h-.007V.584h-.002V.583h-.002V.582H3.64V.581h-.001V.58h-.001V.58h-.001L3.635.578V.577h-.001V.576h-.001V.575L3.632.574V.573h-.001V.571H3.63V.57L3.63.568V.565h-.001V.55h.001V.546h.001V.545l.001-.001V.543h.001V.541h.001V.54h.001V.54h.001V.538h.001V.537h.001V.536h.002V.535h.001V.534h.002V.533h.003V.532H3.662v.001h.002v.001h.001l.001.001h.001v.001h.001v.001h.001V.54h.001V.54h.001v.001h.001v.001l.001.001v.001h.001v.002h.001v.002l.001.001v.003h.001V.569L3.674.57v.002h-.001v.002h-.001v.002h-.001v.001H3.67v.001L3.67.579h-.001V.58L3.667.58h-.001v.001h-.001v.001h-.001l-.001.001h-.001l-.001.001H3.66v.001h-.004v.001h-.003zm0-.007h.005V.577h.002V.576h.002V.575h.001V.574h.001V.573h.001V.572h.001V.571h.001V.57h.001V.567h.001V.564h.001V.55h-.001V.548L3.667.547V.546h-.001V.545h-.001V.543h-.001L3.663.542 3.662.541h-.001V.54H3.66V.54h-.002V.538H3.645V.54h-.002v.001h-.001v.001h-.001L3.64.544 3.64.545v.001h-.001v.001h-.001v.002h-.001V.55h-.001v.003h-.001V.567l.001.001V.57h.001V.57l.001.001v.001h.001v.001h.001v.001h.001v.001h.001v.001h.002v.001h.002v.001h.003L3.65.58h.002z",
    fill: "#c69264"
  }), __jsx("ellipse", {
    cx: 0.527,
    cy: 0.704,
    rx: 0.021,
    ry: 0.024,
    fill: "#404040"
  }), __jsx("path", {
    d: "M.527.731H.52L.52.73H.517V.728H.515V.727H.514V.726H.513L.512.725H.511V.724H.51V.723H.51V.722L.508.721V.72H.507V.718H.506V.717L.505.716V.714H.504V.711H.503V.693h.001V.691h.001V.69h.001V.687h.001V.686H.51V.685H.51V.684L.512.683.513.682h.001V.681h.001V.68h.001L.517.68h.001V.678H.52V.677h.004V.676H.535v.001h.002V.68h.002V.68H.54L.54.682h.001v.001h.001v.001h.001v.001h.001v.001h.001v.001h.001v.002h.001V.69L.549.69v.001L.55.693v.002H.55v.003h.001V.714H.55v.003H.548v.002H.547V.72L.546.72v.001H.545v.001H.544v.001L.543.725H.542v.001H.541v.001H.54v.001H.54L.538.729H.537L.536.73H.535L.534.73H.531L.53.732H.527zm0-.007h.006V.722h.002V.721h.002V.72h.001V.72H.54V.718H.54V.717h.001V.716L.543.715V.714h.001V.712L.545.711V.708h.001V.695H.543V.693H.542V.692L.541.691V.69H.54V.69H.54V.688H.538V.687H.537V.686H.536V.685H.534V.684H.531V.683H.52v.001H.518v.001H.517L.516.688.515.689H.514V.69L.513.69v.001H.512v.001H.511v.002H.51v.003H.51V.713l.001.001v.001h.001v.002h.001v.001h.001v.001L.516.72h.001V.72h.001v.001h.001L.52.723H.52v.001h.003l.001.001h.003z",
    fill: "#313131"
  }), __jsx("ellipse", {
    cx: 1.198,
    cy: 0.645,
    rx: 0.021,
    ry: 0.024,
    fill: "#404040"
  }), __jsx("path", {
    d: "M1.198.672H1.19V.67h-.002L1.187.67h-.001V.668h-.001L1.184.667h-.001V.666h-.001V.665h-.001V.664H1.18V.663H1.18V.662L1.178.661V.66h-.001V.658h-.001V.656h-.001V.653h-.001V.65L1.173.648V.636h.001V.633h.001V.631h.001V.63h.001V.628h.001V.627L1.18.626V.625h.001V.624h.001V.623h.001l.001-.001h.001V.621h.001V.62h.002V.62h.002l.001-.001h.004V.617H1.205l.001.001h.002V.62h.002v.001h.001v.001h.002v.001h.001v.001h.001v.001h.001v.001h.001v.002h.001V.63h.001v.002h.001v.002h.001v.003h.001V.64l.001.001V.654H1.22v.003H1.22v.002L1.218.66V.66h-.001v.001l-.001.001v.001h-.001v.001h-.001v.001h-.001v.001h-.001v.001h-.001v.001H1.21V.67h-.002V.67h-.002v.001h-.003l-.001.001h-.004zm0-.007h.006V.663h.002V.662h.001l.001-.001h.001V.66h.001V.66h.001V.658l.001-.001V.656h.001V.654h.001V.652h.001V.648l.001-.001V.637h-.001V.635h-.001V.633h-.001V.632L1.211.631V.63H1.21V.63H1.21V.628h-.001V.627h-.002V.626h-.001L1.204.625h-.002V.624H1.191v.001H1.19v.001h-.002v.001h-.001V.63h-.001V.63h-.001v.001h-.001v.002h-.001v.002h-.001v.002H1.18v.004H1.18V.653h.001v.002h.001v.002h.001v.001h.001V.66h.001V.66h.001v.001h.001l.001.001h.001v.001h.002v.001h.003v.001h.004z",
    fill: "#313131"
  }), __jsx("ellipse", {
    cx: 1.198,
    cy: 0.339,
    rx: 0.021,
    ry: 0.024,
    fill: "#404040"
  }), __jsx("path", {
    d: "M1.198.366h-.006L1.19.364h-.002V.363h-.002V.362h-.001L1.184.361h-.001V.36h-.001V.36h-.001V.358H1.18V.357L1.18.356V.355h-.001V.354h-.001V.352h-.001V.35h-.001V.347h-.001V.343L1.173.342V.33h.001V.327h.001V.325h.001V.323h.001V.322h.001V.32h.001V.32h.001V.318h.001V.317h.001V.316h.002V.315h.001V.314h.002V.313h.002V.312h.004l.001-.001H1.206v.001h.002v.001h.002v.001h.001l.001.001h.001v.001h.001v.001h.001V.32h.001V.32h.001v.002h.001v.001h.001v.002h.001v.002h.001V.33h.001v.004h.001V.348H1.22V.35H1.22v.002h-.001v.002h-.001v.001l-.001.001v.001h-.001v.001h-.001V.36h-.001V.36h-.001v.001h-.001L1.21.363H1.21v.001h-.002v.001h-.002v.001h-.004v.001h-.004zm0-.007h.006V.357h.002V.356h.001V.355h.001L1.21.354h.001V.353h.001V.351h.001V.35h.001V.348h.001V.346l.001-.001V.342l.001-.001V.331h-.001V.33h-.001V.327h-.001V.325h-.001V.324H1.21V.323H1.21V.322h-.001V.321h-.001L1.206.32h-.001V.32h-.003V.318H1.191L1.19.32H1.19v.001h-.002v.001h-.001v.001h-.001v.001h-.001v.001h-.001v.002h-.001v.001L1.181.33v.002H1.18v.004H1.18V.346l.001.001v.002h.001V.35h.001v.001h.001v.001l.001.001.001.001.001.001h.001v.001h.001v.001h.002v.001h.004V.36h.003z",
    fill: "#313131"
  }), __jsx("ellipse", {
    cx: 0.527,
    cy: 0.287,
    rx: 0.021,
    ry: 0.024,
    fill: "#404040"
  }), __jsx("path", {
    d: "M.527.314H.52V.312H.518V.311H.516L.515.31H.514V.31H.513V.308H.512L.511.307.51.306.51.305V.304H.508V.303H.507V.301H.506V.3L.505.3V.297H.504V.294H.503V.276h.001V.274L.507.273V.272L.508.271V.27h.001V.27L.51.268.51.267V.266h.001V.265h.001L.514.264h.001V.263h.001V.262h.002V.261H.52V.26h.004V.26H.535v.001h.003v.001h.001L.54.264H.54v.001h.001v.001h.001l.001.001.001.001v.001h.001V.27h.001V.27l.001.001v.001h.001v.002H.55v.002L.55.278V.28h.001V.297H.55V.3H.548v.002H.547v.001H.546v.001L.545.305v.001H.544v.001H.543v.001H.542v.001H.541V.31H.54V.31H.538v.001H.536v.001H.534L.533.314H.53v.001H.527zm0-.007h.005L.534.305h.002V.304h.001V.303h.002V.302H.54V.301H.54V.3L.542.3V.298h.001V.297L.544.296V.294h.001V.291h.001V.278H.543V.276H.542V.274H.541V.273H.54V.272L.54.271H.538V.27H.537V.27H.536V.268H.534V.267H.532V.266H.52v.001H.518V.27H.516V.27H.515v.001H.514v.001H.513v.001L.512.275v.001H.511v.002H.51V.28H.51V.296h.001v.002h.001V.3h.001V.3h.001v.001h.001v.001h.001v.001h.001v.001H.52v.001h.002v.001h.004v.001h.002z",
    fill: "#313131"
  }), __jsx("path", {
    d: "M2.284.172h-.22v.032l-.2.045-.22-.002v-.02h-.217l-.18.209v.113l.178.215h.218V.75h.221l.2.056v.032h.22l.54-.136.001-.386-.541-.142z",
    fill: "gray",
    stroke: "#737373",
    strokeWidth: 0.011
  }), __jsx("path", {
    d: "M1.38.6V.67S1.208.593 1.204.58a.338.338 0 0 1 0-.176c.004-.01.178-.083.178-.083v.08h.933V.6h-.933z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M2.227.671V.322l.26.063v.21l-.26.076z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M2.227.678h-.002L2.224.676 2.222.675V.675L2.221.674V.317l.001-.001.002-.001h.003l.261.062h.001l.001.001h.001V.38l.001.001v.003h.001v.213L2.492.6h-.001L2.49.6l-.002.001-.26.077h-.001zm0-.007l.26-.077v-.21l-.26-.062v.35z",
    fill: "#e6e6e6"
  }), __jsx("path", {
    d: "M1.99.417c.065 0 .104.038.104.085 0 .047-.042.085-.103.085-.092 0-.133-.038-.133-.085 0-.047.041-.085.133-.085z",
    fill: "#8c8c8c"
  }), __jsx("path", {
    d: "M1.988.435c.05 0 .082.03.082.067 0 .038-.033.068-.082.068-.073 0-.112-.03-.112-.068 0-.037.04-.067.112-.067z",
    fill: "#1a1a1a"
  }), __jsx("clipPath", {
    id: "ship4_svg__d"
  }, __jsx("circle", {
    cx: 992.5,
    cy: 221.5,
    r: 25.5
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__d)",
    transform: "matrix(.00202 0 0 .00227 -.003 0)",
    fill: "none",
    stroke: "#8c8c8c",
    strokeWidth: 5
  }, __jsx("path", {
    d: "M987 246l29-29m-43 23l36-36m-43 24l32-32"
  })), __jsx("ellipse", {
    cx: 2.002,
    cy: 0.502,
    rx: 0.052,
    ry: 0.058,
    fill: "none",
    stroke: "#8c8c8c",
    strokeWidth: 0.011
  }), __jsx("path", {
    d: "M1.545.429c.053 0 .085.033.085.073 0 .041-.034.074-.085.074-.075 0-.136-.033-.136-.074 0-.04.06-.073.136-.073z",
    fill: "#8c8c8c"
  }), __jsx("path", {
    d: "M1.541.44c.045 0 .072.028.072.062 0 .035-.03.063-.072.063-.064 0-.115-.028-.115-.063 0-.034.051-.062.115-.062z",
    fill: "#1a1a1a"
  }), __jsx("clipPath", {
    id: "ship4_svg__e"
  }, __jsx("circle", {
    cx: 766.5,
    cy: 221.5,
    r: 25.5
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__e)",
    transform: "matrix(.00202 0 0 .00227 -.003 0)",
    fill: "none",
    stroke: "#8c8c8c",
    strokeWidth: 5
  }, __jsx("path", {
    d: "M761 246l29-29m-43 23l36-36m-43 24l32-32"
  })), __jsx("ellipse", {
    cx: 1.545,
    cy: 0.502,
    rx: 0.052,
    ry: 0.058,
    fill: "none",
    stroke: "#8c8c8c",
    strokeWidth: 0.011
  }), __jsx("ellipse", {
    cx: 2.434,
    cy: 0.494,
    rx: 0.04,
    ry: 0.082,
    fill: "#b3b3b3",
    stroke: "#f2f2f2",
    strokeWidth: 0.006
  }), __jsx("path", {
    d: "M687.19 342.388c-19.263-9.002-27.58-31.916-18.578-51.18 9.002-19.262 31.916-27.58 51.18-18.578 19.262 9.003 27.58 31.916 18.578 51.18-9.003 19.263-31.916 27.58-51.18 18.578z",
    fill: "#f2f2f2",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M1.392.8l.01.005.034-.082-.01-.005L1.392.8zM1.356.78l.009.006.034-.083L1.389.7 1.357.78z",
    fill: "#737373"
  }), __jsx("path", {
    d: "M1107.66 395.964c-14.07 15.94-38.4 17.457-54.34 3.386-15.94-14.07-17.46-38.4-3.39-54.342 14.08-15.94 38.41-17.457 54.35-3.386 15.94 14.07 17.45 38.4 3.38 54.342z",
    fill: "#f2f2f2",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M2.257.897L2.264.89l-.061-.06-.007.008.06.06zM2.23.931l.007-.008-.06-.06L2.17.87l.06.06z",
    fill: "#737373"
  }), __jsx("path", {
    d: "M940.11 301.807c-10.74 12.167-29.31 13.324-41.477 2.584-12.167-10.738-13.324-29.308-2.585-41.475 10.74-12.167 29.31-13.324 41.476-2.584 12.167 10.74 13.324 29.31 2.585 41.477z",
    fill: "#ccc",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M1.913.684l.005-.007-.046-.046-.005.007.046.046zm-.02.026l.005-.007-.046-.046-.006.007.047.046z",
    fill: "#737373"
  }), __jsx("path", {
    d: "M941.415 149.17c-10.74-12.168-29.31-13.325-41.476-2.585-12.168 10.74-13.325 29.31-2.585 41.476 10.74 12.168 29.31 13.325 41.476 2.585 12.168-10.74 13.325-29.31 2.585-41.476z",
    fill: "#ccc",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M1.916.339l.005.006-.046.046L1.87.385l.046-.046zm-.02-.026L1.9.319l-.046.046L1.85.36l.046-.046z",
    fill: "#737373"
  }), __jsx("path", {
    d: "M847.607 307.644c-16.223-.43-29.026-13.93-28.596-30.153.43-16.222 13.93-29.025 30.153-28.595 16.223.43 29.026 13.93 28.596 30.152-.43 16.223-13.93 29.026-30.153 28.597z",
    fill: "#ccc",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M1.72.712h.008l.002-.07h-.008l-.001.07zM1.69.71h.007L1.7.641h-.008l-.001.07z",
    fill: "#737373"
  }), __jsx("path", {
    d: "M850.606 139.738c-16.192-1.1-30.21 11.135-31.31 27.326-1.1 16.192 11.135 30.21 27.327 31.31 16.19 1.1 30.208-11.135 31.308-27.327 1.1-16.19-11.133-30.21-27.324-31.31z",
    fill: "#ccc",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M1.728.304h.007l-.004.07-.007-.001.004-.07zM1.697.302h.008L1.7.372 1.693.37 1.697.3z",
    fill: "#737373"
  }), __jsx("path", {
    d: "M770.113 309.987c-14.688-6.9-21-24.402-14.1-39.09 6.9-14.69 24.402-21.002 39.09-14.1 14.69 6.9 21.002 24.402 14.1 39.09-6.9 14.688-24.402 21-39.09 14.1z",
    fill: "#ccc",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M1.558.721l.007.004.026-.063-.007-.004-.026.063zM1.53.706l.007.004.026-.063-.007-.003-.026.062z",
    fill: "#737373"
  }), __jsx("path", {
    d: "M766.005 136.232c-13.07 9.62-15.865 28.015-6.245 41.084 9.62 13.07 28.015 15.866 41.085 6.245 13.07-9.62 15.865-28.014 6.245-41.083-9.62-13.07-28.015-15.866-41.085-6.245z",
    fill: "#ccc",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M1.546.29l.007-.005.036.056-.006.005L1.546.29zm-.024.02l.006-.005.036.056-.006.005-.036-.055z",
    fill: "#737373"
  }), __jsx("path", {
    d: "M1107.66 50.022c-14.07-15.94-38.4-17.457-54.34-3.386-15.94 14.07-17.46 38.4-3.39 54.34 14.08 15.942 38.41 17.46 54.35 3.388 15.94-14.07 17.45-38.4 3.38-54.342z",
    fill: "#f2f2f2",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M2.257.114l.007.009-.061.06-.007-.009.06-.06zM2.23.08l.007.009-.06.06L2.17.14l.06-.06z",
    fill: "#737373"
  }), __jsx("path", {
    d: "M677.067 115.736c9.002-19.264 31.916-27.582 51.18-18.58 19.262 9.003 27.58 31.917 18.578 51.18-9.003 19.263-31.916 27.58-51.18 18.58-19.263-9.003-27.58-31.917-18.578-51.18z",
    fill: "#f2f2f2",
    stroke: "#a6a6a6",
    strokeWidth: 4,
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M1.344.27l-.005.01.074.039.004-.01L1.344.27zM1.36.23l-.004.01.073.038.004-.01-.073-.039z",
    fill: "#737373"
  }), __jsx("g", {
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }, __jsx("circle", {
    cx: 861.5,
    cy: 374.5,
    r: 38.5,
    fill: "#f2f2f2",
    stroke: "#a6a6a6",
    strokeWidth: 4
  }), __jsx("path", {
    d: "M869 381h5v60h-5zm-20 0h5v60h-5z",
    fill: "#e6e6e6"
  })), __jsx("g", {
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }, __jsx("circle", {
    cx: 858.5,
    cy: 66.5,
    r: 38.5,
    fill: "#f2f2f2",
    stroke: "#a6a6a6",
    strokeWidth: 4
  }), __jsx("path", {
    d: "M866 0h5v60h-5zm-20 0h5v60h-5z",
    fill: "#e6e6e6"
  })), __jsx("g", {
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }, __jsx("path", {
    d: "M1444 146h30v150h-30z",
    fill: "#ccc",
    stroke: "#e6e6e6",
    strokeWidth: 3
  }), __jsx("path", {
    d: "M1593 155h-32l-73.07-8-53.16 14v117l53.23 14 73-7h32V155z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship4_svg__f"
  }, __jsx("path", {
    d: "M1593 155h-32l-73.07-8-53.16 14v117l53.23 14 73-7h32V155z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__f)"
  }, __jsx("path", {
    d: "M1561 153h34v134h-34z",
    fill: "#e6e6e6"
  })), __jsx("path", {
    d: "M1593 155h-32l-73.07-8-53.16 14v117l53.23 14 73-7h32V155z",
    fill: "none",
    stroke: "#e6e6e6",
    strokeWidth: 3
  }), __jsx("path", {
    d: "M1593 257.355a7.354 7.354 0 0 0-7.36-7.355h-13.28a7.354 7.354 0 0 0-7.36 7.355v6.29a7.354 7.354 0 0 0 7.36 7.355h13.28c4.07 0 7.36-3.293 7.36-7.355v-6.29z",
    fill: "#262626"
  }), __jsx("path", {
    d: "M1724 256l-107-3-11.13-1.378L1585 251v19l20.87-.622L1617 268l107-2v-10z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__g"
  }, __jsx("path", {
    d: "M1724 256l-107-3-11.13-1.378L1585 251v19l20.87-.622L1617 268l107-2v-10z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__g)"
  }, __jsx("path", {
    d: "M1617 249v24m-11-24v24",
    fill: "none",
    stroke: "#999",
    strokeLinecap: "butt"
  }), __jsx("path", {
    d: "M1583 250h10v22h-10z",
    fill: "#262626"
  })), __jsx("path", {
    d: "M1593 218.355a7.354 7.354 0 0 0-7.36-7.355h-13.28a7.354 7.354 0 0 0-7.36 7.355v6.29a7.354 7.354 0 0 0 7.36 7.355h13.28c4.07 0 7.36-3.293 7.36-7.355v-6.29z",
    fill: "#262626"
  }), __jsx("path", {
    d: "M1724 217l-107-3-11.13-1.378L1585 212v19l20.87-.622L1617 229l107-2v-10z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__h"
  }, __jsx("path", {
    d: "M1724 217l-107-3-11.13-1.378L1585 212v19l20.87-.622L1617 229l107-2v-10z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__h)"
  }, __jsx("path", {
    d: "M1617 210v24m-11-24v24",
    fill: "none",
    stroke: "#999",
    strokeLinecap: "butt"
  }), __jsx("path", {
    d: "M1583 211h10v22h-10z",
    fill: "#262626"
  })), __jsx("g", null, __jsx("path", {
    d: "M1593 177.355a7.354 7.354 0 0 0-7.36-7.355h-13.28a7.354 7.354 0 0 0-7.36 7.355v6.29a7.354 7.354 0 0 0 7.36 7.355h13.28c4.07 0 7.36-3.293 7.36-7.355v-6.29z",
    fill: "#262626"
  }), __jsx("path", {
    d: "M1724 176l-107-3-11.13-1.378L1585 171v19l20.87-.622L1617 188l107-2v-10z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__i"
  }, __jsx("path", {
    d: "M1724 176l-107-3-11.13-1.378L1585 171v19l20.87-.622L1617 188l107-2v-10z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__i)"
  }, __jsx("path", {
    d: "M1617 169v24m-11-24v24",
    fill: "none",
    stroke: "#999",
    strokeLinecap: "butt"
  }), __jsx("path", {
    d: "M1583 170h10v22h-10z",
    fill: "#262626"
  })))), __jsx("g", {
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }, __jsx("path", {
    d: "M1254 146h30v150h-30z",
    fill: "#ccc",
    stroke: "#e6e6e6",
    strokeWidth: 3
  }), __jsx("path", {
    d: "M1403 155h-32l-73.07-8-53.16 14v117l53.23 14 73-7h32V155z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship4_svg__j"
  }, __jsx("path", {
    d: "M1403 155h-32l-73.07-8-53.16 14v117l53.23 14 73-7h32V155z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__j)"
  }, __jsx("path", {
    d: "M1371 153h34v134h-34z",
    fill: "#e6e6e6"
  })), __jsx("path", {
    d: "M1403 155h-32l-73.07-8-53.16 14v117l53.23 14 73-7h32V155z",
    fill: "none",
    stroke: "#e6e6e6",
    strokeWidth: 3
  }), __jsx("path", {
    d: "M1403 257.355a7.354 7.354 0 0 0-7.36-7.355h-13.28a7.354 7.354 0 0 0-7.36 7.355v6.29a7.354 7.354 0 0 0 7.36 7.355h13.28c4.07 0 7.36-3.293 7.36-7.355v-6.29z",
    fill: "#262626"
  }), __jsx("path", {
    d: "M1534 256l-107-3-11.13-1.378L1395 251v19l20.87-.622L1427 268l107-2v-10z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__k"
  }, __jsx("path", {
    d: "M1534 256l-107-3-11.13-1.378L1395 251v19l20.87-.622L1427 268l107-2v-10z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__k)"
  }, __jsx("path", {
    d: "M1427 249v24m-11-24v24",
    fill: "none",
    stroke: "#999",
    strokeLinecap: "butt"
  }), __jsx("path", {
    d: "M1393 250h10v22h-10z",
    fill: "#262626"
  })), __jsx("path", {
    d: "M1403 218.355a7.354 7.354 0 0 0-7.36-7.355h-13.28a7.354 7.354 0 0 0-7.36 7.355v6.29a7.354 7.354 0 0 0 7.36 7.355h13.28c4.07 0 7.36-3.293 7.36-7.355v-6.29z",
    fill: "#262626"
  }), __jsx("path", {
    d: "M1534 217l-107-3-11.13-1.378L1395 212v19l20.87-.622L1427 229l107-2v-10z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__l"
  }, __jsx("path", {
    d: "M1534 217l-107-3-11.13-1.378L1395 212v19l20.87-.622L1427 229l107-2v-10z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__l)"
  }, __jsx("path", {
    d: "M1427 210v24m-11-24v24",
    fill: "none",
    stroke: "#999",
    strokeLinecap: "butt"
  }), __jsx("path", {
    d: "M1393 211h10v22h-10z",
    fill: "#262626"
  })), __jsx("g", null, __jsx("path", {
    d: "M1403 177.355a7.354 7.354 0 0 0-7.36-7.355h-13.28a7.354 7.354 0 0 0-7.36 7.355v6.29a7.354 7.354 0 0 0 7.36 7.355h13.28c4.07 0 7.36-3.293 7.36-7.355v-6.29z",
    fill: "#262626"
  }), __jsx("path", {
    d: "M1534 176l-107-3-11.13-1.378L1395 171v19l20.87-.622L1427 188l107-2v-10z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__m"
  }, __jsx("path", {
    d: "M1534 176l-107-3-11.13-1.378L1395 171v19l20.87-.622L1427 188l107-2v-10z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__m)"
  }, __jsx("path", {
    d: "M1427 169v24m-11-24v24",
    fill: "none",
    stroke: "#999",
    strokeLinecap: "butt"
  }), __jsx("path", {
    d: "M1393 170h10v22h-10z",
    fill: "#262626"
  })))), __jsx("g", {
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }, __jsx("path", {
    d: "M523 141h30v154h-30z",
    fill: "#ccc",
    stroke: "#e6e6e6",
    strokeWidth: 3
  }), __jsx("path", {
    d: "M405 282h32l73.074 8 53.156-14V159L510 145l-73 7h-32v130z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship4_svg__n"
  }, __jsx("path", {
    d: "M405 282h32l73.074 8 53.156-14V159L510 145l-73 7h-32v130z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__n)"
  }, __jsx("path", {
    d: "M403 150h34v134h-34z",
    fill: "#e6e6e6"
  })), __jsx("path", {
    d: "M405 282h32l73.074 8 53.156-14V159L510 145l-73 7h-32v130z",
    fill: "none",
    stroke: "#e6e6e6",
    strokeWidth: 3
  }), __jsx("path", {
    d: "M405.77 181.645a7.355 7.355 0 0 0 7.356 7.355h13.29a7.355 7.355 0 0 0 7.354-7.355v-6.29a7.355 7.355 0 0 0-7.355-7.355h-13.29a7.355 7.355 0 0 0-7.355 7.355v6.29z",
    fill: "#262626"
  }), __jsx("path", {
    d: "M274.77 183l107 3 11.127 1.378 20.873.622v-19l-20.873.622L381.77 171l-107 2v10z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__o"
  }, __jsx("path", {
    d: "M274.77 183l107 3 11.127 1.378 20.873.622v-19l-20.873.622L381.77 171l-107 2v10z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__o)"
  }, __jsx("path", {
    d: "M381.77 190v-24m11 24v-24",
    fill: "none",
    stroke: "#999",
    strokeLinecap: "butt"
  }), __jsx("path", {
    d: "M405.77 167h10v22h-10z",
    fill: "#262626"
  })), __jsx("path", {
    d: "M405.77 220.645a7.355 7.355 0 0 0 7.356 7.355h13.29a7.355 7.355 0 0 0 7.354-7.355v-6.29a7.355 7.355 0 0 0-7.355-7.355h-13.29a7.355 7.355 0 0 0-7.355 7.355v6.29z",
    fill: "#262626"
  }), __jsx("path", {
    d: "M274.77 222l107 3 11.127 1.378 20.873.622v-19l-20.873.622L381.77 210l-107 2v10z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__p"
  }, __jsx("path", {
    d: "M274.77 222l107 3 11.127 1.378 20.873.622v-19l-20.873.622L381.77 210l-107 2v10z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__p)"
  }, __jsx("path", {
    d: "M381.77 229v-24m11 24v-24",
    fill: "none",
    stroke: "#999",
    strokeLinecap: "butt"
  }), __jsx("path", {
    d: "M405.77 206h10v22h-10z",
    fill: "#262626"
  })), __jsx("g", null, __jsx("path", {
    d: "M405.77 261.645a7.355 7.355 0 0 0 7.356 7.355h13.29a7.355 7.355 0 0 0 7.354-7.355v-6.29a7.355 7.355 0 0 0-7.355-7.355h-13.29a7.355 7.355 0 0 0-7.355 7.355v6.29z",
    fill: "#262626"
  }), __jsx("path", {
    d: "M274.77 263l107 3 11.127 1.378 20.873.622v-19l-20.873.622L381.77 251l-107 2v10z",
    fill: "gray"
  }), __jsx("clipPath", {
    id: "ship4_svg__q"
  }, __jsx("path", {
    d: "M274.77 263l107 3 11.127 1.378 20.873.622v-19l-20.873.622L381.77 251l-107 2v10z"
  })), __jsx("g", {
    clipPath: "url(#ship4_svg__q)"
  }, __jsx("path", {
    d: "M381.77 270v-24m11 24v-24",
    fill: "none",
    stroke: "#999",
    strokeLinecap: "butt"
  }), __jsx("path", {
    d: "M405.77 247h10v22h-10z",
    fill: "#262626"
  })))), __jsx("path", {
    d: "M1.342.424a.205.205 0 0 1 0 .14L1.286.55h-.022V.439h.022l.056-.015z",
    fill: "#ccc",
    stroke: "#e6e6e6",
    strokeWidth: 0.006
  }), __jsx("g", {
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }, __jsx("path", {
    d: "M1138 190v62l-30.98 28-14.02-10-42-5.074-3.81-6.404v-76.28l3.81-5.168 42-4.074 14.02-12.463L1138 190z",
    fill: "#d9d9d9"
  }), __jsx("path", {
    d: "M1107.02 280L1093 270l-42-5.074-3.81-6.404v-76.28l3.81-5.168 42-4.074 14.02-12.463L1138 190v62l-30.98 28zm-.22-3.843l28.2-25.49v-59.38l-28.05-26.675-11.96 10.63-.29.233-.33.193-.34.15-.37.108-.37.06-40.67 3.945-2.43 3.298v74.47l2.63 4.427 40.54 4.897.37.068.35.113.34.157.32.198 12.06 8.6z",
    fill: "#e6e6e6"
  }), __jsx("ellipse", {
    cx: 1105.33,
    cy: 220.268,
    rx: 16.331,
    ry: 29.889,
    fill: "#b3b3b3",
    stroke: "#f2f2f2",
    strokeWidth: 3
  })), __jsx("g", null, __jsx("path", {
    d: "M663.495 204.14c7.83 7.83 7.83 20.525 0 28.355-7.83 7.83-20.524 7.83-28.354 0-7.83-7.83-7.83-20.524 0-28.354 7.83-7.83 20.525-7.83 28.355 0z",
    fill: "#b3b3b3",
    stroke: "#ccc",
    strokeWidth: 2,
    strokeLinecap: "butt",
    strokeLinejoin: "miter",
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  }), __jsx("path", {
    d: "M1.358.55a.006.006 0 0 0 0-.008L1.274.447a.005.005 0 0 0-.007 0l-.008.008a.006.006 0 0 0 0 .009l.084.094a.005.005 0 0 0 .008 0L1.358.55z",
    fill: "gray"
  }), __jsx("path", {
    d: "M678.787 244.09a2.617 2.617 0 0 0 0-3.698l-51.543-51.543a2.613 2.613 0 0 0-3.698 0l-3.697 3.696a2.613 2.613 0 0 0 0 3.698l51.542 51.543a2.616 2.616 0 0 0 3.697 0l3.697-3.698z",
    fill: "#f2f2f2",
    stroke: "#ccc",
    strokeWidth: 2,
    strokeLinecap: "butt",
    strokeLinejoin: "miter",
    transform: "matrix(.00202 0 0 .00227 -.003 0)"
  })));
};

/* harmony default export */ __webpack_exports__["default"] = (SvgShip4);

/***/ }),

/***/ "./src/games/seabattle/media/SvgShip5.tsx":
/*!************************************************!*\
  !*** ./src/games/seabattle/media/SvgShip5.tsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_8z5reqhox() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgShip5.tsx";
  var hash = "ed1c465eab2b5a06599fe5096fa518ea6e646c5c";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/media/SvgShip5.tsx",
    statementMap: {
      "0": {
        start: {
          line: 4,
          column: 17
        },
        end: {
          line: 1875,
          column: 1
        }
      },
      "1": {
        start: {
          line: 5,
          column: 2
        },
        end: {
          line: 1874,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 4,
            column: 17
          },
          end: {
            line: 4,
            column: 18
          }
        },
        loc: {
          start: {
            line: 5,
            column: 2
          },
          end: {
            line: 1874,
            column: 6
          }
        },
        line: 5
      }
    },
    branchMap: {},
    s: {
      "0": 0,
      "1": 0
    },
    f: {
      "0": 0
    },
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "ed1c465eab2b5a06599fe5096fa518ea6e646c5c"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_8z5reqhox = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_8z5reqhox();

/* tslint:disable */

cov_8z5reqhox().s[0]++;

var SvgShip5 = function SvgShip5() {
  cov_8z5reqhox().f[0]++;
  cov_8z5reqhox().s[1]++;
  return __jsx("g", null, __jsx("path", {
    d: "M4.996.42s-.271.304-.781.354L4.213.082c.51.012.783.337.783.337z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__a"
  }, __jsx("path", {
    d: "M2520 200s-136.88 145.212-394 169l-1-330c257 6.073 395 161 395 161z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__a)",
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M2429 98h-93v225h93c-16.75-85.87-16.74-160.86 0-225z",
    fill: "#8c8c8c"
  })), __jsx("path", {
    d: "M4.212.777L4.21.079H4.246l.001.001h.016l.002.001h.011l.002.001h.011l.001.001H4.3L4.3.085H4.31l.001.001H4.32l.001.001h.007l.001.001h.007l.002.001h.005l.002.001h.007V.09h.006l.002.001h.005l.002.001h.004v.001h.006l.002.001h.004l.001.001h.005l.003.001h.003l.002.001H4.4l.003.001h.002L4.407.1h.002L4.412.1h.003l.002.001h.003l.002.001h.003l.003.001.002.001h.003l.002.001h.003l.002.001h.003l.002.001h.003L4.45.11h.005l.003.001h.003l.002.002h.005l.002.001.003.001h.002l.003.001h.002l.003.002h.005l.002.001.003.001h.002l.002.001.003.001h.002l.003.001.002.001h.002l.003.002h.005l.002.002h.002l.003.001h.002l.002.001.003.001h.002l.002.002h.003l.002.001h.002l.003.002h.002l.002.001h.002l.003.002h.002l.002.001h.003l.002.002h.002l.002.001.003.001h.002l.002.002h.002l.002.001.003.001h.002l.002.002h.002L4.59.15l.002.001h.002l.002.002h.002L4.6.155l.003.001.002.001h.002l.002.002h.002l.002.001.002.001.002.001h.003l.002.002h.002l.002.001.002.001.002.001.002.001h.002l.002.002h.002l.002.002h.002l.003.001.002.001.002.001.002.001h.002l.002.002h.002l.002.002h.002l.002.001.002.001.002.001.002.001.002.001h.002l.001.002h.002l.002.002h.002l.002.001.002.001.002.001.002.001.002.001.002.001.002.001h.002l.002.002h.001L4.701.2h.002l.002.002h.002l.002.001.002.001.001.001.002.001.002.001.002.001.002.001.002.001.001.001.002.001.002.001h.002l.001.002h.002l.002.002h.002l.002.002h.001l.002.002h.002l.002.002h.001l.002.001.002.001.001.001.002.001.002.001.002.001.001.001.002.001.002.001.001.001.002.001.002.001.001.001.002.001.002.001.001.001.002.001.002.001h.001l.002.002h.001l.002.002h.002l.001.002h.002l.001.002h.002l.002.002h.001l.002.002h.001L4.8.255H4.8l.002.002h.001l.002.001.001.001.002.001.002.001.001.001.002.001.001.001.002.001.001.001.001.001.002.001.001.001.002.001.001.001.002.001.001.001.002.001h.001l.001.002h.002l.001.002h.002l.001.002h.002v.002h.002l.002.002h.001l.001.001.002.001.001.001.001.001.002.001.001.001.001.001.002.001.001.001.001.001h.002l.001.002h.001l.002.002.002.002h.001L4.868.3v.001l.002.001.001.001.002.001v.001l.002.001h.001l.002.002.002.002h.001l.001.002h.001l.002.001v.001l.002.001.001.001h.001l.001.002h.002V.32h.002l.001.001.001.001.001.001.001.001H4.9l.002.002.002.002.002.001V.33l.002.001h.001l.001.002h.001l.001.001.001.001.001.001.001.001h.001l.001.002h.001l.001.001.001.001.001.001h.001l.001.002h.001l.001.001.001.001.002.002.002.001.002.002.001.002.002.002.002.002.002.002.001.002.002.002.002.001.001.001.002.001.002.001.001.001.002.001.001.001.002.001.001.001.002.001.001.001.001.001.002.001.001.001.002.001V.38l.002.001.001.001.002.001v.001l.002.001.001.001.001.001.001.001.001.001.002.001V.39l.002.001v.001l.001.001.001.001.001.001.001.001.001.001.002.002.001.001.001.001.001.002h.001v.001h.001v.001h.001l.001.002.001.001.001.001h.001v.002h.001l.001.001L5 .414l-.002.002v.001l-.001.001V.42h-.002v.002h-.001l-.002.002-.001.001v.001h-.002v.001l-.001.001-.001.002h-.001L4.985.43v.001l-.002.001-.002.002-.001.002h-.001l-.001.001-.001.001-.001.001-.002.001v.001l-.002.001v.001L4.97.444l-.001.001-.001.001-.002.001-.001.001-.001.001-.002.001v.001L4.96.452l-.002.001-.001.001-.002.001-.001.001-.001.001-.002.001-.002.001-.001.001-.002.001-.001.001-.002.001-.002.001-.001.001-.002.001-.002.001-.001.001-.002.002-.002.002-.002.002-.002.002-.002.002-.001.002-.002.002-.002.002-.002.002-.002.002-.002.002-.001.001-.001.001H4.91L4.91.495h-.001l-.001.001-.002.001v.001h-.002V.5h-.002V.5L4.9.501 4.9.502l-.001.001h-.001l-.001.002h-.001l-.002.001v.001L4.89.508 4.89.51h-.001l-.001.002h-.001l-.002.002-.002.001-.001.001-.001.001h-.002v.002h-.002L4.876.52h-.001l-.002.001v.001L4.87.523 4.87.524l-.002.001-.002.002h-.001L4.863.53 4.86.532H4.86l-.002.001-.001.001-.001.001-.002.001-.001.001-.001.001H4.85L4.85.54h-.001l-.002.002h-.001l-.001.002h-.002l-.001.001-.002.001-.001.001-.001.001-.002.001-.001.001-.002.001-.001.001-.001.001-.002.001h-.001l-.002.002h-.001l-.002.002h-.001L4.819.56h-.001l-.001.002h-.002l-.001.002h-.002l-.001.001-.002.001-.001.001-.002.001-.001.001-.002.001-.002.001L4.8.571l-.002.001-.001.001-.002.001-.001.001-.002.001-.001.001-.002.001h-.002L4.786.58h-.002l-.001.002H4.78l-.002.002h-.001l-.002.002h-.002l-.001.002H4.77L4.77.59h-.002l-.002.002h-.001l-.002.002H4.76L4.76.595l-.002.001-.002.001-.002.001L4.753.6 4.75.6l-.002.001-.001.001-.002.001-.002.001-.002.001-.001.001-.002.001-.002.001-.002.001-.001.001-.002.001-.002.001-.002.001h-.002l-.001.002h-.002L4.72.618H4.72L4.717.62h-.001l-.002.002h-.002L4.71.624h-.002l-.002.002h-.001l-.002.001L4.7.627l-.002.001-.002.001-.002.001-.002.001-.002.001-.001.001-.002.001-.002.001-.002.001-.002.001H4.68L4.678.64h-.002l-.002.002h-.002L4.67.644h-.002l-.002.002h-.002l-.002.001-.002.001-.002.001-.002.001-.002.001-.002.001-.002.001h-.002l-.002.002h-.002l-.002.002H4.64l-.002.002h-.002L4.634.66 4.632.66 4.63.661l-.002.001-.002.001h-.003l-.002.002H4.62l-.002.002h-.002l-.002.001L4.61.67 4.609.67l-.003.001-.002.001h-.002L4.6.675h-.002l-.002.002h-.003l-.002.001-.002.001-.002.001h-.002l-.002.002H4.58l-.002.002h-.002l-.002.001-.003.001-.002.001h-.002l-.002.002h-.003L4.56.69 4.558.69l-.002.001h-.003l-.002.002H4.55l-.003.001-.002.001-.002.001H4.54l-.003.002h-.002L4.533.7 4.53.7h-.002l-.002.002h-.003l-.002.001-.003.001h-.002l-.002.002H4.51L4.51.707l-.002.001h-.003L4.502.71h-.003l-.002.001h-.002l-.003.002H4.49l-.003.001h-.002l-.003.002H4.48l-.003.001h-.002L4.472.72H4.47L4.468.72h-.003l-.002.001-.003.001h-.002l-.003.002h-.002L4.45.725h-.003l-.002.001-.003.001H4.44l-.003.001-.002.001h-.003L4.43.73l-.003.001h-.003l-.002.001-.003.001h-.002l-.003.001-.003.001H4.41l-.003.001-.002.001H4.4l-.003.001h-.002L4.393.74 4.39.74h-.002l-.003.001h-.003L4.38.743l-.003.001h-.003l-.002.001h-.003l-.003.001h-.002L4.36.747l-.003.001h-.003l-.002.001H4.35L4.347.75h-.003L4.342.75h-.003l-.003.001h-.003l-.002.001h-.003l-.003.001h-.003L4.32.755h-.003l-.003.001H4.31l-.003.001h-.003l-.002.001H4.3l-.003.001H4.29L4.288.76h-.002L4.283.76H4.28l-.003.001h-.006l-.003.001h-.003l-.002.001h-.006l-.003.001h-.006l-.003.001h-.006l-.003.001H4.23l-.003.001h-.006L4.22.769h-.008zM4.218.77h.008L4.23.768h.006l.003-.001h.006l.003-.001h.006l.003-.001h.003l.003-.001h.005L4.27.763h.003l.003-.001h.006l.002-.001h.003L4.29.76h.003L4.296.76H4.3l.003-.001h.003L4.31.757h.003l.003-.001h.002l.003-.001h.003l.003-.001h.002l.003-.001h.003l.003-.001h.002l.003-.001h.003L4.349.75h.002L4.354.75l.003-.001h.002l.003-.001h.003l.003-.001h.002l.003-.001.003-.001h.002l.003-.001h.003l.002-.001h.003L4.392.74h.005L4.399.74l.003-.001h.003l.002-.001h.003l.002-.002h.006L4.42.734l.003-.001h.002l.003-.001.002-.001h.003L4.436.73 4.438.73h.003l.002-.002h.005l.003-.002h.002l.003-.001h.002l.003-.001.002-.001h.003L4.468.72h.003L4.473.72h.003l.002-.002h.002l.003-.001h.002l.003-.001.002-.001.003-.001h.002l.002-.002H4.5L4.502.71h.003l.002-.002h.002l.003-.001.002-.001h.002L4.52.704h.002l.002-.001h.003l.002-.002h.002L4.533.7 4.535.7l.002-.001h.003l.002-.002h.002l.003-.001.002-.001h.002l.002-.002h.003l.002-.001L4.56.69 4.562.69h.003l.002-.002h.002l.002-.001.003-.001.002-.001.002-.001h.002l.002-.002h.003L4.587.68h.002L4.59.679l.002-.001.002-.001h.003L4.6.674h.002l.002-.002h.002l.002-.001L4.61.67 4.613.67l.002-.001h.002l.002-.002h.002l.002-.002h.002l.002-.001.002-.001.002-.001.002-.001.002-.001.002-.001h.002l.003-.002h.002l.002-.002h.002L4.65.652h.002l.002-.001.002-.001.002-.001.002-.001.002-.001.002-.001.001-.001h.002L4.67.643h.002l.002-.002h.002L4.677.64h.002l.002-.002h.002l.002-.001.002-.001.002-.001.001-.001.002-.001.002-.001.002-.001.002-.001L4.7.629l.002-.001h.002l.001-.002h.002L4.71.623h.002l.002-.002h.002L4.716.62h.002L4.72.617h.002l.002-.001.001-.001.002-.001.002-.001.002-.001.001-.001.002-.001.002-.001.002-.001.001-.001.002-.001.002-.001.002-.001.001-.001.002-.001.002-.001.001-.001h.002l.002-.002h.001l.002-.002h.002L4.76.594h.002l.002-.002h.001L4.768.59h.002L4.77.588h.002l.002-.002h.001l.002-.001.001-.001.002-.001.002-.001.001-.001.002-.001.001-.001.002-.001.001-.001.002-.001.002-.001.001-.001.002-.001.001-.001L4.8.572H4.8L4.803.57h.001l.002-.002h.001L4.81.565h.001l.002-.002h.001l.002-.002h.001L4.818.56 4.819.56 4.82.559l.002-.001.001-.001.002-.001.001-.001.002-.001.001-.001.001-.001h.002L4.833.55h.002V.547h.002L4.84.545h.001l.001-.001.002-.001.001-.001.001-.001.002-.001.001-.001.001-.001.002-.001h.001l.001-.002h.002V.533h.002l.001-.001.002-.001L4.86.53 4.862.53l.002-.001V.528h.002l.001-.002h.001L4.87.523l.002-.001.001-.001.002-.001V.52h.002l.001-.002h.001L4.88.515h.002V.515l.002-.001.001-.001h.001L4.887.51h.002V.508h.002V.508l.002-.001h.001l.001-.002h.001l.001-.001.001-.001L4.9.502 4.901.5l.002-.002.002-.001V.497h.002V.494h.002V.493l.003-.002.002-.002.002-.002.002-.002.002-.002.002-.002.001-.002.002-.002.002-.002.002-.002.002-.001.001-.001.002-.001.002-.001.001-.001.002-.001.002-.001.001-.001.002-.001.001-.001.002-.001.001-.001L4.95.46 4.95.46l.002-.001.001-.001.002-.001V.456l.002-.001.002-.001V.453l.002-.001.001-.001.002-.001V.449l.002-.001.001-.001.001-.001.001-.001.001-.001.001-.001.001-.001.001-.001.001-.001.001-.001.001-.001.001-.001.002-.002.001-.001.001-.001.002-.002h.001V.428h.001l.001-.001.001-.001.001-.001.001-.001.002-.002L4.99.42H4.99L4.989.418h-.001V.417h-.001V.415h-.002V.413h-.001L4.983.413 4.982.412 4.98.41 4.979.408 4.978.408 4.977.407V.406L4.974.405V.404L4.972.403V.402L4.97.4 4.97.4 4.969.399 4.968.398 4.967.397 4.965.396V.395L4.962.394 4.962.393 4.96.392 4.959.39 4.958.39 4.957.389 4.955.388 4.954.387 4.952.386 4.951.385 4.95.384 4.948.383 4.947.382 4.945.38 4.943.38 4.942.379 4.94.378 4.94.377 4.937.376 4.935.375 4.934.373 4.932.37 4.93.369 4.928.367 4.927.365 4.925.363 4.924.362h-.001L4.922.36H4.92L4.92.359V.358h-.002V.355h-.002V.355L4.913.354 4.911.351 4.91.35V.35L4.907.349 4.905.346 4.903.345V.345L4.901.344 4.901.343H4.9L4.899.34h-.001L4.897.34 4.896.339 4.894.338V.337L4.891.336 4.89.333H4.89L4.888.331h-.001L4.886.33 4.884.33V.329L4.881.328h-.001L4.88.325h-.001L4.877.323 4.874.323 4.874.322 4.873.32 4.87.32V.319L4.868.318h-.001L4.866.315 4.863.313h-.001L4.86.311 4.858.31 4.858.31 4.856.309V.308L4.853.307 4.852.306V.305H4.85L4.849.302h-.002L4.846.3h-.001L4.843.298h-.001L4.84.296 4.837.296 4.836.295 4.835.294 4.834.293 4.832.292 4.831.29 4.829.29 4.828.289 4.827.288 4.825.287 4.824.286h-.002L4.821.283h-.002L4.818.281h-.001L4.815.28h-.001L4.812.277h-.001L4.809.275h-.001L4.806.273h-.001L4.803.273 4.802.272 4.8.27 4.8.27 4.797.269 4.796.268 4.794.267 4.792.266 4.791.265 4.789.264 4.788.263 4.786.262 4.785.26 4.783.26 4.781.259 4.78.258 4.778.257h-.001L4.775.254h-.002L4.772.252H4.77L4.768.25h-.001L4.765.248h-.001L4.762.246H4.76L4.76.244h-.002L4.755.243 4.753.243 4.752.242 4.75.24 4.748.24 4.747.239 4.745.238 4.743.237 4.741.236 4.74.235 4.738.234 4.736.233 4.735.232h-.002L4.73.23h-.002L4.728.227h-.002L4.724.225h-.002L4.72.223H4.72L4.717.222 4.715.222 4.713.22 4.711.22 4.71.219 4.708.218 4.706.217 4.704.216 4.702.215H4.7L4.698.212h-.001L4.695.21h-.002L4.69.208h-.002L4.687.208 4.685.207 4.683.206 4.681.205 4.68.204 4.678.203h-.002L4.674.2h-.002L4.67.198h-.002L4.666.197 4.664.197 4.662.196 4.66.195 4.658.194h-.002L4.654.191h-.002L4.65.19h-.002L4.646.189 4.644.188 4.642.187 4.64.186h-.002L4.636.183h-.002L4.632.182 4.63.182 4.628.18 4.626.18h-.003L4.621.177H4.62L4.617.175h-.002L4.613.175 4.611.174h-.002L4.607.171h-.002L4.602.17 4.6.17 4.598.169h-.002L4.594.166h-.002L4.589.166 4.587.165h-.002L4.583.162H4.58L4.579.161 4.576.16h-.002L4.572.158H4.57L4.567.158 4.565.157h-.002L4.561.154h-.003L4.556.154h-.002L4.552.151h-.003L4.547.15h-.002L4.543.148H4.54L4.538.148h-.002L4.533.145h-.002L4.529.145h-.003L4.524.143 4.522.143h-.003L4.517.14h-.002L4.512.14H4.51L4.508.138 4.505.138h-.002L4.5.136 4.498.136h-.002L4.493.134 4.491.134h-.003L4.486.132 4.484.132H4.48L4.48.13 4.476.13h-.002L4.47.128H4.47L4.466.127 4.464.127H4.46L4.46.125h-.003L4.454.124 4.45.124H4.45L4.446.122h-.002L4.44.121H4.44L4.436.12 4.434.12H4.43L4.43.118h-.003L4.424.117H4.42L4.418.116h-.002L4.413.115h-.002L4.408.114h-.003L4.403.113H4.4L4.398.112h-.003L4.392.111H4.39L4.387.11h-.003L4.382.11h-.004L4.376.108h-.004L4.37.107h-.006L4.363.106h-.005L4.356.105h-.005L4.349.104h-.005L4.343.103h-.007L4.334.102h-.005L4.328.101H4.32L4.319.1h-.008L4.309.1h-.008L4.3.098H4.29L4.29.097H4.278L4.277.096H4.265L4.264.095H4.249L4.248.094H4.227L4.226.093H4.216l.002.685z",
    fill: "#999"
  }), __jsx("path", {
    d: "M4.722.008L3.532 0H.064L0 .077v.745l.063.063h3.474l.948-.147h.237v-.73z",
    fill: "#595959"
  }), __jsx("clipPath", {
    id: "ship5_svg__b"
  }, __jsx("path", {
    d: "M2382 4l-600-4H32L0 36.58V392l32 30h1752l478.14-70H2382V4z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__b)",
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M633 257h550v226H633z",
    fill: "none",
    stroke: "#ca2923",
    strokeWidth: 3,
    strokeDasharray: "24 24 0 0"
  }), __jsx("path", {
    d: "M1776-42h301v511h-301zm-301 0h301v511h-301zm-951 0h301v511H524z",
    fill: "none",
    stroke: "gray",
    strokeWidth: 3
  }), __jsx("path", {
    d: "M-19 45h2423v147H-19z",
    fill: "#8c8c8c"
  }), __jsx("path", {
    d: "M-19 192V45h2423v147H-19zm5-5h2413V50H-14v137z",
    fill: "#d9d9d9"
  }), __jsx("path", {
    d: "M-19 93h2423v51H-19z",
    fill: "#404040",
    stroke: "#fff",
    strokeWidth: 4
  })), __jsx("path", {
    d: "M.063.885L0 .822V.077L.063 0h3.47l1.19.008v.73h-.238l-.948.146H.063zm.004-.01h3.47l.947-.148h.228V.02L3.532.01H.069L.01.08v.737l.057.057z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M2.61.757c0-.084 0-.084-.08-.084H1.15a.082.082 0 0 0-.08.084V.83c0 .046.036.084.08.084H2.215V.887h.316c.079 0 .08-.001.08-.057V.757z",
    fill: "#8c8c8c"
  }), __jsx("path", {
    d: "M1.149.914H1.136V.912h-.005V.911h-.003L1.127.91h-.003V.91h-.003V.908H1.12V.907h-.002L1.116.906h-.001L1.114.905h-.001L1.112.904h-.001L1.11.903H1.11V.902h-.002V.901h-.001V.9h-.001L1.104.9h-.001V.898h-.001L1.101.897 1.1.896H1.1V.895h-.001V.894h-.001V.893h-.001L1.095.892 1.094.891 1.093.89 1.092.89V.888h-.001V.887H1.09V.886H1.09V.885h-.001V.884h-.001V.882h-.001V.881h-.001V.88h-.001V.878h-.001V.877L1.082.876V.875h-.001V.874L1.08.873V.872H1.08V.87h-.001V.868h-.001V.866h-.001V.864L1.075.863V.861h-.001V.86L1.073.858V.855h-.001V.852L1.071.851V.848L1.07.847V.842L1.07.842V.74h.001V.735l.001-.001V.731h.001V.728h.001V.725h.001V.723h.001V.721L1.078.72V.718h.001V.717L1.08.716V.715L1.08.714V.713h.001V.711h.001V.71L1.084.71V.708h.001V.707l.001-.001V.705h.001V.704h.001V.703l.001-.001.001-.001V.7h.001V.7h.001V.698h.001V.697l.001-.001.001-.001h.001V.694h.001V.693h.001V.692h.001V.691H1.1V.69H1.1L1.102.69h.001V.688h.001V.687h.001l.001-.001h.001V.685h.001l.001-.001h.001V.683h.001l.001-.001h.001l.001-.001h.001L1.116.68h.002V.68h.002V.678h.002l.001-.001h.002V.676h.003l.001-.001h.003V.674h.005V.673H1.147V.672H2.573l.001.001h.008v.001h.004l.001.001h.003v.001h.002l.001.001h.001l.001.001h.001l.001.001h.001v.001h.001v.001H2.6v.001H2.6v.001h.001v.001h.001v.001l.001.001v.001h.001V.69h.001v.002l.001.001v.002l.001.001V.7L2.609.7v.005l.001.001V.717h.001V.865h-.001v.004h-.001v.003h-.001v.002l-.001.001v.001h-.001v.001h-.001v.001l-.001.001-.001.001H2.6V.88H2.6v.001h-.002v.001h-.002v.001h-.002l-.001.001H2.59v.001h-.005v.001h-.008l-.001.001H2.548l-.002.001h-.331v.027H1.15zm0-.01h1.056V.875H2.576l.001-.001h.007V.873h.004V.872h.003V.871h.002V.87h.002V.87h.001V.868l.001-.001V.866h.001V.862H2.6V.856H2.6V.706L2.598.705V.7h-.001V.696h-.001V.694h-.001V.692h-.001V.69h-.001V.69h-.001V.688H2.59V.687H2.59L2.588.686h-.002V.685h-.003V.684h-.005V.683H2.568L2.568.682H1.134v.001h-.003L1.13.686h-.003v.001h-.003v.001h-.002v.001H1.12V.69h-.002L1.117.69h-.001l-.001.001h-.001v.001h-.001l-.001.001h-.001v.001H1.11L1.11.696h-.001v.001h-.001v.001h-.001l-.001.001L1.104.7h-.001V.7h-.001v.001h-.001v.001H1.1v.001H1.1v.001h-.001v.001l-.001.001-.001.001v.001h-.001V.71h-.001V.71h-.001v.001l-.001.001v.001h-.001v.001L1.09.716v.001H1.09v.002h-.001V.72h-.001v.001l-.001.001v.001l-.001.001v.002h-.001v.002L1.083.73v.002h-.001v.003l-.001.001v.003L1.08.74v.004L1.08.745v.101h.001V.85h.001v.003l.001.001v.002l.001.001v.002h.001V.86h.001v.002l.001.001v.001l.001.001v.001h.001v.002h.001V.87l.001.001v.001h.001v.001l.001.001.001.001v.001h.001v.001l.001.001v.001h.001V.88h.001V.88H1.1v.001H1.1v.001h.001v.001h.001v.001h.001v.001h.001v.001h.001l.001.001h.001v.001h.001V.89h.001V.89h.002v.001h.001l.001.001h.001v.001h.002v.001h.001l.001.001h.001l.001.001h.002v.001h.002v.001h.002L1.128.9h.003V.9h.004v.001h.005l.001.001h.008z",
    fill: "#d9d9d9"
  }), __jsx("path", {
    d: "M2.096.8a.102.102 0 0 0-.1-.104h-.164c-.055 0-.1.047-.1.105 0 .058.045.105.1.105h.164c.055 0 .1-.047.1-.105z",
    fill: "#333"
  }), __jsx("clipPath", {
    id: "ship5_svg__c"
  }, __jsx("path", {
    d: "M1057 382.012c0-27.607-22.38-49.988-49.99-49.988h-83.022c-27.608 0-49.988 22.38-49.988 49.988S896.38 432 923.988 432h83.022c27.61 0 49.99-22.38 49.99-49.988z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__c)",
    transform: "matrix(.00198 0 0 .0021 0 0)",
    fill: "#4d4d4d"
  }, __jsx("path", {
    d: "M1056.18 412.794l-86.346-92.77-20.262 12.616 86.338 92.77 20.27-12.616zm-66.027 15.616l-86.342-92.77-20.262 12.615 86.342 92.77 20.263-12.616z"
  })), __jsx("path", {
    d: "M2.096.8a.102.102 0 0 0-.1-.104h-.164c-.055 0-.1.047-.1.105 0 .058.045.105.1.105h.164c.055 0 .1-.047.1-.105z",
    fill: "none",
    stroke: "#4d4d4d",
    strokeWidth: 0.02
  }), __jsx("path", {
    d: "M1.56.8a.102.102 0 0 0-.099-.104h-.164c-.055 0-.1.047-.1.105 0 .058.045.105.1.105h.164c.055 0 .1-.047.1-.105z",
    fill: "#333"
  }), __jsx("clipPath", {
    id: "ship5_svg__d"
  }, __jsx("path", {
    d: "M787 382.012c0-27.607-22.38-49.988-49.988-49.988h-83.024c-27.608 0-49.988 22.38-49.988 49.988S626.38 432 653.988 432h83.024C764.62 432 787 409.62 787 382.012z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__d)",
    transform: "matrix(.00198 0 0 .0021 0 0)",
    fill: "#4d4d4d"
  }, __jsx("path", {
    d: "M786.176 412.794l-86.342-92.77-20.262 12.616 86.342 92.77 20.262-12.616zm-66.023 15.616l-86.342-92.77-20.262 12.615 86.342 92.77 20.263-12.616z"
  })), __jsx("path", {
    d: "M1.56.8a.102.102 0 0 0-.099-.104h-.164c-.055 0-.1.047-.1.105 0 .058.045.105.1.105h.164c.055 0 .1-.047.1-.105z",
    fill: "none",
    stroke: "#4d4d4d",
    strokeWidth: 0.02
  }), __jsx("path", {
    d: "M2.183.943V.627l.1.012.064.028.11.016v.193l-.102.017-.06.026-.112.024z",
    fill: "#b3b3b3"
  }), __jsx("path", {
    d: "M2.183.943V.627l.1.012.064.028.11.016v.193l-.102.017-.06.026-.112.024zm.01-.013L2.29.908l.062-.025.093-.016V.693L2.345.677 2.28.65 2.193.639V.93z",
    fill: "#d9d9d9"
  }), __jsx("path", {
    d: "M2.393.685a.262.262 0 0 1 0 .19l-.081-.02H2.28v-.15h.032l.08-.02z",
    fill: "#ccc",
    stroke: "#e6e6e6",
    strokeWidth: 0.006
  }), __jsx("path", {
    d: "M2.383.738c.02.022.02.057 0 .079a.05.05 0 0 1-.075 0 .058.058 0 0 1 0-.08.05.05 0 0 1 .075 0z",
    fill: "#b3b3b3",
    stroke: "#ccc",
    strokeWidth: 0.004,
    strokeLinecap: "butt",
    strokeLinejoin: "miter"
  }), __jsx("path", {
    d: "M2.41.845c.003-.003.003-.007 0-.01L2.3.717a.006.006 0 0 0-.01 0l-.009.01c-.003.003-.003.007 0 .01l.11.117a.006.006 0 0 0 .01 0l.01-.01z",
    fill: "gray"
  }), __jsx("path", {
    d: "M2.424.85c.002-.004.002-.008 0-.011L2.288.695a.006.006 0 0 0-.01 0l-.01.01c-.003.003-.003.007 0 .01l.136.145a.006.006 0 0 0 .01 0l.01-.01z",
    fill: "#f2f2f2",
    stroke: "#ccc",
    strokeWidth: 0.004,
    strokeLinecap: "butt",
    strokeLinejoin: "miter"
  }), __jsx("path", {
    d: "M1.685.647A.046.046 0 0 0 1.641.6a.046.046 0 0 0-.045.047v.302c0 .026.02.047.045.047a.046.046 0 0 0 .044-.047V.647z",
    fill: "#ccc"
  }), __jsx("path", {
    d: "M1.64.999h-.008V.997h-.004V.996h-.003V.995h-.002L1.621.994H1.62L1.62.993h-.001V.992h-.002V.991h-.001L1.614.99h-.001V.99h-.001V.988h-.001L1.61.987H1.61V.986h-.001V.985h-.001V.984h-.001V.983h-.001V.982L1.604.981 1.603.98V.98h-.001V.978L1.601.977V.976H1.6V.975L1.6.974V.973h-.001V.971h-.001V.97L1.596.968V.966h-.001V.963h-.001V.96h-.001V.951h-.001V.636h.001V.632h.001V.63l.001-.001V.626h.001V.624h.001V.622H1.6V.62H1.6V.618h.001V.617h.001V.615h.001V.614h.001V.613h.001V.612h.001V.611L1.608.61 1.609.61h.001V.608h.001V.607h.001V.606h.001V.605h.001V.604h.002V.603h.001l.001-.001h.001V.601h.002V.6h.002L1.624.6h.002V.598h.003V.597h.005V.596H1.653v.001h.003V.6h.003V.6h.002v.001h.002v.001h.001l.001.001h.001v.001h.001l.001.001h.001v.001h.001v.001h.001l.001.001.001.001.001.001.001.001.001.001v.001h.001v.001h.001v.001h.001v.001l.001.001v.001h.001V.62h.001v.002h.001v.001l.001.001v.002h.001v.002h.001v.003h.001v.004h.001v.007h.001V.96h-.001v.004h-.001v.003h-.001v.002L1.683.97v.002h-.001v.002h-.001v.002H1.68v.001H1.68v.002h-.001V.98h-.001V.98l-.001.001v.001h-.001v.001h-.001v.001h-.001v.001h-.001v.001h-.001v.001H1.67v.001h-.002V.99h-.001V.99h-.001v.001h-.002v.001h-.001l-.001.001h-.001v.001H1.66v.001h-.003v.001h-.002l-.001.001H1.65L1.65.999h-.008L1.64 1zm0-.006h.008L1.65.991h.003V.99h.003V.99h.002V.988h.002V.987h.002V.986h.001l.001-.001h.001V.984h.001V.983h.001l.001-.001.001-.001L1.67.98 1.67.98l.001-.001V.977h.001V.976h.001V.975l.001-.001V.973h.001V.972l.001-.001V.97h.001V.968h.001V.966L1.68.965V.963L1.68.962V.96h.001V.953h.001V.637L1.68.636V.633H1.68V.63h-.001V.627h-.001V.626L1.676.625V.624L1.675.623V.622h-.001V.621L1.673.62V.62h-.001V.618h-.001V.617H1.67V.616L1.67.615V.614h-.001L1.667.613h-.001V.612h-.001V.611h-.001V.61h-.001L1.662.61h-.001V.608H1.66V.607h-.001L1.657.606h-.002V.605h-.002L1.652.604H1.65V.603H1.628v.001h-.003v.001h-.002v.001h-.002v.001H1.62V.61h-.001V.61h-.002v.001h-.001v.001h-.001l-.001.001v.001h-.001l-.001.001v.001H1.61L1.61.618v.001h-.001V.62h-.001V.62l-.001.001v.001h-.001v.002h-.001v.001h-.001v.002l-.001.001V.63h-.001v.003H1.6v.003H1.6v.007h-.001v.315H1.6v.004h.001v.003h.001v.002l.001.001V.97l.001.001v.001l.001.001v.001h.001v.001l.001.001v.001h.001v.001h.001v.001h.001V.98l.001.001.001.001.001.001h.001v.001h.001v.001h.001v.001h.001l.001.001h.001v.001h.002v.001h.002V.99h.002V.99h.002l.001.001h.003v.001H1.64z",
    fill: "#999"
  }), __jsx("ellipse", {
    cx: 1.641,
    cy: 0.647,
    rx: 0.051,
    ry: 0.053,
    fill: "#f2f2f2"
  }), __jsx("ellipse", {
    cx: 1.641,
    cy: 0.947,
    rx: 0.051,
    ry: 0.053,
    fill: "#f2f2f2"
  }), __jsx("path", {
    d: "M1.621.275l-.046.103h-.043L1.529.253l.092.022zm0-.066L1.575.107h-.042l-.005.124.093-.022zm-.105.053l-.062.056c-.004.004-.016.003-.02 0C1.431.316 1.43.312 1.431.31l.027-.053.058.006zm0-.039L1.454.168c-.004-.004-.017-.003-.02 0-.003.001-.005.005-.003.008l.027.053.058-.006z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1.824.242c-.005.01-.08.012-.08.012a.44.44 0 0 1-.118.021L1.53.278V.266s-.04.002-.054 0A.113.113 0 0 1 1.443.26V.247l.014-.005-.014-.005V.225a.127.127 0 0 1 .033-.006h.052v-.01s.069-.002.097 0a.716.716 0 0 1 .12.022s.072.002.079.011z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__e"
  }, __jsx("path", {
    d: "M920 115.657c-2.682 4.557-40.11 5.615-40.11 5.615-2.577 2.753-41.194 9.522-59.523 9.948-14.15.328-48.452 1.283-48.452 1.283l-.16-5.776s-20.082.802-27.436.32c-5.74-.374-13.852-1.737-16.686-3.208v-5.937l7.06-2.406-7.06-2.407v-5.936c2.674-1.39 11.232-2.234 16.685-2.728l26.472-.32v-4.172s34.68-1.043 48.934-.16c12.304.76 57.17 7.82 60.164 10.428 0 0 36.735.916 40.11 5.455z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__e)",
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M726.19 104.266h9.466v22.622h-9.466z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1.554.217l-.048-.02-.027.001.01.02s.023.005.065 0zm0 .048l-.048.02h-.027l.01-.021s.023-.004.065 0z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1.718.242c0-.004-.001-.008-.005-.008h-.029c-.012 0-.016.004-.016.01 0 .004.013.006.016.006l.03.001c.003 0 .004-.006.004-.009z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1.72.242L1.718.234h.01c.012 0 .016.003.016.008S1.74.25 1.728.25l-.01.001.002-.009z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1.621.275l-.046.103h-.043L1.529.253l.092.022zm0-.066L1.575.107h-.042l-.005.124.093-.022zm-.105.053l-.062.056c-.004.004-.016.003-.02 0C1.431.316 1.43.312 1.431.31l.027-.053.058.006zm0-.039L1.454.168c-.004-.004-.017-.003-.02 0-.003.001-.005.005-.003.008l.027.053.058-.006z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1.824.242c-.005.01-.08.012-.08.012a.44.44 0 0 1-.118.021L1.53.278V.266s-.04.002-.054 0A.113.113 0 0 1 1.443.26V.247l.014-.005-.014-.005V.225a.127.127 0 0 1 .033-.006h.052v-.01s.069-.002.097 0a.716.716 0 0 1 .12.022s.072.002.079.011z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__f"
  }, __jsx("path", {
    d: "M920 115.657c-2.682 4.557-40.11 5.615-40.11 5.615-2.577 2.753-41.194 9.522-59.523 9.948-14.15.328-48.452 1.283-48.452 1.283l-.16-5.776s-20.082.802-27.436.32c-5.74-.374-13.852-1.737-16.686-3.208v-5.937l7.06-2.406-7.06-2.407v-5.936c2.674-1.39 11.232-2.234 16.685-2.728l26.472-.32v-4.172s34.68-1.043 48.934-.16c12.304.76 57.17 7.82 60.164 10.428 0 0 36.735.916 40.11 5.455z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__f)",
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M726.19 104.266h9.466v22.622h-9.466z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1.554.217l-.048-.02-.027.001.01.02s.023.005.065 0zm0 .048l-.048.02h-.027l.01-.021s.023-.004.065 0z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1.718.242c0-.004-.001-.008-.005-.008h-.029c-.012 0-.016.004-.016.01 0 .004.013.006.016.006l.03.001c.003 0 .004-.006.004-.009z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1.72.242L1.718.234h.01c.012 0 .016.003.016.008S1.74.25 1.728.25l-.01.001.002-.009z",
    fill: "#333"
  }), __jsx("g", {
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M113.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81L25.54 310.99l39.934 43.565 25.752-40.5zM71.827 369.53l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__g"
  }, __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__g)"
  }, __jsx("path", {
    d: "M36.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M70.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M137.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M137.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M113.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81L25.54 310.99l39.934 43.565 25.752-40.5zM71.827 369.53l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__h"
  }, __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__h)"
  }, __jsx("path", {
    d: "M36.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M70.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M137.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M137.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M113.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81L25.54 310.99l39.934 43.565 25.752-40.5zM71.827 369.53l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__i"
  }, __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__i)"
  }, __jsx("path", {
    d: "M36.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M70.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M137.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M137.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M113.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81L25.54 310.99l39.934 43.565 25.752-40.5zM71.827 369.53l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__j"
  }, __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__j)"
  }, __jsx("path", {
    d: "M36.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M70.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M137.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M137.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("g", null, __jsx("path", {
    d: "M113.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81L25.54 310.99l39.934 43.565 25.752-40.5zM71.827 369.53l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__k"
  }, __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__k)"
  }, __jsx("path", {
    d: "M36.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M70.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M137.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M137.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M113.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81L25.54 310.99l39.934 43.565 25.752-40.5zM71.827 369.53l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__l"
  }, __jsx("path", {
    d: "M174.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S64.32 380.44 58.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.786-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__l)"
  }, __jsx("path", {
    d: "M36.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M70.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M137.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M137.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }))), __jsx("g", {
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M1484.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__m"
  }, __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__m)"
  }, __jsx("path", {
    d: "M1407.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1441.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1508.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1508.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1484.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__n"
  }, __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__n)"
  }, __jsx("path", {
    d: "M1407.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1441.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1508.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1508.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1484.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__o"
  }, __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__o)"
  }, __jsx("path", {
    d: "M1407.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1441.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1508.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1508.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1484.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__p"
  }, __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__p)"
  }, __jsx("path", {
    d: "M1407.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1441.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1508.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1508.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("g", null, __jsx("path", {
    d: "M1484.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__q"
  }, __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__q)"
  }, __jsx("path", {
    d: "M1407.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1441.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1508.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1508.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1484.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__r"
  }, __jsx("path", {
    d: "M1545.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__r)"
  }, __jsx("path", {
    d: "M1407.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1441.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1508.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1508.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }))), __jsx("g", {
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M243.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__s"
  }, __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__s)"
  }, __jsx("path", {
    d: "M166.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M200.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M267.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M267.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M243.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__t"
  }, __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__t)"
  }, __jsx("path", {
    d: "M166.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M200.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M267.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M267.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M243.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__u"
  }, __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__u)"
  }, __jsx("path", {
    d: "M166.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M200.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M267.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M267.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M243.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__v"
  }, __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__v)"
  }, __jsx("path", {
    d: "M166.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M200.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M267.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M267.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("g", null, __jsx("path", {
    d: "M243.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__w"
  }, __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__w)"
  }, __jsx("path", {
    d: "M166.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M200.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M267.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M267.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M243.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__x"
  }, __jsx("path", {
    d: "M304.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S194.32 380.44 188.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__x)"
  }, __jsx("path", {
    d: "M166.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M200.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M267.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M267.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }))), __jsx("g", {
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M1614.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__y"
  }, __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__y)"
  }, __jsx("path", {
    d: "M1537.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1571.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1638.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1638.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1614.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__z"
  }, __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__z)"
  }, __jsx("path", {
    d: "M1537.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1571.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1638.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1638.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1614.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__A"
  }, __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__A)"
  }, __jsx("path", {
    d: "M1537.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1571.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1638.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1638.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1614.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__B"
  }, __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__B)"
  }, __jsx("path", {
    d: "M1537.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1571.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1638.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1638.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("g", null, __jsx("path", {
    d: "M1614.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__C"
  }, __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__C)"
  }, __jsx("path", {
    d: "M1537.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1571.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1638.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1638.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1614.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__D"
  }, __jsx("path", {
    d: "M1675.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__D)"
  }, __jsx("path", {
    d: "M1537.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1571.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1638.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1638.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }))), __jsx("g", {
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M2013.58 313.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__E"
  }, __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__E)"
  }, __jsx("path", {
    d: "M1936.54 352.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1970.12 317.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M2037.17 267.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M2037.97 267.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M2013.58 313.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__F"
  }, __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__F)"
  }, __jsx("path", {
    d: "M1936.54 352.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1970.12 317.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M2037.17 267.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M2037.97 267.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M2013.58 313.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__G"
  }, __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__G)"
  }, __jsx("path", {
    d: "M1936.54 352.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1970.12 317.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M2037.17 267.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M2037.97 267.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M2013.58 313.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__H"
  }, __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__H)"
  }, __jsx("path", {
    d: "M1936.54 352.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1970.12 317.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M2037.17 267.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M2037.97 267.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("g", null, __jsx("path", {
    d: "M2013.58 313.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__I"
  }, __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__I)"
  }, __jsx("path", {
    d: "M1936.54 352.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1970.12 317.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M2037.17 267.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M2037.97 267.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M2013.58 313.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__J"
  }, __jsx("path", {
    d: "M2074.95 230.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__J)"
  }, __jsx("path", {
    d: "M1936.54 352.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1970.12 317.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M2037.17 267.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M2037.97 267.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }))), __jsx("g", {
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M373.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__K"
  }, __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__K)"
  }, __jsx("path", {
    d: "M296.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M330.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M397.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M397.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M373.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__L"
  }, __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__L)"
  }, __jsx("path", {
    d: "M296.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M330.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M397.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M397.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M373.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__M"
  }, __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__M)"
  }, __jsx("path", {
    d: "M296.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M330.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M397.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M397.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M373.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__N"
  }, __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__N)"
  }, __jsx("path", {
    d: "M296.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M330.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M397.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M397.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("g", null, __jsx("path", {
    d: "M373.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__O"
  }, __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__O)"
  }, __jsx("path", {
    d: "M296.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M330.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M397.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M397.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M373.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__P"
  }, __jsx("path", {
    d: "M434.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S324.32 380.44 318.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__P)"
  }, __jsx("path", {
    d: "M296.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M330.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M397.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M397.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }))), __jsx("g", {
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M1744.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__Q"
  }, __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__Q)"
  }, __jsx("path", {
    d: "M1667.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1701.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1768.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1768.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1744.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__R"
  }, __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__R)"
  }, __jsx("path", {
    d: "M1667.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1701.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1768.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1768.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1744.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__S"
  }, __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__S)"
  }, __jsx("path", {
    d: "M1667.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1701.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1768.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1768.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1744.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__T"
  }, __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__T)"
  }, __jsx("path", {
    d: "M1667.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1701.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1768.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1768.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("g", null, __jsx("path", {
    d: "M1744.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__U"
  }, __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__U)"
  }, __jsx("path", {
    d: "M1667.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1701.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1768.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1768.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1744.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__V"
  }, __jsx("path", {
    d: "M1805.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__V)"
  }, __jsx("path", {
    d: "M1667.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1701.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1768.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1768.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }))), __jsx("g", {
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M496.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__W"
  }, __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__W)"
  }, __jsx("path", {
    d: "M419.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M453.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M520.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M520.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M496.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__X"
  }, __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__X)"
  }, __jsx("path", {
    d: "M419.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M453.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M520.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M520.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M496.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__Y"
  }, __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__Y)"
  }, __jsx("path", {
    d: "M419.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M453.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M520.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M520.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M496.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__Z"
  }, __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__Z)"
  }, __jsx("path", {
    d: "M419.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M453.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M520.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M520.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("g", null, __jsx("path", {
    d: "M496.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__aa"
  }, __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__aa)"
  }, __jsx("path", {
    d: "M419.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M453.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M520.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M520.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M496.575 336.177l18.038 51.39-15.202 15.203-43.11-41.068 40.275-25.525zm-22.349-22.123l-50.938-17.81-14.748 14.747 39.934 43.565 25.752-40.5zm-19.399 55.476l-3.404 40.615c-.24 2.882-5.048 6.94-6.92 7.374-1.86.43-3.694-.166-4.425-1.93-2.004-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.345-13.26l-40.614 3.404c-2.882.242-6.94 5.05-7.374 6.92-.432 1.86.165 3.695 1.928 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__ab"
  }, __jsx("path", {
    d: "M557.95 253.02c1.326 5.118-24.39 32.332-24.39 32.332.123 3.77-22.397 35.86-35.056 49.123-9.774 10.24-33.354 35.17-33.354 35.17l-4.197-3.972S447.32 380.44 441.78 385.3c-4.323 3.79-11.023 8.565-14.067 9.53l-4.198-4.198 3.29-6.694-6.693 3.29-4.198-4.197c.908-2.873 6.363-9.52 9.87-13.727l18.492-18.945-2.95-2.95s23.787-25.26 34.488-34.715c9.24-8.162 45.956-34.897 49.917-35.17 0 0 26.625-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__ab)"
  }, __jsx("path", {
    d: "M419.544 375.316l-6.693 6.694 15.997 15.996 6.694-6.694-15.996-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M453.125 340.828l-23.938 10.55-9.075 9.757 10.437 3.177s9.403-6.807 22.575-23.484zm16.223 16.222l-10.55 23.938-9.757 9.076-3.176-10.437s6.807-9.404 23.484-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M520.172 290.798c-1.19-1.19-3.234-2.212-4.424-1.02l-10.437 10.436c-4.202 4.203-4.446 7.108-2.722 8.85 1.713 1.73 7.18-2.19 8.282-3.29l10.664-10.212c1.19-1.19-.17-3.574-1.362-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M520.967 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.743-3.743c4.203-4.203 6.882-4.674 8.622-2.95 1.618 1.603.6 4.358-3.063 8.51l-3.405 3.856s-1.078-2.666-2.268-3.856z",
    fill: "#333"
  }))), __jsx("g", {
    transform: "matrix(.00198 0 0 .0021 0 0)"
  }, __jsx("path", {
    d: "M1867.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__ac"
  }, __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__ac)"
  }, __jsx("path", {
    d: "M1790.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1824.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1891.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1891.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1867.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__ad"
  }, __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__ad)"
  }, __jsx("path", {
    d: "M1790.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1824.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1891.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1891.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1867.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__ae"
  }, __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__ae)"
  }, __jsx("path", {
    d: "M1790.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1824.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1891.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1891.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1867.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__af"
  }, __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__af)"
  }, __jsx("path", {
    d: "M1790.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1824.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1891.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1891.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("g", null, __jsx("path", {
    d: "M1867.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__ag"
  }, __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__ag)"
  }, __jsx("path", {
    d: "M1790.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1824.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1891.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1891.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1867.58 336.177l18.03 51.39-15.2 15.203-43.11-41.068 40.28-25.525zm-22.35-22.123l-50.94-17.81-14.75 14.747 39.93 43.565 25.76-40.5zm-19.4 55.476s-2.71 32.248-3.41 40.615c-.24 2.882-5.05 6.94-6.92 7.374-1.86.43-3.69-.166-4.42-1.93-2.01-4.84-7.94-27.68-7.94-27.68l22.69-18.38zm-13.35-13.26l-40.61 3.404c-2.88.242-6.94 5.05-7.38 6.92-.43 1.86.17 3.695 1.93 4.425 4.84 2.003 27.68 7.94 27.68 7.94l18.38-22.69z",
    fill: "#bfbfbf"
  }), __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z",
    fill: "#ccc"
  }), __jsx("clipPath", {
    id: "ship5_svg__ah"
  }, __jsx("path", {
    d: "M1928.95 253.02c1.33 5.118-24.39 32.332-24.39 32.332.12 3.77-22.4 35.86-35.06 49.123-9.77 10.24-33.35 35.17-33.35 35.17l-4.2-3.972s-13.63 14.767-19.17 19.627c-4.32 3.79-11.02 8.565-14.07 9.53l-4.19-4.198 3.29-6.694-6.7 3.29-4.2-4.197c.91-2.873 6.37-9.52 9.87-13.727l18.5-18.945-2.95-2.95s23.78-25.26 34.48-34.715c9.24-8.162 45.96-34.897 49.92-35.17 0 0 26.62-25.326 32.22-24.503z"
  })), __jsx("g", {
    clipPath: "url(#ship5_svg__ah)"
  }, __jsx("path", {
    d: "M1790.54 375.316l-6.69 6.694 16 15.996 6.69-6.694-16-15.996z",
    fill: "#333",
    stroke: "#999",
    strokeWidth: 1.71
  })), __jsx("path", {
    d: "M1824.12 340.828l-23.93 10.55-9.08 9.757 10.44 3.177s9.4-6.807 22.57-23.484zm16.23 16.222l-10.55 23.938-9.76 9.076-3.18-10.437s6.81-9.404 23.49-22.576z",
    fill: "#a6a6a6"
  }), __jsx("path", {
    d: "M1891.17 290.798c-1.19-1.19-3.23-2.212-4.42-1.02l-10.44 10.436c-4.2 4.203-4.45 7.108-2.72 8.85 1.71 1.73 7.18-2.19 8.28-3.29l10.66-10.212c1.19-1.19-.17-3.574-1.36-4.764z",
    fill: "#333"
  }), __jsx("path", {
    d: "M1891.97 290.004c-1.19-1.19-3.63-1.816-3.63-1.816l3.74-3.743c4.2-4.203 6.88-4.674 8.62-2.95 1.62 1.603.6 4.358-3.06 8.51l-3.4 3.856s-1.08-2.666-2.27-3.856z",
    fill: "#333"
  }))));
};

/* harmony default export */ __webpack_exports__["default"] = (SvgShip5);

/***/ }),

/***/ "./src/games/seabattle/media/hit1.mp3":
/*!********************************************!*\
  !*** ./src/games/seabattle/media/hit1.mp3 ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:audio/mpeg;base64,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e3ynqxJkjgRSc7NTudB/////7x///+7z/ff7r9f+vq2csd/8/Y7nrK07p/93u/pfbhY1XMuppFclZFT6WS+21pgE3QCIw6AA4GdsIB87vCwxzCQ0REUyaLE3OG4ypHExQIkxHD0yhL4wuN8w9IcytE0zSHkEEEAHwZkDBySA5qzR2C9ZKeYhgLUSAGXQUeX3Oh8C2mUWXDMTwe6BohxPJWGoKaR4sUYDhnaGy2HPGuOBoDiMDgjiKMNobcEBBKqOFnC0ugACiAIzQTSSCiwHbNMMMZKAjCCJl//7wGTfAAi4Zcv+b0AAAAAP8MAAACwKDS/53IAAAAA/wwAAAC94JBEApVIQJgkovUZySRheVFoveTGUY8uW3CohcEqEmWWh8QIhZMGDCE4MZMEEBIIIl9prAYJRZcVR9WtIlKkaSDgErKeENbctjCXqNStSGraMlfpmcbbW3asP/G26Rtrsux7SX6SrKZfWprC7uSuAZRnjj2rKtZWe5b5zvMf5r//XOb73XM//m6tm7SXL//25Wu9zsfjlz8c+83/cf/////////+///++f////////////9/YMjcFlQA8hrRZNLQ2AbHk87nYaAxbyhJxkgZEAnvEL/moJRqBYYmRmRohlYUYqBGHBxjICZq6ig0gBCwiqQCmmbWYNIBIT/MtE+/Qa+afxLMlWu2GzGNkSjMoSoRKAc6pk214MIUZYqqo8C7VOKURoHUAagJh1i1CdLzKlSpQVceGWtzzO401MqLiMJHhU46gyiKIrQuUvrII27jYGeTtQeJBRA8ULCoUBcFDQvShJZg5bdViIjP5PwHE6GRQPfpUM1VwsAoI2VPYaCiTkLDSVaMDLtmqaq+2eH4c1hvPea6pbDcWezGNwijoZRMxm5BUKltLdnH1k3/////////9PTxydvarzuV67lhhqVal1X+ax5l+u1u///////////////////Yw3h+OGGf2rmocry7qIdUdkZZ7/vtbGmATcBVzOsCzuYnzF8NjVkVyIKjNYGzB0cjM9czDVDzNYEzCBDDB0KTH0izIUnDPAXDJESDGI+zYrTbTDFNjyOBpMbZyYM2DEYqmNOzNgrBrYySYMGmLGDpUyRsw54FFTaDDtLACxMOYJAocCMEjCEpnhZmQBEcDCpQCAA4x7ERKDZnhpyACJlh4gIGOLiAEChmKehhw5UHgg0HJzCEjDEzeqTHtzAjho8XiCg8xAwyyMECgaNMMbHSQgBmABqmYKq1IVe7s//uwZP6ACU56zf5vIIAAAA/wwAAAKHF9L/ndAAAAAD/DAAAAOmkW3AyIAv8qqQjlYTAiB4HIZuUPU3V2kxlStSau+7L1A1zJIRCnpXewcKaVM+7hT1M06Ev3P0ncKeUVKfKrnbpP7hhUsTUWgGm7Vpt2fyw1///////71nj3DX/rnd9//qgyCKyohTX6//STUKf7O5UwOLuHlnRzVVTN9PN2SSIo5qKJUY0FiBhy4YhxkMyiMADUwCFzK6INPBIw2UjH4jAAgFQcJA8yoDTCAYOuUM/QBDoREWFwTcaAJQgNAoiwLQULxaQHPsXMoJBCHDpOMVfaGoZQbKgTJU10lwU2X0NA5gKpWIvqw0voREI5lk0B6LMrAAjUB4VIZlMPSq3KpcyhsDA5Og4kI4qNqQbOC7bB2sSmAnel3KzWnNYytf2hroh9tm6wtdkFv3DtrF/Z19o6/sZuymKxdu7fsQl66KOtVpHYnIhOatxvKX36WUwzAUPW6amz1k77+O3CbcYdeG592Ipy3+f7t8z/9WO4Zb5lv9fjj///4Wz4wBlwiFDjk3/+R//n0Sc4DBSgygpgpgRAYGQwEBQIAYiDqxjeuSNhoH/N2Asy0XDEyaMSlT/AQzBIoIjeYcD/+DYOAxRMigGBAYZ+BjQwtgAiUAgOHQcZMXEVAtCDPRCUmA4nysJRF+KWG8KVBsoDDNQMMXBoG+F1YncPkELjkhl4EgoWIiNBkiNEo/i6FtE9ifB9C0uHRCkiLkMHUOITb/GaMB3FliIk4SY6CAlAjyiToxxAimSn/IAJCRQQWKo4yHkwVR2jaIcSRATEyJUolUhxNHf/+6Bk7oAIv1/M/nMgAAAAD/DAAAAgces3+coEAAAAP8MAAAD/kEJgmyHFYdo6y+PyZBSsSBME+ShNFsmTEyI0mS0TRkYkcTR///qSRTTUtFJBk///LqJkRpMni85iRxNHy6pMQU1FMy45OS41qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+xBk04/wAABpBwAACAAADSDgAAEAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg=="

/***/ }),

/***/ "./src/games/seabattle/media/hit2.mp3":
/*!********************************************!*\
  !*** ./src/games/seabattle/media/hit2.mp3 ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:audio/mpeg;base64,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kJcPoonShex0hfOs5wRIcIzh98EyBAhrPsuqr/////////////2d1QC5SgABeAAAZxQhQOBzJtRpDo3IfrJSNfBGYaLUlLmspyRhx4PbVukxMFTgfUMUzFgTKVSw7b2POcyU+suZ8bu3NMAoBWf//////////+hn/+6oVAC4AAB6NaLgJog6YGlAsK9wQN3VuMMR6VVVC0h63sYZKMn6npEwFkNdYY7EjTBeP8TEQ8FIDYjK7btnjtbC8my2Zv/7gETngRKpH0preEh4SUP5jW8MD0iEcy2tPSdhV5BldbektB/ZNHeP89kE///////////VoWaEn/XV2AGaRAEO8HArAgby7ADeVEPETET8esqhCimaMHbmo6yx14jhSULmgiWV5h7w+9Nf1ChskOkqXhQNIyuK5njU2rQHUf///////////s//0gAxAAACcGR7KZOKZ/oCUZygqVrtFmwwYtquRdjU5JBziw4+z6r4ZWyopAcNlKJKP7isroBXpxWXGq9ys1lUsWZzNdyy5c99+nZb7///////////yn/+hQJLdGEFuAAACbxMCKwocQcZOFQIcNJkOhUKHAZGiGyZcj9W2/fxllgbNUbUYTTek63Rkow+CXvUNIrX2O/ukn//////////////0AbQABOAAAcacHjoQFGgIRmCiVKYYyNUa8FWKWLXagk27zPn+mW5Kqu2zF/JXIbQA7BoViVCBRATHSAlvY/j4Ygg//uARO+BEpYdSmt5SHhbJBk3bwwfCcB1K63hIeFakKU1zLA8aL+HtU3F7QOBESv//////////XzFq2xf/yHuaApDIqCRS/g6qI6oE4oUbHlMJLlpirEEQFFnhlDFGyLqpZIcqBqXD3RacUQULajkOrJaYH4tHdUsFWGUrlVzZBE5eAa5UAArwZa2E5cezl9DCV0wcVKYcGsOtJXKRimUBrleJ2n/YxCXTAVcmIolRghmCzRazSg0OIFYwl0AuTQJIwuVtDzY44S//////////////tuVBVymJSn4AABm4GwI+4kAiEnOXgTBdcdGmnMs2dtc0aYhLiLAePnEYqnA+vKLUXdRsYJUKpWEEhqc3Kxb3AJ4gJ3tAAG8AAA5dsOHKjjDXiJXoPl3y5D3EILUFrN4nOrFFHMwf1tYo1lGBKo6skC8YqY9Wc3NIquDeqFmfW09oICpACr///////////3av+kBdZhUNDc4Afn/+4BE6oESVxzLa1hIeFzDyTpvCR8IQGUv7WGBoUqOJXW8JDydwbASQoKAkWnWXALKiMQBUukHgYjIGZdLhVbEYzHp9ALKd5TffVNbaig1dehpSUVdhRNAhOOEAzcGWhBwgOE/MUi0F1NNS5nCTbaER3iZ+yWYYtAQwSgqdNTsiLd0KT7NcbLFis8aZpgSuRlZP+7rLRlP//////////////sVAe0kJbfAAAByRpwiIbtqQdBP4UKpiuNTov+sOqrEmfwOwVsZQMsCFYRGNfM0jaUGaSixZBKSFJnBXJFNCRLf///////////Sz2//R0BubZhI38AAA8KYyhYe6nedpuWLCfpxUJbQ0rk+0PJdTQ4zqYEsEwysQskVGq7UvJxUSI0Mo42yagsjlonEW0DHda2peAcXfGQIASjLrLGKBMVVYIBiIkpUxg1WeRrpbW3ROBADMpDhXZaXvREgiycemJJTg/ZMRQx1Ub/////7cETwgRH5GktrOEhqT+NZXW8pDweMYzHs4YEpK45ltbwkNP////////9H/uWAlo2UUuAccEIZ5pGn0QsSOXuoCFBFQrIBQLNWlOyHD4qUIaYdnQ5cil9KueOEa2OVioqW2219pY+yDwkb///////////////1qgB1aEMzR3gAAAbvJuiZIOCX6CpZaXdJnr5RoWOJo8eHlD0/KxVFqR1xIyay3UulA+5dY7NV2MRw+4DgJiQt///////////92hH/q94Du9pUc4AAAO3BMY8FrIcw7sOMLDGp7AAIwFCYz92FdNalU8AwkI2xOFtes6RVsQqZBWMRO2ery6s24JsX//////////////+gFS3xGOcADbzwgB8iGJfi2nitRF5UywjKWmpyPzCGhQY2BguQrkDyEBUDM9H/+3BE74ESZRlKa1hIaD7DKX1rCQ1JGGcrrWEj4SQMZXWsMCwY4rNlCJWV1pKbaLGJbjkf//////////pfam9rKWpr3R+MVSIAVaZWUjZbgHKiAXzMAzwBX2EiVgJpiyRK77TWV/MrcppMOiZ4fZOECYYCwJoALajm6tTYPIz23OLKjoTFBWiolUVt+AAAD1WIRQX0CjOyU1UEqCRpI6MtC0heTfyUqHgwJ9CcodJRMJhjDjr61BrZhSJKm3QRJI3KgDppUWnwAAActGYckTMEpAGmcAPbLwJiltWdIsNKtprDMD4+nAXNo15ViXMmzazFDDS6zB4bdWc6Y3VCIHb///////////9XFf/+tICqzDwaJNwAHsqKDyvqOhUDLwsJB7ApCuI8uhJmI8FCdClfpvKAKJc4w30S//uAROsBEl8XSns4YEhI4yl9awkNChhpJa1hIaDwjCY9nCQ1KOOtEFVUHqSZRBxH///////////+ywj+gILuQAh8A6FkNhIxHAaOTMUOfMugmmi4t9o7L1kzb+rFsCJGAogJRRapdpl8Lv4pohDFSrJSKH1kU0EAg7/////7v////2a7zpWLdHT2WIiiC1+2k//AAAASGUvLioci7xetpajamqISwsDVFtNiX8yCuvMSSfh6wuTlReTB4eN49cnxMQaXWv4SWn///////////////0ha+3Fp7gAAATqCqQ+AaiBgKjWHTliIs9HJuUCQGsRkcXbSRoQiQDkioxFgsitzBVNJCYSKNopq2sIw3f///////////9+oB77SR78AyajGFQGMRDiILJA47E25pbQMzpqjYm/pI2AlOWCSUl5ZZiXPdI5wbxw7Gcu1T48wDIXb////////////9v92r0gWPSlN3gHBiha0ABL/+3BE/oER4hXL+zhgWkvjCU1rLAsIjF0p7DzHIUCNJLW8JDQjCSIUXoqFVFgLIi10MypaKdLuvi8KEJuQFWp+qOIyvCvLDaL4KMsuLp2DqxP2Dp3///////////vv7Wf9ytWSNQJZqZuZiYiGdgAAAAADHwGuaSIKMnhhA8QIDiQCKxYgCVhmQAINphImAQcrOnMU4GYkgpwsxfEScrKomJMH61w7Tb727Cn/////////////9QCcPERCOzs6qwdAYAAAAAATKZYU9k4TYCDWADBiyhkggSaEmhowBMFJCaA0FNRAGBzNoyuWoJwiTy3CiysjXkD2dvunosLA8qn+cyxk3wC81WN////f//tY27bvl3m//////////+vbGu/5kQjP/1EDrBB4KhAIAwJAADKlEGUqW0/w//twRPqBEjUYSutMM7hGIulNZwkNCNxbJ7WWACE1DGT2tsAEeRMKqjdb/Lxqe7v/ACuBX/DwaEX8fGOnP9Jakl/+pJakl//1L///6vV//////////3S/////rSR1LOmq0pkEgrgkAagSgjBICAAAAAAAdWwDEpiD4QE/zPQjg4ll6/yBiFB0aeH/AFgEhUlhdIAVA3JjS4TAAVAIGGLjGkY+ASAN0Q9oG/BgXX/IcLmHJJoZYcn/8vEWJkvEWJkvf/5FiZNiLEybEWLpt//+TxdNieLpsTxdPl4u///+fLxqfLxqfLxqfNjU3Lxd/////Pm5VLZsTpufIqkmeM1MQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kET0gAKJE8x2beAAceO5T81gAAnlsx95poACbrZlfzUiAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7EGTcD/AAAGkHAAAIAAANIOAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV"

/***/ }),

/***/ "./src/games/seabattle/media/hit3.mp3":
/*!********************************************!*\
  !*** ./src/games/seabattle/media/hit3.mp3 ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:audio/mpeg;base64,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gpuX//////gpqYbkdiK4KABUObbfAA0LhOAmTsNNsEELBcwwjWzFsWuqMFxW4o+S9mSl9ORAVKeMnpVM2cnbY8ZiqpGVIlyWpIkmrjGmoxlbMIqSdCi8KHRYWISbCFdYfMFcKuln6iW0KAZBC8AHUNhFVGUGQ8JFGTptUgYhCEEkDiEAVA22WFUHMpVNU6GwS+JBRBC1Zq3A6DJETx7xcz4AIwM+3WPOLgaaGgDRpxOPxGOYPiA0QHHg8M0aNrC+LlnHQAWaFAVmK52CrWeCeo8NYYsHoqnMrn1hz/////////////q///6KXAAAANadTmWE312MtUDFiM4cRAupoJDYZxxG2WZJYqCdTIs2BpQQkgCJgnnGSIBTAVpk7pAsOBgtN1Bd6GvIKyDCX///////////+j9X6+1FJ4AAABqJBjJZthZ615uDgr8NvKGCKQccC6izRIkKkGVAeJQOWwTcSXflxUkFu//7kETVgRKOEc7TeWBqWgOZym8pD0bMTTdN4SOpJYnlTbzglBpuwzH72lhURMdtYFZkC/////////////+e/+lfc+ABbmnJ20LRIzcCRUDmYggWTGTTCCEAC0EqhIkBEDgRe0ARqRLpNNgN7EKMTWAsCXWAu6Cj+hwSuADsVc1fMGmI6I0VkOD4Egg4MdiN2wOMDOBCu7CPJyDpmkWaZaakTZctVreb9shpwreVZbaNBgB/////////////ppwAAADp0cOrqwzQLzHIaPQ0+6wzI3zACAZyYRkYkSHIuaClx45AaClQcMk8penEu9p8BVCyEPxg2ZBAWn9gxQgZ///////////////pfAAAANEHA8SSQxmmJRSEahd8HPnCKOwAQctskgpWYyRbcW1FtEPREDAkKcFUDfPhVOFhSsqXFz/9NKzJif////////////+7/3t1L6g0Org2gSsxdOAxVAcFhDZOzoiQMRMwHMboPgdGTJy1IkWTrIiqpgi6akQMFgaJBwdHVIeD38ExG4czGyclvrRwL1nxL4sjgsCaQv/7cET+DdKLFMobeWFoS0J5Q2ssHwcITy5uZSVpC4jlTbykfABHjrk///9upgrd3/////CqaCxhCin3TUXUxPGr8AzvpDRqCM4rYAgoqC4dIhtgHIMb5oqcIjy5hfoULLIDTyC682qr9geRKAS+niojFZRemBx3z9OZkBrDyGlP//////////9X7X//1TwAAADhQjNfzY2iWjPwwMWhAKGAZENsRNMGGNeOMgyhQrGEFGkSbohcEQjEIkveBlDLtvwWAdAiWIOu9S0GW////////////9X+r9XxZD/AAABr9Ymi6QZZNQJGA0mYux2XBGR4Sir4kircDSDvSY2OOCRRMSvNRdABDYgsEdBNDTMzTTNZrzpQKyrLf///////////02//+iSNHEk0LHDPaDmIzEmTTEALo4z/+4BE/I3SaBTKm5lI+EsiiUNzKR8NCGMibumD4TIKJQ3MpLSS1MMEt0AAMAww0bYKd+r6Lwr8qPvCIMkMnk0vt77FNd53cqKs/////////////+z+mn3vAGAK8AGOEoUiApYPmqVm8AIgFjPKpkXpL3w00pTYHAO8qkzKu2uJoNq7Ah76gUm541UAAApwAAADj1hNYncZZBYAaMe7jU0fwSqARQYQWbL5qmTUDlEqEHkFF2xWNAsfFQmDq2fnBMZllAgAQP3AAAAMUWj0XkzQHDG0IKzRRpWcRGUJKyLVTYAwk1G/RoB0kVXrvNo4wJAr2xWd7R0RoHMkFAAQXvABlS6cMagauBQS4QHCRLDhC5loquYWyFgaqEPpnq1AiQgIBQnQMC0UZuExZhXLzABJAB3gAHJqpqxWcIDFC5gcoWBUQiAAvgpWrGikp2zh42IOmwSGY9bIQTEo4yTKJtIVkagBAA1wAAADlkjOnv/7cET6jxJxE8obmUFoTCJpQ3MpHQi4TSgOawBgxQjmKbykPRgMQBmwGma0eMAGUUgNLqXrKFHwUO1NHFAEzAMCRiSNaGzAFF2y4CAkbIU3oj1hx3/////////////q//6gIAC3AAAAN0Qs4aiD7HDpHQimLFyhLDAahGcAjLJOSAWJpBcCVgcJ14+7r7vzDVPaxkPctyHfK8EGf///////////3f7v1/9z/AMuC5OFS7PuYN8jVtN8RB4wzKKZhG34WUCohVYVgp8rSPGcGPvRGpfOS15Zbbt5ZyycsxUVBEAlizTp09/////////////7l9fsEN4tQ+eLxk83E2snEkZBqPgCERxEaJECbrhdsCLBxajihpZSMrqiIpI0Bgw2eJXiUmPIw0hYBK/////////////rv///+1BE/AERxhFLU5lIejhCOXpvCStGXEcxTeEjaNAIZrW8pD37aAADQzEjjgAAAAW8mbmIcww6XkQeLNMOTyLgvQpq8DbsQQ5OEKLU0VtIEjV6chAeVmLatd6gAAD4AAAAMeWBDlGpBpohS1MSRyETHEKlNxGtMdHAQqTkR2QMTOHNkRRWpHZv1pQfeua1chf///////////////9voACAk2NFjLwEPYkuQajoc45iVSCYhAXshMVjgBNxcwoAk2BMjlszVstlk5pa+HeqXmAI//uAROYBckQQytOZSOhIIjlac1gDCWxFKG7rAGEYCOUVzKQ8AH/ABnLNGwl4cgHRhsAnd6MkF6wuMUFjAA9CMmMTBiIWMDMy5IyLVT2bZ8hwUohsGQFYHZAu8trlVkTIt////////////vp7v/rZfvoQfAAAABgqrA0GgY08DzgGGQjKLVAJXlAAiEHQy1pddIdbaByHwLB6GZKUKrmiz7ZyiBbacAoAAK8AAAAGX5EZxLZkoFgIYg4iToEGjYnOGFBoFgUFEcIGZLDssAq4oTFRevqOBtd1hM9EoAgAACHYGpFGE1kAj+QlpyJBEcKCWQXtoUdkt4q5q6HWGw9iKck5G3YwKS1SfF9GLhP////////////////qAAQAAhjRNgiFAcsz9zCTMh8LiFt0Gy4xf0cdcRHAasKxXpa2MwMDUiKaBc5PSsrWUXIHEXf/////////////mP+2rRUBMAgucAAAAG2LHHYm8if/+2BE+YMRpBFO+09jGENCOVpvDCkGIEcvDmWBqTcJZOnMpHQKACSBRCG4AFlRdZoC6UH061zrtb9HkMKlioaEZ4lCC5WaQqLXNmwAAP4AAAANaBNm3PIpA2YmEyAuwKTHhhUoCMmOl2oonwm0gSRqZY/EUZkNDgWFR1gurZRFSVf//////////////2e52kAEHAAMYOUYTFw9chE8AKjXwEpOWViGbWxQCwZf5fTktiTAI2BAIiAwtgLQkGaMSDGDg8B/+AaEjnGKw8OmgARj0okETSU6ElK5YcvGDhgauwYumgnUzalDr9N3GkQebeZRrTKid0me1QcNGiJEjV//////////+2BE7oMxpBHLO5lgajYCKY1zDBsH0EMqjeGDYQ2IpRHMsDT//6d61/T3I1VEVQAQwFZwAAAAcKMD3JjmDKgeqxy9a9yRBsnCBUKUN4fhfDkJ0m1Ug3w/zqfsKqtA3mFLF0AAUAHOAAAAAKs36PjRSJgEpegTXNBAspMAiygGSF8EJQ47jAVrU0CIBSBkQOQI+TQAP/////////////9v9nqrABAsyVCTN4QP9gGdJlDYJEmXzQLMAJYAKgCINej3CxTOadGWeh7AjEo1iOULrlGLHf/////////////zH/QARUAZDPYEyY2Bwi+jDRajPggyElFdTVDNdygzCEhYdl7NYvH/+3BE6IORrhLL61lIaESCSUprCR0GYEUvzeGDaTQJ5Om8pHRJgBl+hLyUwQsqAQA/gAAAA40EDHxkCxFMqD0A6MJS0wMWmeTaSuLYIYl4UNXBUZjECMHxhcEQ8SRC8EWGiIz/////////////XUF15D9SWfIgAkgB7gAAAA6AE04oY7MQcWOIEUAJf9MtBcvcEC2FKHEeJ+GMjExTtBWiP8uek2H4ru////////////////9YACNmOIB+E84TLCKqq8Uax44t4CBS48EtzU1TgVlnHbBEe/MyqSqcTnLVpQ8Bz/////////////4pp/bFjfTe8AQ4MwNZNnACpGkbckcAaAvQxNFkzESYgVYFDu/xFA0OAdWRujmsgvElmBlNBaRAT/AAAAADOmRLgKKZQMYGLKEJTsOB//tgRPWDMZsRy+tYeChAohldYelHB8RHKQ5lIeC0B6WRvCQ9pU82Xq/ZO4Ko3/coVgQXgBpyCyNU1ESCMymyNVAAADMAaWDiiSpSEqgBUSEWGmIXIHQ8hMpO19nds5zAK9AIEBtAWABYAKh5fnHkTccpACiyFwokp8p0pEJdp9P26SlcMsPFAA5F0Quo22y+tYeS//////////////Y///1g6uxGKpAOUEMUvDikRR5pNcaEC4CJEyOQ4QQLEWUVvDxANIR+HYcfSFoBRFB38AAAAG+lAq2BSNyWSCAMsKiUzVpqwqUstbgnoBYGw/jieiOV1RKXLjBY1DygAUIQEljgAAAA//tgRPYDMjsRSdOYSNg/QhltaywNB/xDKQ1lgaCwh+b5nDAs2zw08BWVSACUhBoqBqARKlvE/NLlghodI4wHuVSIotlAiEmEA4MksFOmJ8IOS0Ty04S5EtkZUE+5d8s+2qsMRahXZJAACRWUjI3PYOOWl82wEkUzFYsxZw/4irDoK008FAp0JiNqzGHLNWtCwMDwQiMHwNz8AM/uemZ7A691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"

/***/ }),

/***/ "./src/games/seabattle/media/miss1.mp3":
/*!*********************************************!*\
  !*** ./src/games/seabattle/media/miss1.mp3 ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:audio/mpeg;base64,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crtqbq81ze/5/e7/X///////////vd7YeB3/scwUeuqmmEuTtApkVCSX4TGoRiw4hPGjaESIWIgwUZIyacEVCA1HLzA4ibSIabmCDRgwZi8QzRMioGhaewqOTZF7svBR10khzCCgcZGRi11pFAGYZtACpUF1ILTRnYGlOsLJWwTC9oBf4YLmNHoD2mFuSgS1poSlr2MhHAMRWKj4xRdL/OUwKHHGXG5EGP21161nOa48DyaKS+aa1NRd0YHh9ezQJtl7sQ3AeMrl8zF6R35h3I3ZeuHIjtsLKZXRUk3T368FzzjM3zkbXI7D9FA9HK4HhNR4HArRSAqClpqd4XTguxKZuXRetOTUiweeawrWLVJLLVjOBI/jKngpYNsT8RqS7CtTzUuo5mfzl8nyuzPafCmpvt42+//O/z///////////+rW7N8CRUVJ/0cb6WrEzDuRUYbRKYklQFFGJBGICW7sSSTIig08lVYzgIwramc8YDmSFmDbHEDqtnB6pf/70GSvAAlddtl+a0CBC/BbT81gElLJO2H9hgAJ2SZsf7BgAUOcWMsgy2+85RxuOx2YTXX6iGXC7EYBgu5RWqavGIZhiVv8n2pNliwqlX13Ql28Py/Byu0M1E83rdOUUrmwPcgr47el25dapq052/K4YuSy5lUw5nYu27sbtyyNXIlHqtys7uM1HrF2fZJLp+nlU5LocjliduyyltX3ezuRatZnK1BDliCJDOynczLb/7qc33+U/cLdyxlKJFcjVJhbnIzE4dr8iFDZi9JEa8Edf6iu5UU/jKbvMOfz///////////////rcudw/fdfV3z/////////++K9u+8riMh1MCJlFIlQwzCuW3HEBkUJY1ERmL0AYgldVecSaYA6bxLAE81OVwknZ6T4nU9A6EWFjCqOseHTKdM1WjB1j0+gVV23rWWxc01vk77ISONc7nV5m1WDpdaNpdfv7L987BvTDadj7LWmt67an2np6tL0Yymf0zM9n1tV3PrbWcrRdCQDSXLV0mBdu8Fvk1rVlRrNhUpXri4NTAE0SiRUTFAfLbEa1dbit76Q/jhhUq36W73+tWdtQWBweKXhAskLo6XzGl+3s5Xys8UzzkJMR2Siw8JHVVRashq3163/1j5X9X6zafz1z27fPX+M39e8zvu629tnf4Soivv9n+8s8pk47AZgHHaO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YxypTdtkh/YmH8Hhl3OYQxRIGBC6tvHXJoQEAZxvBxh51n39//uwZNeABHBZ0uMpHHJuTBpvPCPKUYzrSZWGAAnpsuq+sQAETK2NZXLSRsXUUzEvOfN0jEtlZVXX21ujUpDa9JBlurui739nXrV2QqdkX6kNVlM7LvmjMpTvZClaplKV91K1stOmjUkpaToqRTnKTUDq1u1dSJtqPSa/heWTjthyfZhDahMbES7x69IaoMAgPMQDQsDkxKFUIwYRMMEwuAC2yYucGMFxtBWYiCK7FQCA8PFl5AsJLWCEG8LvCQMdChx9QKU0SKig3HGGgAIGp4O4wKUx5HpVRlKRqVKWzYAwMhWomx1gLEYdpYCpnikzmPR1AeogHE06y/jFHClMZsY6Z/GHffxlbv2ghEy1tEhW7LBLCQ0+rXX5q0tTCURyeiTx14xImuN43WHlbWuvQtBPL/3/1qsZhmzHMaS1Xn7s1QP9TKdy52LLkwxGmnSBr0Snqta/VlUPS7cpe69HJa7VankdBRVKGVyiMSFeLgXqR/qR2IGkLInFa7Syql/eOW6tam7lldrU1jPesPtdz5rmv/////////8c+9zubz3hdf/SDR4RFjygPgBMAgEhUgFdcKhKFQKDVJqYmaES0jGBccBXmgdczpymqYOkmVwDRS1cpcFKFLAOSgtEpcqo1SLGxwmg0/pq1q5Fn+jLWWcNOf2NVZS/oIGHgRIJPQ4mIvw8CVWgGVRp2suymV1NZUiXSNyeLSGNp0b1ll/yq3ZoN2astl6VbSViVkJlNjS0ut1YjT7xn3VdmJP5B7TFuumw2VtheRk/4ZZU1rHWU40+Ixmfd+Do9t5uQhtXCf6mjD7Rx1XGdutDUu3ym+tDWPL/+7Bk/QAJjHnPbm9AAR4PWg/N4JAKRH8PPPQAADyBImeGAAQjI4XG33svbetyiIzsbicdZU4kN4yKAaF9l2v487KFboIabWrU1arZuSmlxiMVuY4092UUkWlUrkFDFKaUT//////////87euW+T9mnk0xjPS3/t2Bq2qYZgABuNITYXJRXP0W0XFaL6XFUtyHTqVDRGBSABAVWGZtmuVgoWpm5qBYWNKFjtdhaov+GOAQdlg4DT4NDA7//wah2s7/Wd//9Z3leVOiXKkAEAQAARgIV+Cv/UDUSnZMQU1FMy45OS41qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg=="

/***/ }),

/***/ "./src/games/seabattle/media/miss2.mp3":
/*!*********************************************!*\
  !*** ./src/games/seabattle/media/miss2.mp3 ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:audio/mpeg;base64,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"

/***/ }),

/***/ "./src/games/seabattle/media/miss3.mp3":
/*!*********************************************!*\
  !*** ./src/games/seabattle/media/miss3.mp3 ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:audio/mpeg;base64,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Wg6uZqw4WT3t8x1vZhRrO69L3rHnbRQM3oXkzzJgStPUFysV4SxeOJtPMLTNFTN87n4sr1WZ6adnx0ta9/pNpmC3zV9r//T25TXbCCV+G6cyEwDGWAchPZ0JT9qVRlUiXi1bvLvfWZSGQ91yao//+6Bk8IAFqWjP+yl88FjIaf9hIioViaNB9YYAAViiqHqwIATI6sP1Y5iuaj0MdGEI5QkhFg73/0WlVZ2X/6VhGUxXZLOksSrjh1A1Oxfrs9jP+qp5RoJGJzQkERCayIEBAsNgKmhguBxByCz4AEQZAWBAiQ5olABAQEi0Dh5jwRaFnSXxkGZ5roKqS8ytZqAiKtkmAXNbZwZVH3IZsj42du6wzI5A1nK64KCJoy62pQYt9yUTo+Sg3SvrKajT46/0OMhjDV3eblJXjmOymW/Mw7d5RwJKH7fakuWXLbjH4hcuS6AcojDtzGYd6bkNiJ1V3RVn7ytvdjVmX8iU9EqOU6prULhitjVYN9ynuXH5oZ6gZWoxLb8ojshrWscqtzW9bxppTaxoozqGbcTpIvQWLVDXjUgmYFpX2gSL1LOc3QY7s6/VNjNU35fVs1uVvz/8N7/9//////////2Nf//+8dYfl//////////W1lgoDURMHFhCFBAxg73zqEISIgDKF0A5sFypytYaOwlutdxoBhpJTkw12OMbyMrVKnaRp1KqsF9N04a3tpU6bGYu1WJDqzWzDDBXwjIQ0MRujKasCA4wl1dhfF2Q1VqpcJ7CuhwZsZv8X3WkOBR3h9bfhbrmvt94+MPtzX3uSn+MbrnVtZ+P//+9pv7lfX///////tqFhwLHnCkjuoP/+6Bk2wAI4YLN/msAEKCKOe/MvBIAAAH+HAAAIAAAP8OAAATf//+dixZFTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU="

/***/ }),

/***/ "./src/games/seabattle/media/miss4.mp3":
/*!*********************************************!*\
  !*** ./src/games/seabattle/media/miss4.mp3 ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:audio/mpeg;base64,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"

/***/ }),

/***/ "./src/games/seabattle/media/miss5.mp3":
/*!*********************************************!*\
  !*** ./src/games/seabattle/media/miss5.mp3 ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:audio/mpeg;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAABQAACfxAAEBwoRFRUYHSQqKi4xNDY2Ojw/QkJFSEtOTlFUV1tbXWBjZmZpbG9ycnV4e35+gYOHioqOkZSXl5mdn6KipKerrq6xtLe6urzAwsXFx8rN0dHT19nc3N/i5ejo6+7x9PT4/P8AAABQTEFNRTMuMTAwBLkAAAAAAAAAADUgJALPTQAB4AAAn8QnS1B/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//vAZAAAAQwAyegAAAAygBmdBAAABZgDL+AAAAHpoOY5hg1xAAAAAtsbQSf/+Xf3FFP/pEFzVvW/8pzn/6w///5T/+7cm6ypxQOApFSMQHAiaOBjJYRfOZcuQix/8EDmULvyes/nwQOMKHNHlHZRa3/o8hxjv/wQAACAhlRIiSSCut0cIFsY7a8CKa3Z/ayL//ukl61+v1K//bTudc1yYOa6GIem6uqhVVRGYF11DJC7IOuYgQyRBHDJ2tTiaYYL6Paoe1ZPHU2JioQ069/LezPZ19jcecz7pAAcMIJLg1hHHjqQ4dBzEkzjQABlKz63OxLgvtZYds3ftKn0uHe50jGUxoFDTiPcPF+739aqqiX7kkjYYhPAdC9s37HmYa4qAIgGZ1ZY2ySCtAhvsDrHDgsueZYfKWwmpI1Jlxsi3kvjqkPZVSWizIozxX9Qe+rj5pdDNmjW2tdX+n1VM1MQqInwy2gLWDFCK8R4Q4owqvQQ3xEBlCljsMsb6jd4GAoyTip4mPPmyMqtDqcqXJ3MsRbkj2b25ZqOa7nFiqUX1pYvKKFMlBorFQii0NRVCBENxrHmYNCU1+KSU5kceeOTWH8Kc+c22tmhUXNnVeNUVJXP+59sfo+i7H/hEOEO7oyVspAFijG0HQnfUpky9SE+eYmn+mMTRqNRVYxn/+/7f7nu9LLFJQ+wqQDyjtylzdVV26KiShRDUNQ2mgDSnEA4JIU5hVtLAy+oOoqJG1/G5vg8humF8UYwJpeKx4Frih6C8a9O+Uz1UubuyV7PIruIW0TwJ2HyWfJWzmF5vu7UcTDO+5d7wu4sKMJDBXbFCRAMnE7dcBUyOZmRGTHuTsjWZZak98ywyx4zhgCqAxTMFWdX9AYQaOFFi4iFpVIei8uKpi3/9dVwAACHZEraQILG/KColfRc8iZIsHG3pYlDqlWMyzUlT3y/euDiVIf4zmPKdpVG/6j6FgY8mID/+5Bk3YAB2wBL+AAAAH6J+Z5hI3pGaAEx4AAAAlwqZf2GDfhz4UHJDl5Gqu6p4VC+ti2SrBF9Ad9PUFgGEmcqEwdAnaX0UoTNgxeLsOnDz/QQ+ztSmHqo2hUiJUSrRsiZG4kZPlLdRQmRyUFk+nTEZKHJRyFOZRlgVXUxG0TDLrZ8mKzzlutbt5lomXPQxWEr4TxRepTRTY35ZGIlTO3LMjIsyxxmEILeKkpVm7cpw1b1hkgiPA+Mqufgh57/DOwDgAKyoXKqMHMS3RvaGLLYGpf63du3PO2sJFGRT2XKxj293FPRoe3pmtL6CgZC7lEYrSKjCcj/+rKuKmWdD+ZH0WQX4DPLXgwhdLBqkGrtdJOZJeAnCkzktIBFADBMJo3j8qSUi01H4jLlbyY8+Qa5IRKy0oZwcaibSu85wkfXtzqh2tydUYirdtOOpq7tKp3KmtPpznT9csu67u6lt9xDtJkP5axzmMa18T7u5ZcrVLGpN3Sj5y5tTfU3L4ch5jo82RysLv25XVPxt2pll1o1cjhFklYtGYzHYk25NoyEDYT/+6Bk2YAB5gFL+EAAAJTrWX5hI55HFAMt1HAAAkYsZjqwsAE/usG1PSb8bfTcODAHSUwUIDTE01XhjAezt0GmKSY0hdgJMG57X0U0EoDUClToo4rRJNTPZJFkj6yCGZByKIst2QUgkiko8Qcumoy4uci5aQMFprUgtJF0FpmhopSaYuQcxAZgmCwOeM2TaTGroLRY0VMWRQY6xxI2PFkfxpiyyLkXH2KTHGOAmzput6DmKnTayRss4szWgpVJI+kbpilyeLwzYy5uLkEFBOhXO3V/////+rW///PB8AsgZgZcgZbIOQceyLl9TvDw0RLm5oZk6dLJiRBJSKe4oXNYIMwTGAiDYcsBApKo4REwweWmBFgEeMDBCoCbptpoJQY0JqMJPCABpqYcJlpahSLqpUK2KzrDNMXSqdoeSmjxp6JYqUiH7ow3pl7iphLCIGvzgAgDRV9JXJprsjq1M5dA7RGauc5Tc1KmpTT+RqItPaLqDIXKX2vLKY2owy1m4XEvZw3fvsPlbovLTw9LHilcqgBx5RZj83EH/n4rPzr+SyI7j0svYVYIgqPYTteLZyud7FopIoxLqeVRiJU03NRGliFyWvfF5qzPxq9VqWITTxuzWtSvOdp4hAcZh+gpKX+XJZhcwnqlNSy7Hksv58qfZvV+5ZYa3Wyy/na3/waDRQMIAH+IHhYWDBP/++Bk/oAG84jPfmZAoR6tqS/NYAAn7iMv+a0AA70wpn81kACIqam7iZaJaFayROotplIAIpmzbBRiFiB8SRmUBlUo4KMkFHFZwRpeIi3ga8X5NcCDmQGbmjIA2mXZlypS5StpgCIc1MIZFhRmAYkILQpchgVFYwggaZqcJ/zDE5pxFHFup7xtOJniNjxw5bRRpGkr0XpFXXcBy1IN85EOQ1PPHLY46LzP/DMaZxATh0DS4MftR5o7xvDF4vDzt1r9934nSSmapqGNvc2N9YCiEkpmW1qS89jtyBxpqXxhvafF2Y5YwUpcp4n6pZiFz7c5RHZfT1p/UkxtzUenZmMy+pem7UPW5y3nD9+rF7tSRTcCv7GKGUUtSUXbEzXpeU+sa+dinyuZdmcLX40cuv0E5Nzct7Z1avzkoprt//////////+o8EQl8op5fhvU/cpv/////////6OO241aoMKDm6nbLxOXWXtvExEM9lt0laZRITll50x0TzKJDElwCEFCxb0wogrCGCRG9CkWsx5AmSGwUHDDnJ6bIgIBbogTHhGhGeWzlFNAIIBQAW0hpYsivhZhhG1GRpmqHNbV2CQVjO7ZY+zBRV0amMSf1/Jt7lYH7bZ7njdm5DqXzBJFfbLCoNWnC1nZvXPOA02mlNJOQG4+piNXoo5E84FXk3I4hWkMkpIhjan6X8LFztFlQz1PKYjc3dnIbzp8N7z5Z5ny39F/MeZ6wv/jbvWPxx7hzPWVbvM+71rmP61/5c/+/3/7///NVQYaFhQILr7/4p939t9azKvLmXdbXI0kTJ4BMEZjmAQQQ6ongwiGggUX4Aw12N2W9AKupMCOeOgQlIEJIN7MC4mrmSaSMGB8xNJH8sUo4862n20tacJZUarrOokIue9dQvmDFBNbOKrTq0vK0PZd22alSoh5zY90y61HbKc1i0shI4u7XhzTZrp2s21DeGdJy6tWKpnrRDbpqzK+P+G3zMPZcRDvnPubstvo2cB4+TOvWl6iOL0tVlTeRCwZMsopg4ZrjX0QWmgYYqI71NJgdQv24yjjBVhZAzh3A2AcEg4arNMlFSg0SUfFNdENWQPHz8UxX+oj5fPVI3EOUY6oXUiV3TUtfLJXaNUKvUCYXFUiYLhA2g48gXECzt5dkywfYLA0Khmd2dvS/VN3tTMwz1yNIlEpk8jQBHsMYtM2gdl/EvmiPqibZZimCvx1HvgNv6s7fpYbk8jis5ETDQohBB3usNxM3UE5Bzz7iUDBi6ZCkrugPJdpR+FO6ZE7IjOcMFhEgR2J85beRfhwhziVzPsIqSFX38olsTKflyF7Uqps57tLewjNjbXP6ebai9yQ+gs9ZClzyapViXj6m7qpiFP7hXEjs0mENgrcLDEQXIb/+7Bk4IAFRWjO/2FgAHLFia7sLAASJaE97Bh1AegSZvmEmhmWVQjTQ4b3r4dlpDWFVIs6D3O2oFzgQQGyUkaOvZQo05izJqYgnGGP2wNCJeIQToKHEDCCvLZjAlzNu7103JufyyOrWq4G0vu4sm/u0yjnEZTRvd/+++p/8kLGuQWg9+1W6Pv/6rq73rybdIlkaIJF0jETSaMGxgMoZJAMYKMtUvmjwsViLOlNl2uiEAPoJGbJZ8nLBmWTUzWLd2N67Li44TNYoZOWnF8SxRS7zpdOENh84ZXWs5pcECKXB6tlv73oFlPvLtKHeHrG29Zzmz0QfYQz7rayeedzWaGynbIyni9fWxi29sxUe6btjQT/iNlO0P8b6+4f/92Mxohoxn0D+xGmrB+sFPCI9/5hf715cujSRokFkolinlJrYhUsZLwDiVeXJacWAtMg59GaKfZcflYkB1/9Yg1LsdAOUEDh8c9IlylWWd0XKI2TalyfJVN0UCSI1CJbGHVlHFhGza+1jT6Gin/76u+npZFkV+hM3nVUQztYkkiSbQCNwJCDZhcwwYAGTeVGSiHrF+wIBrKjzwwWwYxXE7TfRZJmmOawnpKygSrETFmP1T+GzuKXP2s7C8cLYpl+93CiWvmHInHFjc3jBFz4qnZLwHjhBlxAXURsgsm3jbHYIEWBE3MsRu91CZ792rKPG9vR6sccrd4jbHj1jSyWapnuX9IbueHR+3Otu2WPNXE2GBscI8BsWIlm2kHeNyxq4fXeeDOrJX7ZBralM73u+vTNd5tj7xHrit6RGwxxp+G6PZVcxddx/XrNyJl1WJogAKe6s9nABP/7oGT0AAUvaU97DDPiYsQp72GGdBoNoz/1h4AJZw3nvrCQAOioVLJir7ByIq0RtmStAeNkkMAqIgQFO9lgupEqbR2bUPFG6+13fGW7S84ImENKHlAQWcQlCbXrGXuZijK0tU7Snfbtyv9321Xurty5qtemWGVnRc9SyUQiASzJtjoZDtMwVZMAONZIMkcABI0AU2JcBVAhEZkIChjsg5aIzpz3IOKlAQhEQAqS0GSChwSUY6WuLomUAEFJwOOBpE4GGuQhA3q5FBxYBoHpmoasQadG2HMFdpkrZWgAIdd5b9QN9Hdl6n3ZY9B67IpGndjn09qTKb14k/Vt+HQkLSGDNKqx5yXFi+DDGIQIw+HmsNYc6Gnzvx5zpfLJ2Vx6Yl7VJfJZe5b/vfOMMeSYhiHHhgKGWvRNucbjOn1oqKHnpaQ8j/Rmep5dNwVArX20zh9fj1uvFIYiU3GYjZn6OVR2xR1cqbCNwCxOJOpH88IRYoLfNcfVHtZ7EGJKkdyVP5SS+N25Brc/9vK7l3/1hl//////////SVLtvly7vH8vy//////////+3mGv6k7JZ4ZlaCgxgzgmBAACAQDF4ZmHYCzsvbtbk7kdYPGok+Fh0Hhu1yZHQBEBb7gYQGNgKKZjiM0KBGhZoUQLGzMulw8geZEvF9MtkVUovIIqSRaFqTcPcGYKpbZluf/70GTNgAn0g9P+aySCkckqX81IkCYxmVH5vQABxBkp/zUiAKoU63UyaCK2RNJshXr+b0FpOmkowWpFM6m6fQUyl0zGlQWvW7rsipZ18pGshU61HBYa8I9bv38q6rMdoVYZK5WkiWCiozJK8x1ZMjJTDAk2NKMvaAUlGOghi4oXREQUYEDFgfCh6BgUwMcMiQjYhE1mo59JFkuONEjOCjdwDJ1R6ircpklKhSNCkkBJKghMUCV2WoLytZYs2ytq5kkHMbdLV4mlR1pDG2Qytdiq8PuGshQt2lluCzlpLLHSaa0+MvxKWrRlsCIyVtxYeB22mW0oG/eRrT6QxF5ayeBlhHMbxOd1oJdGmlsC0sYoGXS1uDCngQAs3beYj6sdRnaECJ8aeZwH3jbrKrQI/N53IrIYi/M1DcBS7KJWrlBEpCsLYpFpMFfN/GDwiWzTmPuu1iMZ2/0zDt3PeXMnehpsdJIZTDr/wLVl/btvOEtPn428dDIoVG4AzpsaKXguLij//OnF//DwYCI7quJhZ2VoAYEMJBEEgkRi04C00rZt5I06NPGovTZz9t8X7noaSFHg4DKCbj6xlg1agiy9AwSSNjh5FAzTZaSCl5ytkWbUg7Ov7Ibbsja6zbb0u+Yh4EVEN2saWmQwlQuZNCx0ThFz2i3Srw09rW1qFb7Z2ak2YVMDc0ZThUKAwKC45MKDNwOMJBhLEEIswaRBCBDD5DJgOAACwEhIRhUEmJQUYBAwkCzAQHAQ9NpkJKqomtDAkC8ppin2GaQ5MBBGBGtXq8m4BxASBXDXnDcQSOxIv8pspeGbQFuQXYqNEUClbDV9sUGiDFhkKXkDouKuf9brKZE/Uy0S4z9ay8mDPugHUydl3XtYwyovLAlFLoTLGsbeaBH9hiRsqXqwoRARSMIiI6KL1tWZDjFnhpIf+jlfWT4v27bC6akguMtgbaBHKRSadHodc166ORP1PyKXSOWyrlavKI1lK39poEiz/4Q00qHWaxiCmnMNgTDt38tTUUfy+7c/Yj8UiUirc7nncgmZwiDpRuTS6UTUpzlEvlEcjWNq0HQkO/1s//OUcz26uZEZGIoJwomAsspNyHVAa4PKlJK0GEP/++Bko4AJaWlUfnMEAGwF2k/MmAAzxiM/+c0ABDzDZbMy8AHn1lkT1G43hh3lZNdz4Khpb4QUynmXhKLPLl8Zu8oPjXmt/P3dfk1sNTF5/n/ePP/WOYDJRG82DaYXTEkPBQXaTmTwGahrx6nJzr9AOvNSmYl0bc7tLKGbEaKiSVxyx2yX7HfCiNQoymXTXNaPelA0ITyVpmW9GaScp4vtmSYEc8oRg48CAwGcBEY2QyIhkUpC0Q6Lw7KELrT2oTMGhZUxQQkQElIrRkwoBfkJgxqxI0QulhwEQHCiKYcMNccNGCEjJjy5VBiSQSOOAqQCljKg0BAFCmcFtbS9AQ2TGVWq/CDSPRMWLLJjMYEAhwxI6XvLAEiDmTDQw3kAPejSUAy1sEgY6h0FkQcQToGiKN4GADgUAAI4YwUms0sHIlAA4SvFQEwIMs6NHIaR+pYDCgIDBFSI6r2V2XWAgILAH2CECMqCFu4OVOGyMLkRwGlcLCUA7ThgO0pIZNJ/WevcvZgzM6RtSgWmquhDpCguAW9OM5YJPF3QUCLfocXeSvGRAkLZKKhmhq4WYTBEcQcFX28xeAsuQgWBKDF11dAgMXIVnJgSP68XOVM5DOV4o5p1FBtGIoLItugwJo8VTqWIkSkEqK3D9Hj9nlrLWeWX/////////9V/MMbE7csb7bwx//////////m5PhV7OZX7P6ynrvrUlHUUYbHqLq+l0BJBlohoJjRElLWxASLLpFmMAaSMCMwlK7VHXIISmRb1AXovJlky2SKVouuzZVrUvjjldDeJ2zlYsog5x/p07zzqexfHg+E2XFIyuTgYySW12ihxpUwFOXN4kkCX1EINHFGiDRL6ok9ESJLFakk66L0lC8QYyUhrgl2lyhRIE8ZKNRbmjQ4zWUR3GyhqcH2l3hZKlZL0p0MZ0SxM57HEtlkxrh0/J80qU9D0ZiwKJdMqdUBnmkMs91cQRQIa2MqdVSddsDHAkRniOHhUZ43UkRnezt9FqXdNrEei7bcXxDYJH+b/Xpjfr83////////9MWrv69vTf///////8tr4hfz75VWZSFFTMmAKIEKYvJ8qlYvo8seLUiSwCRleRmzoGNxjz+hLMLKzNBIzEpMFATHWwxMFR2EJiZKGhpZcEAiN0NIRqCaL8JkGoOChzeDLbnIJXTHW26sIYKkhNN2YYmyFgC9BQAzVTQSGZsn23BubMmpo+Pa9yP7xQ01l6nCWPFXdgeNsslzBWOLMl9Gj49r2PLSxKGoBkkrkjysznXcgqH0FH4zZwsRpjQXMh2C35yiMnf7OxavPPC4tXqpFrHfuKPo/C72dwPBb+zleMYwBapq0ovyuV4PvLfnY3PzsUlcvYg7liUNYdRl8Xn3HjEKgmmj/++BkeAAJ5oZV/m8kAmYlam/MoAAoqhVl+ayACTwOavcCMACcvufQVI5TQfILEP1nL3SxOmicv5UmJrKUO5elbtvOwSct3KS92r29a/62H61zfP/////////991////////////////+djedvP7weIdQ9CgyUxNwICzTU6LZcdjeCDbEt/SrjFnzv67eoec7wgdkxabgUIrTWu8TX0iOcXKtovMXCOvdcwt9uRyY6iMK2QEWDfvBESVGQcQKoCZotMpQlmptI15u0gxk0TAkXStUWHfS/0GoKaIZSiEBkAJtlxJlQmpmCIGhkDpRMEYKGoJKxmDioMiA+BkpmjJkj5vhJsThpRSoDLBT+dMR08SwEQsKhKIhTCTMFQuYyVn4JFQ0C55hDIBUsy4LupnwEwxPlYNzYgrCDSUXFNFY2CF9XfolbFMlcrqXSyYqAvqz58nDTlavNRp76sKlMYZzah1lKxZxQVY7CHEf9gcviEhbMxFu7NGlQmbqQ07Dbt2Zgr2H2HuJWfyowaTRuGWmSmkgdk0FrogCF220+7AjaM7Y5Vl8vhUTlsPWKKeiUbkNFKLkxD775xuHLV6YiUdlNtlqqT0xFrkNuQ8bUJpozqv1QJqwC4Tf0tLVhm9T39z1mcmYMdKGIdisSdiQU0PS6UR9/Ifwt49/LHeWWuf//////////X7hrljWrHP///////////62XML11acgiEqk5mm00VlGiW3XNbEOSBhGGiKEj5S6SE72+d3yKlC8vKeCCg8TrUcIwTDD0Vq1LsGT9p5biNx5gsNj9pFXciiOQeSOIQ1xsKUHBdgZ2qsRdGWACJCwx0C4ACgMFbFEBwhCFlzzqKER2IspeRubrDWHwzB5etKpBUQxFgt3LhwmEt8SHEE1Sxna1Od5j1rszqdrNX2pE/tL/Wc1Q41L1qf6GvTVWROZbGFLFW9+/1/OrB/Pyh0g/KMP7S+/uUmmze/dMze/9eff2H7QdTJn73vlO6k1p3TGscczffvfIpmnbO/1a5n5T57sn/1hADJrHXiqczS3Cf2ki21JWODpRKzgadXe9rlK3/b3sjW3U7XZdKPq7emhj/NdGxNn5x2Mr/8j3ZKgAAQAI4vBqhIQOWPxFUwocOj4LcXUZwAgRK8wkaCxFm6Y7MmEsxTuKpwCBNt8liENKEnYWBaL6XZGEnYDMLAc5wKV0Xk10esvJTYNldp1kTDpBGrCEUypRD2aJV0jRKWwPlCGJZcyqhWiydWGHwmg5e14IYG4FmiyIwImERRMkOPems61S8W3NwWUhBSCOTKkG0B66ZRYWX82VIvRNq4kquoLqtRQxIhKITzIZkyVFBGPLOICU0hiRkrjkJIzqjOpSW09SAsSroA8wOBKkS/8XEpv/+6Bk1AAFMGhbX2GAAC0gGqrggAAabaNrjD0yyLmAarAQAARMxhJIiyL2uMILGFjzosLKahd7Nra2q9VNu6x0KNu9MuZ+v15nr/iR6tv+v9GJSwgAAAASXBkGzUKsQ5mcgRQMkoSOJS/LjtiVOvmbglbL1oGNefyKui0B3luyCStPgvCNM8m464wauOi5kCVjblGyRZILoUVgK2REkUViOKWDvKJVidIWdRvo/1/pdwUQqTDpqy3ONv7tcworHMim7VmS7zKSUq0u05xjtqK+zUqs47pN3Y047WN3/uMo07UNMxLXw2TUTqWzGyR1VadrVjue7bD7jZZg5RJSScPFiwZWE7Vh4cSVuUPAy/Reg9bVo61LrpTqTdKfR6n9Fz9fV/TobLAADzjEVYR8KHIRIUmSAB3BUCBjJ3+VEsCw5aDdYu1yJISFLl7MlTDYRLH3TMZitJm6okm3dc94oEafZZnPO3I7FzyRUuvUGCTGE9whcjXFxjHcPim7pac06VP81TV7sT8vozAwWw3Q1LuuJjRKzyTUyzVjzT7aj5gXhfD56l6QPyL3kRbga8JiJHZWUgV04IFlM97LOhEzkwnW28bsZhSq+L9Ref7ef17P3ex5OcDkpEe/Ljj+KroEKRtNgSaFDkKYPkRBWlF+R9O9/9FXovFdyur9vZ/VOs/YparVOEgAAGDLAwD/+6Bk3IIFOGJaYwk1kiwACooAAAAXFaNjDDDZCI4AKmwAAAR5aBBgkBboYI/aNQBMmcODApGarpAJiBkIHEYSmJ+vn+c4kieTg5yfDsdthKEPGQ1O0arF2smYZcWGoUGzKVXNSlipRsji8LmHikLjjMU17CggF1EBhGw03jUMYE5k0+COUOUtC2TytdaLCLo8VycsnFaULRoVm2XkE/A+uYbI0LGxWiw1MsxCeoEL/h5pE9JC0o0pBAJIkaA+2XVWRxanFdpNbILHlm7rXnUo5Gm880EkYKr5nQToVNP7cM3UqoqK035Bkta8WcKjDbzbF7uMfH6L0UBMXVb93yivfqY6yjq6W92f+/09Lls9NO7oymIBIqrKnL7I2FhDCwP41SODTWsvyXnbVOUGhQ6Qa19KwOkCwwJpozAkIm2WgbM2ILJYsnhCTrtIJa1aNedKKq2TxXSkh1tDFBFEgwiFLUWmVBqLBY4tq7GHJcWHJBA5oOcMJFo+cfJZVFRFYyAS4RQUQdqZgwvKo8IkY8nMtStu5lni9hyj3zu4TPM2WBGkws6kokVEktktJuDgMlx8XE70WPppsUtIWZt855MUClF3v9dXv3Tdzzr/9fr+tPb3VRv22RhkACFlCUWKmUryj2RVI6UoO/ReV1y+b/r+PhpEkgAfPhUaFoUng8mqEuSExSySmnUgllL/+5Bk94AGNWfaWw9LYi3AGokEAAASrZd1zCRvgLyAKnQAAACCBexRpupKTPUaXZh9nFBUXdgy/immreGc1HLnow6DcafFYljteFrdsyrxovx6py8mDe7ws7vllvlXMY4MhtnO9I4RyTkpRnH37r/Gh8JH5Oc3GrDMasv7Ld2mY2M6PeOJfOualRgTICQKSTTcCVaNLBVNajUgN6oqtK2CwrkWpHbxi0bUh9EVTbRv/Iob3rdTMrb8921qb3U/jNVGiKiGgAgyjCpp5tG0kWnBnQMTURXCvwxC0JRVGW4wxDWCpWmq1lrd2BFgZEUDCSBIuGgTQsSEpx6bSbS+jmsa+yLVZdDZ9OoGTVs3dos+q61cGZsMops4xIl6cfrMloCUxJQGk1itVFDiVlN7y5a5qk3+QiqIynb6nsucOXFrFhm7Cqg6yj0FpDcQtgEYqzHiYyf+uVQEq8jlUq21wqOIMLGKNTgyptVhdFImYnTRf9Pu6xWa17K9Gjim78v/Ttsi6qWpIgAAK8zWCGRDZMMCMLiihDHkP05S/IoCimXlfiL/+5Bk2YAE2Wfb2wwzYDbAGo0EAAAStYdxzKRxyK+AKzAAAATsnaASwbnx68PHHI7B6gGR2ShOTjWIgiwk511HSS8pUPq2WkZyWVzxiEOICySXl0jDtZLTjubBj6Yh6A8BlSxI0gX0ammjX+u7EAiNt3zV5Z2sHRjIO00tG2LMbaTw4uTnqIr45YXkFxlR0buYjJ1A1dZFXKdY/anSxHTPkNpfKB7+92sdvntwKyTVtpIxp0mD1C6BeOdHrS6pZVLvj3dPV9CxDpieLLfytWyn+vqert69ad6ejz9cKbMyEQgCwLmW0dMBopGiAkUHHNQJiEAZENxDFpj+JlOA3Gw+1ueac9UNtLmJHQwFUzBwgwdKSpYKIy5okKmhqUGP4g0JRNxp5DW3rIqzA4TzSzGzDlm/frmlxlVDGSuGXl1y0djntGSORpClKP82szIg2TdUa2KelI2+KxeoInolBkAiBiGDogwYBECXY3c6EYKx8GFr+JhlqJlkkkAwOiNLCY1whaxab6wEtlHvYxjhZf0mEs6+Kyu7T6/f/k3i1uK8IJb/+6BkzgAFM2Za2ywz0jBAGu0EAAES6ZdvzJh1iNKAKrQAAAQ9z6Xu1X6qiLZRAAAgCNngYcIyTBKJRgsQAQjDEEQCZAsFEKpex0kvo+VwVSm4qCpQRRMDsiHpNROF09Ko7FhW8tgbiOdBnCE5JkbjCVEaxI9i9ZmK0CZN7E0JY5cGSydolFokRqDcCXYMFHQlKJGusPWJH7PJyxSVpS0sXjoG6z2UnyRI1N92TaZs33vmprvDbn46Lp4k1FK78oVmZC2SC5y3iba1f9JU3amUWm6MIjiI4i6aF90wVbhAF21+B291X2gNo4RPf/61bv2I9H/tRYStHbAAVRm7jC5KSadB0VjoqTpbwqlKxgQF1AqAs5mLoQ4wF3XHYU1BaxMElQ40TTRep9l8qCrVhyQMkGRTGmT4xVl1ISRJdv4nForl1KVYk7zZ6am2bsDNGlx6wwhlhumPsmTlXlMSjKQm76rbsPczxVdO16pe26WHmF3Mvs0GsRmeosDIdW4FayWplYRRzkUKpaT4z4EMY1GnHaZpxcms6JWoZIEZnVO1Cb823+TD29IvDTnj3Fhah1qiQXE2lcqNkFj2jFqWKnZm9ErARTe3ba3qb3O6tza//o7+/poH+ii0bYiQAAAAgDhb+IOavcweWAFBp0Aw6+1dBwWEMhghYZpbOC8RgpMEReQSIfjq6dtnxtr/+5Bk74IFBWHY2ywzwixACooAAAAXFZdYrLDXQKCAKnAAAARGDwsiI2lLBUGMBTOEGTww2Z6WkAo8aYLXhQW3wxn67qEfqa5StJJOHNY1hRJ73ZctbU3aU1FMPeWmtM034/yfvL28657vGIU8uZdPrW3Lg+8tq7Xh1o1ZYQSPM5VFtRJIymp+rsn3rVTPRpCQbtm1ksbbma5jRcCsTtYffV45L9auiYpnf01K2pP7bF90h9Wz9VtHb4/XFQAZpIMLXQAFD0wexlwIDAwPEXKTwXG2RYyWTFmEv2qeXwC/yei/4WpLxHPYIDLSeWABhOBkM1J3RbPj04Xyy+8dVhNHMcgBFmg1paij5IFmEk3dbZzovulC0DuejYgepBrnPz65v09MnZaDu0lN2jT2Ytpi5WGqWayLYZJ60DPRUSkfCYllIV4rTyG/90G2Pc0e7GM938fW+Z/3xzl3b2RG3c362003WkXOHGZsX2TullBDrVdrb+nG65rkvL7fojHj/1e3v6Lv29LAAAAridANUA0CrgNECULTgY6ANEclQnMDAxj/+5Bk1wQE52lXYwwzwCsACt0AAAEUEaNZDDDSyKoAazQAAARLharVWIF3HdixIBlkEUJcROA8nYZC8hGE0Rs/FWTwkBPisqrFIwG+XNVPYScZNOZ+mmqi6ItVrpCEwwSdjOI1J2eK+dKVvfzrO1zpwcPoGygwaAQqG2HHlhUuB+DpCgKCUmIxouFLVN8fmi11kYrXD7JxAVFaxA6Zlq9vSlKrpICRG/FHqLtJEAwgbyKySUITRpTXujp9zlSTO0aRqum2i8EqlCoJWvUZzSxGirHjlq8r/6ndEgpJt0ttopRKGBJNjmOUihFeiLMdtrvYibO1DbXUJF3N15Dc1zNafX7k/9NkbR6syyigAAKBGUpBgqNI2AiqJYUYWlTGLOkjFDF5OomYt1mj5wCyta0NCCThzJZ+OIzOUZuJZoibjLMMZgqKhIP7OF+N5P7jh/OLbGWyk+nGC9a1U/rSk2YgW1q39Usy9t/1eJCIRzpVXaO5HwnLbbzgxJB02my3Ks9i2QwpJyZN4pvtevOUazvttHq6NLhnuCBAs7D6hSDnHlD/+6BkzAAGgWjVKw9MYi9gGq0EAAEVaZdhjDDRyLMAazQAAASCE6czGNH239l8CwCBknOZ8/ohIQl2WyVtpOio1ThlDmE80souk7cu5LlaqLwq+hlq5KP/dV/+vs2rR/+lj/66qBTBAASgCI9CySy4VUbNhLirlBseUrwWrDLABIkCs6QIgwjNadhS61UHdfVrK7muYRyRr05dfKC4YdWUMPf16J+EVqasqqzKNtmlWV55gQH7TImbFwbi1IhonMm2nEaapEqSEA/2VsaciTMTNQoo0SxD5ShTJ7dbGufRxelSrXN3ynezp1Uxkyru0tewaCAcElE6m35vmHfPZ5U03FGp2xFI+SDCEf4anW1bL1r68N5YoUUkARXTTUmA6U5G40wk2A41r3IqGkRU69Sj7kUIUvmNe+nRJV3rYKAVft//1NSsIiiejt1/6EgoQAAVVzIWQSkBBGkhUqOYtBr6MCijQwiqBqsKrEtjocz4RquONQLke6xENU72Iqk26XMSz5VI9E3TyiWlcxJ9U3VVVe0VbFanIUBcup4MzrwPSqnEKwNHdBEHEcCQ4ABESiHTT1xyiAVartbmkTZLJFMhbQ9YrZXDk0uVkrmH2CrgiaYCFtBmlE7fUU1RV0Uzb5qyoNwjl3w5AlLNV8+51NlYye5saxqHBa7Z3HXDqmiS241gIFmqKuGGVV7/+6Bk0wEFw2hY4wk2sC+gCr0AAAEVvaNgjDzPgKOAKegAAAAstBco9O3G6/p6/0+SqYz/93/9iejo7JiihbJJAAIgEOuBSEzxAMCgFsl3wUUGHDjqHF3S6yp2eMipoELRXJxTFgViIdiCbj2+vWjcIxWfLFcJcPauPRkx1x5w8otYP000qybeY2FIIJG5RZhIqkutqO6kpcPGJp1GsQPXMqSyCq766s2Wzr5bmM0qd4/7fYW+Mbj8xbNWa9vbdPZrP2wuGkix8nHMbcazX/LxlNPr5rlopEEwnYsSVagiiWlBrnDXjHsljpoa3bQPJWI6Ksp1/7cuNrT993//63/rTsVEiUCAADESSQQVEBxmixbwAlGCMuIzjqAhCJTFXwZA90DOk+DzQOmqppDawL6rngB2mvnw5mBiXUwzIokkJDK7xmqQDNDX0unMSqvu7Gz5/0F27rNj9F9oYosiXxMOwobb1oruxFs4ojahbm1BQHWOkUTtRUkCyVW3lG+SSzya2bEpg8zRrGIFTJ7pCpxMhacJgVZTM8RV0prXeQ1vCdtZZeZunwBQ3IabFT4ezef/70FLM7XY0yy3WnkNLojHjyKkNtNpOuW0XuvtIN+qqjJKrupd9FJzf0Pe5yvrq7EnmNFOrqqoogIAACPOAChBEG2BTVUjMSCExhxrxjI2Iw+nwuSGGSVH2Uz/+5Bk5oAE8GbY4wwz0CcgGmoAAAAWCYldbDDVSMyAKvQAAAQoXJqwA9NKueHYTD0da5uU0EwWEIQ4bKkwYLEZGQLoCxOtqab2cNoyYMJcXVpDsLL1BsWIXXROAR7Jnkia0lWwWtznJX5PKkWyVwilQHceGWehZAycNmchzzzMfvCvPNflUVWJGTUNhrec+Pibjpenv49/Gj+21Vf+OpnhpfSxOOKMH/pHX5lNoptxhQNMHiqKTtS7dFLljnZudyhH36b/ud7f7GL0//7P/3IwcAABXBYFo4/I1PMoitxeMaXDYjEzMylUxZkm4xhCtzy/agRIF62TJXsVW+XRXusRgEoa65DtPqs6ZpyI6VrRGtPJNNKA8oDxRAsOCZGcC4yum9pQwuagCCDdOMMztopBERrg8swbcSFBGhPtCk+JmkYlGSELpkeojJ4mJVlBqKAhQYsePEe2JWy8DZNOkDCLKijRQttxBh6azj0cx05bCUkfFrffSbnPrn7ZJitp2C3Lk9+zNXaM/xyGnODd70uAW4AONJxtElRynHhwmm5l4GD/+6Bk0IIFQmjXWwk1sCcACnoAAAAYQaNbDCTZQLEAajQQAAA7qheZezKen+76f6Lko3IZt6P2/i+/tiXtH/6haoNiYzMQElNEFQDaLjGAQXEpqUiJkKYoSkL0BSOSpVFFfp7wTBowFiULgKSGS6JU6cAYyF3gMZk9GeJLJEiMuILWOkSoeRRRxDEHBYbEaBNFSzz/dnOWbj9eRpeOniZ5n8aY9blNW8vd3PGteR81qbvsNy5gv68Fs5XjcZ2f3DbWkmbv35192ur4bMMopaUH09RhCmr7rnRi7IEzGRSLhSZTbTrAcg0OniMcVFTjXTlL30DvTt6qtattSmpYo9ns/d/2U//70M/0alKXDosMhmIJSONOLNJFF6AFoQkSnCyR5RtKgTLUgIDXFdPIpi26zG1yp3zEJIPq5HznHQ0x3S+VViWFW+xErwmlqVS6t5Kjp23CuL6R8vrMeX/vu0s1dzZuw62cqH2uehs+y56yGO3YWGJEYwzWrgEioObGxGKrwo1eD7ITi0cP0a33dGCkc82VobQRa5qQMoFlWvBPooytPkN0lYrvpuUbShSfArHuMVWuU3pU7Q25v39PNN+/xdvV9r6gIsdUNJ3reau1d6dbvT111BLIAAAllDdSEmwjWA5KmIcYhA0JTgSG3FBxEtFV50VE3W8Yy8jtPM7MDLVmHSbJE5TIZO//+5Bk5IAE2GPa+wkz4i/gGn0EAAATPX9v7DBxyLqAamQQAASzUIBCR88RGBuYNzEjaNguHI2STREZvROmZ6FY2yasvFWaEYnLsm6Mrm12ZLDMmiJdSoa58FhQId/ECDygVaZp7kzyemGESIYhyEPZBRsQGaUiUnEItOAJojfLOLDmXT5GUdzSdLZBNtOxT40OUVJexe1C6BwSgQubrCnvQI7LJqkFIYxyHiR8sYs2J/tYq4tmqjvJ1JR6fQEBSQttGJ0b+y/Vb/7q/lOogAUsrjLQsQSgJuLflzEEAkpYQMhmDBiMKPrQWyNBdutOtpaPjwWJoCYCEAkQmjJABxCRjp8QQCoqGjJMNNLLAoRCcxbLoVJlOJiORfhCRClDGK1RmhRKQWTVdFVAhWKKIkQ5up09O+73pqXQV9LyFw8rIvqH5hcJPDw7PsbyLXFM/24vZVkZLGvbYoScL7WNxsIqTxQ+7uijQcGjRCQN7PYVU1ULSbTZoA4oWi6GH3EX3lA+KehM4n8NzTNlCjjia4rP+fj2so/+/i/+hu6ilcAiCQD/+6Bk2QAFjWRX2wk1wCmgCngAAAEUfYVnjCTRwLmAaegQAAAAIEAM2WBAMQaKKRBghCx6NIJCTpUkAwB5FmMIySRd4XwW9RKQYBBGclh7IWjESYalJqpCbOQuCoNNkQDfHQ+SVcnPANhQwXodFZQ4s9C9pMgFSAwyRkwZSIXPJ1ZkSSsJ0KUTQ+KzCiEnFR1xsuxp1GRIBZ5+SAXMk5SiWSGonIIC6AwpXhMjZE6za7ctSUo+jVpASUlZyB4o05dS2FFpJqsbG2n75q0om7XTpOFy8rpFD1dKU0tf2kGnbjyZMXFdTILTbjTiJKbcIwIESFkwfVcqhMup4Wvs6fKf1N9q0oL0P7FuJ1180vdOsuTo7bneqwYlAAAEQRuMDriIgAiQ0bhShq+Ep004eZAXWQOaG0iC24tbWEjcOI8ubAIdGRF8tkVaJRiTiqOZwaqyoKTJJhToWi408jVvp1lr56ldCyl+iEvL9cicib6BHEPRk0YDwHoxgCkWas1+jQUwWlZZgnIsaUZDHdqRIzNJkT1Z0iSMzZ1EudLNVVyOJSrLRLz9cs+FlMCqyiRD1RxVo3OGzcTG7XRZ3c0DpL2EXezkEQlI0ikW0nGMew4t5NgFTKuZq9tvW8XfxP5ai3r9/JeYd3em2z/UtXQEWAAAJlYsCnsf1g0gkIYVJn3DCBgkGnfQfQCsyWH/+5Bk9QIGK2lX2y9K8DAgGq0EAAEVuZdjjLDTQJ0AKjQAAAAgdrrCmoypyK8tcCMv3AK06QlCsUjifGgOiCeEoKTstF09utHBG0VDpK0huoTLySq9Yd2rWiNRWHKRvMRGjMED4GI7CREAJS6wVBQWDIUSDoh1gj/cLo4g8ylKCMYT0pRbn7eJJGfd+HqPa7crYmErK6J+d5am1GnhCTdiNbJbCBkRRgfnEQh7qG4FU/HGO97uKFIJ2OMpEgEQmOHJESIUJByAcW0NCCLbXIQz9lPX/fLk+3T+955F6f/0IQpxJ2qvNXJWDIzEhAAEAIyVRtKzmEoKKB3hwwVGLAkiHZszZErnaexWxuzNXceJUrwszzfkMFqosrAP3aKzKlsfYjhSuTqMuYAJlQNwAgw88kbkqt2TPTMIBiRyERCzkLMJnzG9JkYbSREkBJkSRIU3l5fT4R+bvQ+kbZ/nd4bvW6z7F6zMrq/eUH1submZbf3piFwZQ9O/SoUYtB3zJxeN+oqCxYKMXzQ4NANRJtpluWnNNMIVBiyaQ1ydFpK7QzD/+6BkzgAFh17X2ww1QjFgGo0AAAEUUZdjzDDSgMyAajQQAACy7/wozpbXv+yxSIx62/PwAvNi72lrbkdDvkPW3pSZAAAAEaoClYFFOl4BfiX4wY2EuGDgG6JYrpVkTPXS+kNtKg5fLdYpDSuobTCKPicC4xYZDkmHRMRKkEw9jNufmVIj+PYIUm8ywbe6yhzh6KYHRF0VIKyWZ4J6UtJ1mk9IbrmJYhKJOjtKeT9MjGlW4Xnx0WtoGtPZ52MzEdZL6f9yWUjytuZbtVu0wg/MWQ5uSaem6GRkZBHsXueWgo5AWilzIyEy0S0srsBpSxSwWcuBtYmelROpynL9Hi1FD7vhtcaqq0z/TVv9//6P/iq+0AAAAPsRHZybFmboG2nqO0EDi2I9Us6mMtZDFb6WjTEBKYDdF4tlVsTxgmcY2153IAct2W9zZq6wDwqKw7qzccGGx7BwDWC0tMik8Xpl7xlAuWOzZcdL6eqxc8u9o8OV0DCylute4ke2ixAQnG2XoFxYu1RWdy/q6A6hajarafOOjnHr0QjZW1BGxe8TcKwCBqBk8plSAIM2qaCFc4JikIGBOEPJAbBIWTG3dQl5/2YmSTFej9ra7Mygk2oyUiSVApXECJ4HLpSdRLu7H/JV/3LuTtfFbZNMgj/Jbr1pJBW//htNT6XqlhAkEAAAAAEwUCsUvDi1rxX/+6Bk5QIFKmdY4yw0wCxAGowAAAEXHaNcjDB3iLqAanQQAARiDlSMRsZUAViwF2IKv+XY2mI3ApFyX6GSw7hzJBPdDkigx1m6TRqPkhT1EbaFbFfs7A5NauV0ZeYHuoFzwXoMIO1zPaSsXOrQCayiHc0+FALC8FycnjGFWFRuhnRazU3Neao2jjD5rVGIdiGfG5scg2nQTOEGMTzW2k6qcqPr0g7rWdFlylqb3ktFFae4IhRg1BdB6E1X66SkUCmwqDDjJWbNlCrHKmnJx/mlU+2zDOoeO33DTymE4pY9nRqr/dVgC32aNlm9VqYkRCAAARxIpnCUABcgl8YU+JNINAohKMODixsUAM8L3DQXAhEIwBILFpKEI2qJjYNXimJS0KkaxCMYF646c9dFKGYmZTrNmhcp6TTP1IyxLrvSmdJlJmFHbTupvWK2ZamUUrFgRpLcKjbx+niaaF7sVcIdBKu/OqXMVJh+HRzgJDl66M23+1L7MuT3kmTs07VQSMMUnBvrttG8+zPhQSJkH27XJcQSc2skiaTjhQu4iTYQiKkdDToU5RvIPrdsy3SoV11+/xT19bO7VZto/66aliIyMgAABAY3VSZIOXGxHiATBUDW4BT2EomhQVUrJxIRrqODP4w+cWWAZKyJ6WSioqIxbGJRKHEtsnZNVIjGePqMlk6ir8EfOurarLX/+5Bk+4IFSGDX8w8zYC9gKnwIAAEUrZthzTDNQK8AKzQAAAQbtij34lcJW/m9clvobS6juRl/Ky1OdZEqXvKDmo82XI00GxM1RGraDeWhUHaqza6MV/dJShab22tocvCsupvv27Xev+aUji3yW0dhz/m/SgQCY4cHb16pAinbq7I2XMaXDV2mlLY4iEnJutdEC2I9voToos/6f73exvv/S307mt2iui9SYQyEBAAAAABA7xyIAQPTQYDBg5AZUYCVTig2TOQnmlagLVK3EhSBPQ9RbxtDDDkRhIgUqRVaIPFQrkXJDXx7NqRjJSE9ePX8NdKDa2umMoxFiAWcC2DgppoDKL1l8DTMBsglZqJe4SlDUEQjEVBw5AkWCCT9LKLWH0geP0grsPE4gx44keNQMTNRb8xzJlKMRhLnQ8WdpLkHfsw6Nc7S+lG2g/xrLaSjUVyVT3cJFQoRFS36PT6GAiZoiSNspOhJypUFkLEqAKfVE+XfLtHFa0UJSxW2YVtZZ7NCWe9rO10/762od0If/YiuypeXVCEAm0QTDo8QAPf/+6Bk5QAFJGNYcyw00C3AGt0EAAEWpY9bzDzPQNGA6v2QgAQDEDLDFoS+oObMkEvQABC06h6ZiuE65yyCxPAsmLJAbYXImbaiutorOUxgqWOSqX+4RnDKB4tMHB7nVAFIQNNNW/IapNBeooqHW2P5QjyyCDo76UfqaYxj7MxL3SSRhk3j2qPP9XNOVPSr5v/Xd/XjU3K19eiv8+a246UCd2SRs6aL05ysP5Znlrg2HQT6cJ1bEGylJJGkk6E4xxsAD75aRVWZKvIMlys0H6UlOyvYpvl+3FhShyeqiv/Fen01tsa3Xo966y0AAAAIpilZDANEToEJAhLU1EZoYAW1ZiullioobmUVpBFV+RFnq1X5cNRxsjEnch1QGy9KsLMWTRKNs+kLZ41KbAVtroVy1YUCsTSOsK6Whm8axJVr2LThPc+PSSwl9frpTTIfXchHglFJajLy5TesB3GYp3DxRyx6yCyyiZfUpqE9iRbJNBJ1GiVYgTNovUmkkkdcTubaHnelBZbvn1i9LCipN0myN1RlpYtEo2qZdEzSx8ogg8dTU9Y3WSCUomlaEY6KKefBUlVMPTvXt0m5QWTU+tknqT7vAOYaU2mm9P+jszv//654ZEJTIiBaSKWEMh0RpqAiAFaipghBZfMWIuZboQ1H5FWAJIxdX0vbC/D4PxYkukrjj3kb0pRJ2Zj/+5Bk+gAE9Gbbeywz2jPAGr0EAAEXrY1ZbLDZAKyAKjAAAASIgahM+HnNLTTFS1oIMpzs2XQyZbpENJVmuKdj2EM2Rgw8YxoyQ77Yx8azku9HKuNR2Js5h0tZaV9F10Pxk2kfHFTEItPVX11d9VcxV0YNcVPJPFw0CwedixrsWYccjycIkSZLXrUnFFTI6kkmpIQjAKkpRdWZFTyGGyt+u1Cn3elkh6D9O3/fvaZey2b+/7qf/+it4clURABVkWzs0SeIlmEgrIJgXRfYOeWDsnBTV1aXoADQUFAyD5KfmIlkE0QC8VA4bUmvJWbwKlFVLiEiMHIpm696O7Tba09LZ8+21yh8pbeUuXG5CuzIIenxCv885Ged1D6Me9ezJNd49M7t9rUO0fbj7373mO57PbeJ2DMRP9teahjSgkl62xTpp0XRA5j257Ag7Un8ZJKiRSZBKSbrJPILBUshEWadW5VfTMbH7XyzWB1GnxFOq7dsZ69ie/Z/3clQiiprKqJpl2RSIQBZRSUA5k4juOyDnCSQwYBIBmoCFRAAqMYlgOT/+5Bk2wAFB2jZ+wlEwCvgGnoEAAAS4YdjzDDNyMQAabQQAAAQj8GIHkMSCwIBPTdZFGiqqXQn7iqq5Za6XV8BtAvOPprjKKgqiU0aVeLNsajyEpVB6vUR8neqFMe/q+5vMVl36dnsjCHqe38LchGxWdotprC/6qMbGc1v2bJrt9392XOU5ItAigmC9RKiKAojjxWXz5Mi3aDuGBNKottNNSQkhOQDIbKJEx5Uq3SmHXLfMb1puurXXADnUDW/rZ+3Ti1vjtu7bdGbzOSEgpJppUnIYQonmPIcMbOLTDipal+AxKkETi7CEizxl0ZqtcdCXxyli+5TLrXK1WS1pvJ7Lc1VlufKRAajBhoggYTNLvnqP1Igv2jTmo5/E2WTuzIRWZUjyEKOI/SWOUsFUjbbReUiSTrc+K7j9pX7mgjlfZRcIm6bcykZWsf5NtRIGCzATr0PaPSHQLmyaJ5tGKhtyNNIkFQ4HUhhpJjHiqjrV2y5hS+AD80bjaHI661f11+j9fq+6l3/c5CzT13reQABNUA0SDFIAoRigEqY4oGTmNH/+6BkzwAEuWLZewwzYi9AGn0EAAASeYFnrBh5CLoAKnQAAASPCFAbBBI50GCq8WM47HFbV2tzZR8QXPAbyMBfNzRAsoUA8TsozZQUKQIxWSmNSLskJVgVxQQQD0x4gs8PoJoi5DEBpmkZBcHAlppzRIABJwkoCO3bL4YmYgRBhPFYaRQPi909VInw68LSpiw/Sy+kcaSw3s7YmdTXjdt++99VuGGISQIl9i0spoJW/rtdlPDlQMKBdMznGf91BozNW5JJGW697SLRQjNzNLeXTKWgVjXyDLQkgqt3OhE20Y7+xS+kWOdFPr32f1fq9SRAABwLDVpKMGGJXjTQAJYCAShUMt+wVgSyhIFtFg2oslVuVte5R5CYzmbeN/H/dSgl7L4lAFyP00qxpXYn41PM9Z07leK2Iljbvl3IMRjhU1tICqZ2Ae1AYIWQVJUJKRwalCEFY6ocWTtCrizyjS8Q8qbUghOnT056gM4+YRr+XPi1p2tGucamL0ghpO5q6Trp7zLchaA3yg791s59utye6WSU0+FTJQNIKKMMFUu33a45EgiC0WXHOIgVFxgqF5iomKaKCDs2uzoun/bzMhQ/0VWnQuIGfT/u6KLMqbSJSsoi3L0EFYYzNAAAAAACOwJMcYM4eNEJLoixkt2IxqqQcKL3A4EztL9bsrYxIMGsM9tTLT3PcVhs5Db/+5Bk/YIFemRWwyk1Mi/ACs0AAAEWWXFYjKTawNIAqjRgAAD6SFi7ZK79y2CrGxTJY8LAVK5yYIY7GhmqFhLcPy1c/xXKGnPVVofvZalo5759CuQlyt7Y0D+59mDWVtmjmSYdHTSRYTgJhAWkxWarSswy2khLNGky3aNde0nOc18iCtaf83SVrOYqqRcJTJIniLgkdDE5gxRXnuZInFaTgDbq/U5mmSWgo23JhKDBc+8P1WQ+tzH6V8oZtuSuwZF8v2/rT/2LWvZ99blfq6afs/r3agPXEx9DXIMdtzTSHAxTtDJDKSoCyQv5Da6V3ob2HGVWadSPO4cRblfV3QSquHpUFJ7APoDjcSS/CdqRiiEg2M2YIT9EXizqNE0errkKnJz8s+fNLHbHLbzDyxZK36xmSJeentKffpOp5W3SD1rkBnGugrdIsoYMuds02vWfvKm96MVhXsFy/sNPO3Jjka2r5E18lOJW20vgkhAzSHL1FILOQjPjtus3fSwKE1giit9SlispElNmDa0WLCpSB3qYfYPtah9V791//qc5aLT/+6Bk2IcFo2LW80w1wC3gGp0IAAAWLZNYjLDVwK2AaagQAABTsVXUui1rKKbmdn/2DdGZSgAAJmmA4l6ENgNg4lT4EmozmAjL0uS4TO0S0OjbLlf2SS50p6u3sGvy2N+m4NdIRCdQLCtEGQFE4kA0D4lpYBkCJI25syA4pDOkyYgUcK1FWAbcY1JJhZdpooRoEc1T0UhEOsagRvPJ9RuBCjQMozG6IUoKNEAki7wPLy9q4tb4pcVoVlFT6CA0quDdMjSrIRrwdeQc7J/WV53ThWUZt7y+f31syqzCqb42ZH7pKNPJqIENzcDSLSSaRSlD54BoUw8OtTdULutP7WFpjVy+9zfrs+j9Lf/2qKRZiGEX//TYvYyABWY3cFoRYQFDwEDjIA3LMSR4YgEHAToYXfTNeWPMNdKYp5Y3GYQskoeHgIOqNoQMjSdLDREdGk0ZUkNquabGDSgakjEgTw8RCsUY4sfX6CjwmCpAwQEaHYWnBMEII6OUDnLgaQZBMJO10Dgkimn7LVvZOCQGEbaKRAd1Jy7VHAkMMuEQa1aW73FbDH5R9vrq2NrdSmSJZi5ec3Ha8zo9SkhwWuasztZtn/2SqdBzajjSRIAgSQwYs6cLTAoHJLSPvfcl/xPufpmdmFOp9Oc3f/p3f/WjOk6bOlWHeHM0EQAYBxHExVCwqohc8WKNBovyFAT/+6Bk7AMFs2hWWwk1cCvACn0AAAAV9YlajCTTSLYAajQQAAQoEPAO0nchoXwW5Ar6ADC1MJInmiWED7J++uHhQ6ZWbrVmyeN2iSKBuySCJX2l96/UQmfvWFwnpFuUxwzOE/+9juevZa6pxB21TQhr9LITKZbQchVU+4mgy/5iNwrMh2bVRLFk8uDV5ZMzE0bMRrGlo0gfr0WpAruSVjmG8m8IrtTa/aGtND5lYZP0E0iUkkmk3QLCKBcOqYVrapV4jtRYRbsNA9bXzIxab0ZKi5r/u9VmtpBy9yb7uhWuYq9OmqGFRAAAAAAADhHDNCDXEyU2ouAiafRCKR/Z4SAjHEBIYY0WyoRBGEqbus/D6srNVHkIHMdB/Icl4py9zI1Koh60pIzrB2LR/Q2RQqdoVkJ6omRRPldhDGZSsS4etjyRC3FsgsKsTjpdvFIRbal0y8i0lkZXh00N1va1bpIngsKpDFLIAbYBogFA2bMCAmMi8NUYXKEF6OGgkrI4TUvhDEukjEpuHdFakDQzBlhaKFx9+a4ll5bNZyCM5LNTy3OlHYwykpV/+qdAJ8Crwm2vrdhnmVnvOiAXasoIxrgC2ABPQLORa/W5Kfc57W6bX/hcXW6ES5JhZno9933Gka39KppWUgIxNJIElwTOFSgRgeVMwGoCKFsS1QGKsEISJhalimC/nWm6RuP/+5Bk/wAFEWjYcywz8jUgKm0kAAAZ0Y9VzT0xwL6AKWQAAAAZo5dDbYGUvq2RTR+ioJAvJfEInFMENNitd4+kMk1JTsqSjpGnbqJor54l/Hsl3uAWCStztJRApLI55+MdEf59+RGX9jMvNZnS2UH7ZfhI1y2o0d1EUT7/YhaBeETJ+PFkXTLEjJUbLMZSpR5TGiZpjGeTRVQGEkBNEokJyve9xURTG0JnjTxbaijFzZFjPZc/c/1fYY9jJPfoS+ZKGS5gBumoxK2e2539eR+s0bJAqk2CuPyyEccIRJuhjBI4XEjuUDYg2ePFvW6JjuA8duTNo7kroqF65pGSzchRsuIg3g2YLw2EGiyzS6NuNqUrNzcX9Z6FtpfF1PZBihC0nK9taEKTm2wxdYiEWMtUqiPocZYNrzI5o4bl7nw9Erqr9MYUblk8Az8QRSQNzm6zJUrVZDT41FX5u3jxJJBik5EnIMeeUq8R+y0lEiVWTXoSBAIxVZBmEK6RUcplzhtoJD/pWwaaehKmUM/5VnMnex7Ov03t84aoqVV2hTQyEjL/+6Bk0oAE6F3Y+wk1IjWACl0AAAATcWtjjCTTyMGAaXAQAABQJJcNdXPGGsCHiFEg4QiM9g6AHLkbAn8biqdwHYNg9TF4sk/1a9IrvdaEZ/FsDkDhdMcutXkp1to7heo/+2Nleilp1JMNEscwCFUOlDD1RhhYGtkT2LNjDo6F3BbzhiOI/Gmbj+nd/7rHsponosXuHGFgSGoIp4Wk32ct9OtBD/MIkZ5oZAyoEW2xN+NbHKuFjzB3UpGlmJayrQ288g4A3BylL22rNDu8ikl95Rl0i+d1vd0W9fY39fo//bosRDIAAC5KgEIRXCBqFICAYtfAJQzwLlUSRTgFp7YFAphjj6NxfhwWYRyvAEAQDjL3FaY1F5LkMLkXq+jYWuapysPIqOg/A9YqHrx82QRFLQ/r23BJSj+gMLxSshJ3t3XDqdK3bpDsxaF6U1Rq2iTeMsm6tTRuUA6XPvFx4caXK4gHw4vLEI3qcRleBb9deulxqG0RktiLZPWGkS9RB+o1n6zebuxS9PzONWQ8SBkSdyc9DZnLyF0yR5JDzOiacRZ+hGW2kkCUnAq1JgRJKvNoc176yBJZwUUpJEqr91P+r67af3Xf8I04r99f0rdlRSNCIJpEpw99LrN0DmBkWaCyQUMSMnOVAxKFMBQ+aCzKJE8PgQIQ4FUWxVH1k8Q2Gi4mtS7Akqiw4bn/+5Bk9gAE0mLZewwz0ikAClkAAAAYKaVUjDB5gKmAKWgAAAAQnidWGBfX47WaQKNQoa5s/b8xOkEV1Bjn2Kr5SKGSXB1Wx1Yv5kuusQaKLrEYvcnlX5z6g7lTMHmGI3eilqDz9R6amk+fSJjdEu9Tz+7WXQWeVEe53NKmeUdvU7wW2OIDrCCmkgiUUUoEFiDyI88EBjmnEn3TKlKFmNT5ZrkuczqM0kTl7fdbfp6O7a/o1/8LlUUb/remVUUTIiCUSXA5occcwatN0GUIOhmRGR1FBlaYNCjEp2QTcXWopvLcR0qWwanwlCMV1wzPlZbUnbUDCr12WXVZqildeyg9QoqXLLLTvbZNrIlJCh54TSZJ6Wus1HtaqbTNQWmYvMXM/CKKWmXKruqwi23fe83ctbGkGsw7hPO1Zjpr7Ll0JdE1i26yJbeLGsBJOo8vO+wpsg6qtmMznyK4kSSSJVVojYNGlIcQfeIOxJZpZbxm0XZYrPs/VKqaYnXfb+v/zHr3bNCqeHZWMyACioiXDuIQFELD8k4ADLmEpkKiWABrlCj/+5Bk3QAE8mPZewwz4DRAOk0kIAAT9Xtl7DDRSKmAaTAQAAAgYN23XuL1cpy+SB+RgpeEp6Z1cVaQIVqUbXBMiZYrkEljLZ9AuWkKUkczWVNXKeVA0Rm12S9yWkzinXtBtKNR6Sacm9MZzZutuLzCqtSrrkHQYVWx1e4uQm0zYzCDDgQ7wKQDAiKYJpAhi0Ic+KGbI5DpG3S6cZIInoI7gAuRtppEkkExCGB94mi6kPY9C2onFpvo3e2lG+r+tDue+98rVsVXu5LT2orF9fOTVrgaAAAEBJC0wgiL4VQEFM7IcbmiS6ZfFoKcyAuIsCfdiSPFRVwsR8hooxHWfFVKZA3H54vsGihCEIJFoSkGVoVbOoTlP1IsLh2zAtEyYSJCDMGhK2Cy84s4tInJtjqFCKaIiYTk5My4D10SBAsgGHKxFDKq5o8hHliFEQsImRkuidFVAvT2+QkxpleSxGXxfJzhBSS6RKZ66aCsaO7DMn4orlSCdRvUtWZqfdJqLjT1hQYoGQITCssYZO+hBlZpxJpFOOBMKNzZwjPFkrJjFuH/+6BkzQAEz2PZewkcci+ACo0AAAEXjX1VbD0xAL0AabQQAABZJCGTfZ3nb+vps/RyOTyZ5GFJdDW9uxaPT+vWNUEAACaFZeQQmhVZzjSEEZCZqjg8Olkqs1xJBYi9VVoYZm/Mqe+Ho2+sXdCtTNltUzB2SOu6juvRAbkVou/M7Mho2SBYSEKUCUAsWokRIJQSVbEpBmrB9kFlBGuUKlHPFB8oFk7F2XjgkBdBpUYD9Ac000eUYLHR48mnnWZUaWXlMiWB6QRHzkqJyDlkTF0JEkzUUnC6eEWM/fxOlqWJhL3gEbC4RhJ5mS0tBfqS8Pr0kEUnBBH+VX5/v/aM7cItJNqGlYQCD2JQKjWlr7FYzKuPLRtTvv8U1orZ3vK6EPRmLXE7Kf+hfodVLw7OqKQlEkEqHWBbQLnQNNgy35sIsIoOW1QkjRhUyAJSFKp+AWDQeu+noDhiC1S+yjMXHzTirEOKOMrRqT1+CVh9qyGlNUXDE77kBITkxABBk8QeyPF1ZzsBhB0HUrkwXJT2YaOp5lBkawqPcocWZS00gfZ1s1jvSVy9yPjrQwJgqRKbBWUOXRomQYurE9VsYXjLNylOTnPe55BlMfQhJRr7WOWW3Wr6n/6fxW3u6/6LP+nqjaaIBAAmgKWbdQQREJ7VCoGp2hmBl1QmSS/7fppq6gJyVcJ5TVO8Ck130ML/+5Bk5YAF51/V2yk2Qi4AGmoEAAASGYdl7DBxCI2AaWQQAABmYiUOh0ZElZpWOg+HirKhW7clPjSqdiqW15w1GzDJR78slSEMyqHTyPoSnERdrcBIVQiK1WUBKShukRxJNV6IVnCGKFKTb4E7UTZ+Us/YLjTRlBCR9V7CNTYXGSGcVGXoC6Ax5nGMmjkgZkllZL76c5HTmGluoxZtjzzdazVpeq+edqQB1p9Duvd/ENEpHJEoSEmNUSF0pJjxVLYoxgrfQP794oIrWnvan9F+z/uo27ybj9zFsvDCv3KaNaABBhU+72g4gIIJbIFhJgcUuWvgTEoClSwlDogiZVIFyMvUET6RVbp7rRaGX9YKKwNhYDQUQio+DxQLFx0hERAorIysNkSpNFAaWxZMhIGi9KtEKx5alowMWWaqUlI4VPM9knOmipZcuLtpQDBDAhTFTTMJISUArcTyBa6IllzlJprkdlkLUj5ZEgOFxyWpJiy6L7JGtuMlRsj7XfxWpSakkzBiMDpRtDJU5qe3AfKOvyyT2RuHmEQIw65egFODJUP/+6Bk1IMFumdV2yxMsi8ACp0AAAEXyaVUjCTVwLeAarwQAAQ0ZbRSUaxQ2Yj3DHiMbqRQvfaymu7axNjf+P7tiXS2M/s7ei57Xvuf/TVZVEJBAAAAARHOr8ZWMxQzTBI8EhhmaCgiFUTJREHVCh5lQRyVjwc1SPsTYbDrsVgECIlPkZKCB4BEAWMCsRbIydRzSPtoQHgWNHhuU4QxdTHn0DTTJctqqPMXQlxPTaBVEYNqODAlcwK1kB0VAWaPE7CMVwVLvIHG+uinPSvqRZ5VlSHqcw41depBi4Zlsq5UTIwHqk45qP3JeCCt0lLZicvvXD1Fpvnz70Wervzfoy/ePq65bkcSGGEoooklqAsEEfJBGRjJ+H6FtXp5icnSe+uj99Fs3X/qH2M2tYz7n7e5jH3Xpp/0JBkwkIABjIQ+ZkQilJoVVkOICTMUhRaEF5WEJWg4tp7EIDaWVDD/OZJJA2SREPgH2k0MJ6U7lGusnmnlI/LmnnFNXcUs8fxDfiPH+mV+1OMd44z5iObyNDc4MusR4kaJHvZq+32F9XM7VE7XV5PVvgzdjtd/DeSstGXTl39dTq9ztPmjuPCn3Bx5oWs1xaE0Uvfd4NIsDdLXreFNq9v94xrf8fEKWs0k33nG66pXc8ShwBGkFW3E7O5deSUiQkXBOoUY0oARZlajSb3ycLD3pdqzn9X/+6Bk3gMFuGjWcyk08jEgWl0EYQAXHX9Z1ZeAAMqAKSqAAADiJ1KA6h23QeVp1f1KVfShLN1Y9zin/1pEhFU1VYVYRlSTq0qgMKF03T810soBjCY6o4BQgK3MEYMoHTDMQVKgYEvBIgZoaX6MCJMYCAysClzJHy3gXJInGsLkz8RTjInCsUWAiAkZDkoswhYyt8wIgHGHJDkYcGUoZQ1xl7FUVl2GYKCAYNJVysBLgt2WFWAfxnyYamAwFbkxGItqweJQpbTD4PZ40fTTn3zlDfM7chWNiyyG8lbOo1Az3PFVbZpskUAgVoDaOAzCLxNw2btxpW/tQC7u5azJrM5Hn1fmdt9l7iP1GHWd6CX3ft7LszVXPDkZpnetRiN1YKi0aadGJdLeWoMdukeSB5ArhYdiEsh+5DCllFt2G0i8XjTM1pPG/MqldFO4xWns0m84BbpEofciw98zfrQ/3DOvP8v2w+NHlv9ySipEkmm1Gmog2ky5GyxQTnMADNGzXSiQnkLu4cTkmnjYo8kKKKi50m1+KJY1bT5R6WUe0B6jt1z2m5NwRijHFlsvqPp9Qs38UeqZGQyIGm2k3QYwWEFKhSCJwQY4pVlaSJFQXLWRFIhQ+ZqMAGIaZRPnisULbKyTPoMSqWZodMK9dw1VA23KaI9ttnc3m2GO7vGbKvNZ3uDHc9Xvj5xa9I//+7Bk5wAJamhX/mtEAEiCKo3AjAAVhYtj/YeACLUAKauCAAAPWNRfiFqlqvJqUiYrTE7/3kxvec5eZjYv90jYgSWxWtI19V3B170zJDZazRc3e68HWLfOvbFs5m9bXtV9AfPIUOBSlc61FrBs9viFNut4MKZLrcybNTJIpJukkC59zYspaUuJJk2LfRHr7uy3X7VIRQ65H0ZGvTXbot35G7/n3ffVSAEUAAAAAAGCAKAaMallBRw4k4Is95YIvJR1M8KiR9DFokMIYUqkGAehqELYatdxE0YcZA3BStvFkW/bVSp913tu9kUgt9hydTkggFRGepyPEIiRYrK7TxfZuHCw4ZWr9N3klz1tWfLT069Fe6xZkJTKprEdOpKzrLTZKSutpk7jtT5hakPsmmYdUWQHLLlJfqw2ze0QnuQu6jKspyRctRcml2NJbE8/eYhMA2uj15TXBd/UM6zZ2p8v1YSE4bX912CWmkWk2k5QmhE4bGOPkzKplq9xxlF2SelxISUKKRle3RW5+//6/+qLsvctzbVVXCvDqpgRbcLd4BKYVgYwkMcOiQZWIwjhV9CwhwyrEJ6g7dGGxA+CERzj1R2dBAb2xXSlF5/CfHjxYRxfVwyMS0sRpmZM832qV9TRO4w98DNW4yoV6Hnp7u337M2+P1N4WQJ2Omn8m+s2We39bPff0K+7N/1v7F/oZjvEPdFtGabe1RbY/fDCoSi7covxJexqWlS7yeoj4JGDBEI0NTZiJKVGKM8SDjVLLKZfM3tZTi9Cqq126Gs11L9H9CPv66v939hqLLt3hlIiBFIpv8ooUBDKAkhkKgemIayFQP/7oGTmAAYFZlRzDDZSL4AqfRwAABL9e2fsMM/Ir4CqfMAABAstAAk8ztMZnDAWB5wt+JC0iA4W02IqKI5QGlWwgfzrTMMyeyFSr2hxpHB061tVBdpnIeUcqu1jfpmsyS5nySYaeajbGI+tia88k81j4JIXGmD451SRvDWyl+89TdYhj80gKWSwsHJjVInEI1lD0aaMoa2TisGQOHWXFi65+gx0H41t4l0FVZNODo0QU0ikkklaLYGIdiN5Q85KKukoxhcVRsuXdzKWneoiTs0ywQo30f/uIdCNrU2p9P/01Ls7KZCQSZTmxlSAVk1tF0EhAroOIpkFxFD3IDSqTUxZAuudWq4r+NXlBYIDRIZUjEYrpsE80KBMnQyFaJdtC7MFTahQQjjJ+CTakkZhfKa7cdzZTq2ryEU2osNKpSYgWzxxEw+Dk5e6hStrK3l7luyEWX0vCNestlPoBk3yOaA227ZpIiLUirprsTdJNWUZQLVHwuVJ3stbSwP4s+DFWm4OxTQJTUZSImCI9TlFR6y9gmoAhu1b2nnWTtjvR5aQV36n5LmmtdGUNo9f//9VaXaVRCJCigm7zW1wzApzBGpS9iBQMClU3bki9gx2EM4fBxdxpr8y78Luzj7q7nKOVEpcZA2McVhsgIQujkrB9ISZJsNrI2i5eUZFJILP7NeUbvsQ3zb5uhGTqf/7kGT/AAUQaNj7CUTgMiAaXQgAABRVd2Hs4SHIr4ApsAAABAXlkqiprqWRN0Aj7IJuhSFlBDmlKJZr+n2Fe95L7ktLfJH7EpHvyYXe6V0ifY3E0m8S9lrB7010at0mJpZiryH+9j3onffANS2Np3dC5oDAlS1rn0IZrrLpnE1oYugPoE1DEM1HrmXVu2/26Pb/d/0NVQ7qgkYJKJe5wgNPYgeAD2i3oFirWhyNQhpp3KCAL+dxcq7G31bduijUBO1M3bmEWoK1aZnX5xYDIT4MLRSKShOkhGyFFycs5KCTFggHD6XItZlamR2LP2NqXbk3aJL5+1a8e519yHb/sxcx6+Ll4h9qt8NAfmpscyzyBatHKgakRYeetmajOy4s+cEXcgkoQiGlfL0+MbmKIsssDBlwq1tJoklQ8144itkuEws3NU3qkND1S8/YlM7CsdQ30qrWxb2oXrYhFns0kOPUYS6X6FhVRUNBMlJApwxyZCVcNeQKEGgchVUwpWSFiEAGtslKgGUuK0NlMFPKmKjMhoQoBERmxEBqaZ4TA0TtTP/7kGTsAAUOY9h7CTVSKaAajAQAAROxg2PsGTfIzIAp9AAABJgqrMdSG0CYZIEROhqVYMJANFBCjg9poxSkUiI2DQVvmb2+umfE2Yzkp4cC3sVWweXnrY3UTWO/3Kmi2Lfez+Wh37GtdXm3RVtU3Br1auxUnLNclmO3zDrBlYjW51/WEnU2imkAcCUqUElBJgRc5O5ebdF3TyXLvp181R+4qB5RCqzNPZ/qR2/6vSsqsKZoZhtxuTkg9OZPY3cYQgdeNCUTLwwOG0iKJniXzd4w3JQ95ZG3UAx1AAUwMgMFR7sJZNNEyJ1B9gdPSWPTb2bTbcFoymR7BqSBAfQtvxjCc2SMOZCgFKQIPYs+c07wiio4kQqC7dty4J59dO2T2SzHWxHtm7Lu0tn3vKeW3nxMddzk+Wd2m/wfOK8BERbpRlu0H1gZPanL2sIQkkkyAUAAskeZUdGMihPiA+41/6/F/7qwadf//L/LRZvf7/m9f//l2tf6Fa4TiRIH3gzgcQmW+lX1++NAoJtuTgEwebIQwJSDqQN6baZFoj0NMKFluv/7kGTcgATXXNd7CTRAK4AabAQAARONf2XspNGI4ivptBCO/GgopNKjDdWutzk1tx4iNZCVHUS1mhQMETJFeo1Gbb0hRlKYJUJAQNdTG04CslZDKFE03K4s3FyBZbV0SyKN6RXNhwVM1Cc12PZhVsyBVWi5urog/4iBaFtvuoNj2trtZ1elmbFraKHH0zJtdwgemiDAESQ9FR5EmJdSOT7hSdt6zQbzk0rkbbmbSRmMRWXm2yNkDN9LiRxu1F9DapxIzLfIteVO51XZ/jeoj9C2joZIhkQgIpMtFUHEVbSgSbJBBAMyBBp0AA4oJxFXK+aPFWZrzAgESAiE6EkRwbJQw8VoVUeMk6ggUWNCcl0hQsLJrsoTpAo9s0WExu4XBu31Ki4b1ehREYwVyTjoytw5z1lGgrPFzKUHlH2ZZ65avu5fanar3GyLdmhqdnzdZ276V3qkqRhvWd0II6UOVp+Op2SShaE0t6IQ625JFW61OGlqMDWG63DjV1ZdPZ2gM6ebfVv0lB62MWUebjVdzpQf///Xf76Pd1R6d4ZWMxASFP/7oGTNAATrXthrKURyLaAavQQAARLZe2PsJM+gw4Aq9AAABEgnizb5M3AhxkmDZZYCCBA4oQlP6DRlYEyWStDWa/VnNgS8wACuAiFa5kH9CIAgPQk0lMNvPJ1jTeWsIRKRXrBVVFYpEvQiRimnaKLMfdXPhcHCTqoiSQMoy4qa20XZ1Zr1MlRsO2vXGVaoLOntlnF/f7b2Cy15npL3be+zpJ3yVxiSCRBPqulWo1GexTwgSWKs2OTewiCIWGkkggTTawdYcJPyT2O7V27uq7+zaLEhFqTXvb9m+//0/8n/MdcvDqyIYkC2iU8cTOYFRPkTUCQloAMos8FzpGAJbNUImhK3tIZaVhzF5PWmw9LxFJbq8xXo3+Urzcvlc/THCzvPWHO9IuLMSrl7XX5sgt1PkDOXXi5OKYrd3PFn6Vqivy2kHTY5tuqXhuVbZvjn4XSGYy91vPz7TbM9qepubPKrHzDHbbR+5TxjE5HFpO3ytks+Ml+djyZWRbwD0oCSLhSaKRbeOMOHAK5xkMsTWLEW3FwN9FZS5iMX/9/0t6uL//1/+7VaimeXdRMxAAlEp42E4moN6WCKRwORlQaShkeS/02YkI3y9qcMRQKQ7PxBIkDQhJ8892URsSjFXZCVp0ISjJ4vko+yKkMuUZw5ZHMO1+SJHhkWGXtzbFHI0RwuAKlu+9Rm/fZOJv/7kGT2gATlXth7KTRaKEAafQQAARNpi2HsMM+opYApdAAAAOwUlTbiKVOUBWzfbSxE+XctqiTcyrvaZshmPdI67hIw3svrdl+GgcTLNTH5ZyuihsnV9PdcfbbKKp0C4LdAsyQiXKMapJB44/apyXrQgUJ6NCKqfoZf6Hav/Xtaz/Vb93bvX0ksQyKxAMRLIKpj3FW2GDprhKCyAMM8Aspk5EsIej4pi2FWBS9q8Qej9EdPMIRNocPkstNCIOYUDCwqTSISLOwkTLJRUEzduHYzvrKpE94dIJUBm3zKyy0dd30tkJTur6bfX8blHWeRnvKNNrqzUP2aJbJ/z/tj59bZbcNyWrLspOW9t5BG0m9pVIkwCLqm5B8MeU2xkcrCSWSSiE0nJiThRR4TvALWRVamBPo7ouSU0WBZZVVOQYvPs0F39Dtw5CAIGCo2ykxRZ+77tK3exb+qOFVEEhECSwQDQtxtgJ0soEGbMCCkwygQlkaIlwgOi0cTrlzprSaUQ9MikQB+esk/4zIoLCuuN7ycMdaKjdSLdDjDwGkTEaUfYP/7kGTwAAT3ZNd7TDNqJ8AaSgQAABLRfVvsMM7o5oApNAAAAJU0vZbWrVledtBeRN+jDbhFjc1u6jid98m0qd2dD3hVO3tq+d/uIff8uHqXdTu2Ylnrb992cqXbQjkYTTNIk0WaSBc7ZKC5wtvZ6H24idekdGQWm5RjEkyTXrTTejei/r6E/3PUpCvPdArP4v1feirfd/6tOtiqaKCKbcmMvwAAgiaCI5GpDdTGEGFKzICl3pMfpPxek/Lkb7Qq2SOdDOjnrE2lYjrPn8OJh/PaEYaeWm6zlqy4rBiZ6rN3E0tm+Dp+UzcJrjGJrR6ru9QLNtMxmMRVLz4llo7DMrXmdlv04tVnt8mmBi3dyU9Aww8s9+juu9te7Ob3f0t+xqfTy0dt81HAO44kMeUMLl5pjW2dRkF3OFTQDNJnhtxvWYQ/bUjeScxYRotUpy/VmFoQK1MDe+22liC2Vq0N/eh7eFVkQEJUTKVDRLfEQQYEEoMIUJpqOEFFsCELMQKN4FpQS56/H1fVkDjKCrisFiQkALSZtQkkQEW+UENU2MIWGv/7kGTjAAS6Y9b7DDPKJiAKWgAAABMdc1msPMvIuwBpZAAABCJ2Rg/kKGpjh8qCyryWKt4tVbhDYl6giBGAx5m6Sj3SPVyymefJ+oQn68enWswo0VhhvbdPo1oSk6ldrxy5uqfH3G/bv/nqT4e8QJnZBZhJRL/GXEYBI5UV3aGRBRKKJRTdbhh1oDkwgwygVipUoLVvmj7tE05HPqWtbdvxWId/jzmMVHO55S//60e9UNCGiGQISmiCqGETbVjGtTKJjNk2rLjGBxIBBgEv4TAl0MIbV62JL7gDwAziyMqJRcFgCg6TA2uL3QoPLKNIOXaIppiISRlaAUEYXJS3N1B72UEF2lGkk9YZ5hRaV6xUo3WrzSm6puU27nbDEY+jrd1uZNd97c61uE15ZFT4x5PlPxnPZL7OMIRX2HWY9+CfV2TSFMshOMZklmVp+ovcspm9rsRsnNXARCCEiSiUSk6UQlQRU5bVC1CS/OD6fVdrd+hpu/7NFX9P/3+n8Ubb/6YkUmMVoTMEYBMBtsIhpSz8BuTlrAxSKJzDFwhGYpIawv/7kGTfAATZYNf7CTRKMkAaTQQAABT9j131pIAoogApNoAAAIYtIacmYIQSBRRkMjBCEBJ0wFc8TwYpARI4aEIPCRcDyYyGTAmqAYZSkgmJXKhoQWmACBWLoetfL2oSmosEbZMAObQcQsRMEQDKhCAMgpDLCoBmlo3rJtgotkgJLbsgLdsLBAgFHiSaa0zVmzsu28jD34g5P9n8DMrZtEYk7LwKYuQzqD3hYnA8pa+7bX66jD8PvKF1w/DymTEm4xKbeqRO0/bTLkvfyHKsjy61eCI7BUDMubvUisOSJYJ3Xkd17Y9T093U/Tv7atV3mq0FSnnm8fmXPlKWtyCGmesifetAcPWaiPrXJ5zpfKYBp6ekhjG5QMAdKcppp1WozFPUpaaHsroHPg49rf+kzJREygxNSM0GBNuJuSOb4t4xv5p8rigdOjBOCaWIS4PFlTAjOrihKhr0HMq5psoxqZU/OG19J6jNC6EkKDv3tVoHosrLiGAGsahRYF6liGVQIhJEtFSYDprHWSZQwIWBKCJhEEEDioJEUBA2Go9Ua12Kxf/7sGTOgAlOZlX+ayQATcEaj8GAABT9a1v9l4AIxoAp94AAAGAsQ1SjWZqdIYoobBB2VzuNIhUaFu+XOHnM7jAjWftGZnJhhrMsKsB6zXivImKZkn3qtKUlaoz2LTOW17uExRsYxb4Zn8aE+t43zSe/3i2PW0XUXMG8K/kvJP5re19blzq2vjGfu14Mv+sZtvzY3jVdzZmpDhQ7STBNLqYzaK7mJn5tuNiRJOSRW8+MOMHjyygi96Z7uXrqSyp4FsnHNfVIh+m/W3/pI4o5z29HqX7rFYt7KUpGRUQgMgoABUT685nWcZrCkyy/hMZAKpWDjJjv8g6nKqR+s5TFmGvvemqzoJrO5ap5pJYn5tEVRvWQGzionsgtlGgZnlH1sXZ5o4mi7822n7O+KnZ7y+dI0zWktRxyJwcw/Pib2wUealOy1e/WFwzZD5jtvMfNe31UMh6Zu4EykSTzG/mafhEKMLlZpuor1vrVWmaL6cLNYMii31SORuNMSVR1E7nJjESBpr2KUUdOl3m/LK6W7d9ot29/9LxKIwBjUV/tqYWp0s7w8KYiABSAAoLWRyRJKIyg00hyAtg5hhCEIUBCgTPy8cbZA199SFRwdBMHssjcrOrrahqV8xUJSi7FVtjN4kIxZEiglFlziVELMjGJwEJIHy3QCHRP9bRqMX+fV2arkUc4LBJ8Ys1qNerrIf18afM+PreHdqyvl7rO1671vauyflt3G6xSDckYqkFwZnJTSedm1JDe579y5rSiDFCSkQSmm67A2iKVsPPAQlEliN3tsr95f697nLt6LqPMMmVf6V//7/9NmaeIVFAik0iliPBQ//ugZM0ABNNg1vsJNSougEqdBGABE1WjWeywzyCogGk0EAAAEVAHGMRiQ5eIqABAUTFhzCBv1BHbUuhp6n+Za8U6Fpo2BERssgAVE5rijtEoLIRE2UJBOuTZNdeSWIGHNQmJtQEcX+tl+kWVkPDRUM5yOl7i6OAkIk6o+nnREYIhsLTiImsojlbz2ompNotzY+RDVD7LJtsxW//vqMXj5tmc/NdwN1vsPBenp3USZG5hxfbfTltyUlBIkFEp0MEFOsFwgTHIJqmXijg42h7dnFrbaH109skx+pmz61r3+jLT/93TWuIg3ZjICQTqjvPL0/TFMvIFZBSIctcT+mFCcxIVOktyyFzmHsyhCMrl9h6Esm5CVoC8IASubHSVRq1dSicsjsXEr65a76ttCYS1x9brMHr1hqpK7FWnD1pQe5F91ujXJ1xeIDh1JtigOip4qIhLEjyjnPq7lYqImdlr7m74h6rMZWKNOGv0WdFj1NGLZUrHMo1zYwWLEZBck5IcQCo9nGMbxMHPN7ENvTcQUUnKdB4BIQicDdhYtNz3trdTjiNiNi++tuKLYJ1+/zX+VdajehSOt69H1La5UiSAmim6V0CwYqS8wUUQEmEEDxhoJQQHBCAFCFiUEKau85AWNlWMSoTJaRR8Nb1WwwOWOjd1c3Vou1cMLRGrqm1WQNrGopCE6D8gohUj//uQZPkABO1o13sJNFgvoEo9CGAAFMWjV+wxD8C6ACjoAAAAD1ajHMr9uW0ZTuj3MuWl402ztk/Bl1nlyveOneY7Nu9mjc/zKa7ndhtj1LZbM/8esbdz1PbZM3RddJkVImNV5itd4RmpyYGhJIpFTtAbNjFn3WI2Ip61medUlS+56Nact01Xq9HVu2wxYiYF0UK1n2wiQetQcA5JtAyt4iFh1MRCTSKmMJoibjmCRfw5GDRD4xEBb6hoOWg0pS+FO0J9B9JgVxwph1KTyleyX09O8mHSwMzgwceOagmJZHXo191glqGEvvjmmM0bhPfKpJAgCQVZhrzZiC714wxNmNyvZyMPcHpl5RSbHuZV39c3NqvOx5avMx5dW5uID7ImaS5aOudSkmrcfdj4ixmNv2XKdBO+RO/fX5F2f7Pj9nw0epRii0lNUhUEhYaLJWbtVucbFI7eSaiWFmCxpRxgumvxtT0ehnpVZFL2GythoOCrgq46fWFoNK1a/u663JdUdSIiGmS7y84yyJGDAOs26XoXEOkqPuXZAyxqBe16aFtR//uQZOaABJVZ1OssM9I4IBp/BAABFEGjW+wwz6DvACjoAAAAIRkkLi66WB1FUDBeN/ZPaRLPQz1CSnqqFagk4dVxNLKwuGCLBqHDUmdEFkpFN/SabJnnxbtRk1fiPvXpjloWRvXLVa0Xh09179koxLMnmP4a5lt/mreTWOZBRe6z+MnN8zmVv1F1XVUBI/K103ZPc3KaNy3/jH2XEbGspoIokpSaQQYGSY4WIpnl1lGmCF0nFV7/T7MUoRsVO17kf9lYa/X/6YAu9My7PBoQgASinOdco/mJbtI2mZQYMOwoyDmluGmDo1T1o6pg6jyRiItdmWyyGIp9GJaRJnRVZlE5ExZaciJK1JFp12vhRTH5cLhNZg+srHI5ayBfZYiJGfFemYfrozc1FwsTFMggVgraqDI1K6n6AggJx63iM1v5uUI8jMVjEcEQPKyQzMnRXCQ1oBg4hwWuqhUhK0ylhQXLOWymEYmkgAVGnTRoChNMUTCmw0Ihp1BYzZYHIDMd9nEcU0J5j7aGXjlv/sQKXq2/fpp6xYdFMQJBALmGkoAy//ugZNCABOdo13sMM9gtQEpNGEAAExF7W+wkc+jDgCl0AAAE6AV4KqJSxcbaXQFoNuEABooIb1fbRXIdOFvw+jwXC4XI+aowtRGNrD6k0yRE+ZKQKK0ivxRx0kMTShVQ27ny2eCiDJmEsamJ3RK1OHsKCISDsh2WweGi90rvDWcRashYwQBjjaGVEsiRP8PzUw8lTSVamXZPEWjY2Mii1hNOBkjZh5+n4xkP1FjYduack2kEU0RFcjTKmjoZtcNATEjUXyT3Ci2impzWanXppRV1vMKb+//f/4tZd/jEK1XMPcMrABjaJl5lwEuNLEcnIEPyEYQgEHAgk9lC1OVyMrDcIzYCBmdpj5UbJmDysdjOkDTHrRFiWGkFi8duE8wPLHB+7IZyWxlVBpE01LDtR1FFV3jGmy9SyLXEwymmUtPluU/j/dnfWOxKRB6osXm47x/h7NU5rRNHT8aHxp2W+r94+pNsVGTEJMJbJ+Z/i23ah2vPp9b8O1pVUJItN0AosXGHjbH20L08yf3irVvUhi92w3LWtirLEb+3q0auhab0//axn1XaZoVjIgBEJKdKvS1AzcVGOiKLFBFSqqA6LXi+yQ9GWrvOY13TytznAScME6ZOeEzZKcLNmpCbHYk3S1NH6yORrBtw2YbYaJEklW2ZTZp3mvHrNa5PJUs9v009RlheIOMABmLR//uQZPmABNRo1nsJRFguIFqfBGEBEwWjXewwzaC3gGjoEAAANHOmYKExB7CAOEyhEFxQhE0IsI5B3gxnHuURZN4ZeZkw7GEcEogPBCK8dnD2MbkaIYdB5OFBDEzMzJiRBcUFh3GrRHKvOnVlAHAr36LQCsAoP65Z8g9ybfHqrYp/X39XoZ3oZT610rQqT2yZkNzIA0kW7jEwTOAPBcoIERIEtIQC0EI4bC4kmGaNavuGpk7UTaw/89KYapiiBtjD7KIEjs92cEBRABkeZRRxqLechK5hnReLaRLooHeyOpuRYl7MeaJTdPJ70aLRkyTswI7V6dRgide9VSUm81ZeC01quF1CoRqaSHdJ0LS/UyoSvKT2LcUsrbFVoSLTKiMbOlN2CEtPZyeig6KjaXZWlNMGAcQDQ0VDNNtop4XCxcMHwgoYwy1sZW0zyp5V1m7v8a42pnduY3/rFurpXx3/Rx8swVWqZoNGIBMTSTtS9BbCGBa0daCGocDCFAeNLHBpWKPKqJXoS2xrXZYySQwEsJBwnXnCWD0+nZPbXCW+Xw4K//uQZPCABMJl1nsJHHo1gDpvGEABFKmbVewZM4jCAKp8kAAEoTmxGs/j75AohZMvSoziwjBO/3tu9H4U8/ISGwH00ko4moKi6gEczGbD+q3L/22nT+u5zaLJ0hZzDTUDmItuKYSZ9ESlHfVILRg4rflTp1+LyrvKgerXw+rg1DUUHTf9mMwWSiXLADDWF1LELiJ18GELAIlHlkpLK8xal056uq4xya+sAN9D9tP5/v99uudh2dhIQTbhbuCa26vMDtCxB1RjMmEsgLhELQANYQKich+XBXamNNtlfVlCqDKA6QqIQdLFr1VChAqeiIiZGDT5oZwKPM20ilGKFXWpNLITyriFicJ0nHJbD3Uo+UsNIZKwJz5LZK5Nk1AhdO0t5FLIf15dZlZlaazUUqanTV/VbSyvrMo6y+LG3L7kMvfkWZX2rpgqVg0QjQPwaVKoERdJGg4Gb7bHb0bCCUSkQAowCANCiROdYszbdY11dT6T6KbFSGraplDM1rou4ppvs/k2i6P/+u3SZmlTJBAQaVsXFe8OiYCGRB1pkAGKmIwk//ugZN0ABPBf1fsMNDItQBpMBAABFOGLWezhIci+gWl0EQQEZ00gxJRF2nqVA9T3TMBv/TzsrfLECw8qMLFCQdaiKLmujKn2EkaxtyFBNOl1VEOST1S0XbQIXx+U5EpKDF1cKkj2Ssm/K5MYD02EaF82k9sqfp705rR3jAsIUBddOAlTORARuaV3Fh7EcCMGIb1DloRVfrPlIYYVj+cMYgyotU6/DvBDvOhEEgAGgNjAQFlB0o5i16T9WzEr2qTPhTrGj5K3tm1o0TCb6Kh6EdNuvoO/tgVTgkkT2QEoSuMJY4VMzUO6mBAOvB76LZc0DGmaSY5SJBISMpBYFh4QKvx5VCcV2vKxxgcA7hEplUOzUECwLCcVIUQ6ufQA0gTk54rym0Hy1oro0aBJzM0OrKj81GPb72COBvaix3zitWOZ2GKS6GBtZGgaisi+7ULWxKOgVRP4vdZDK0i0KT2A9ljN1o9VkNagSzcn+7z2EdcKOq5+Y8yvZtlktEEtqTCkDSkqcxhhLhE2Ake32e3iNN4W1yMVkf6E7i2p//+P/73ei3bpnIl4MhECWki1DP4ICIEJ0Hw4FuD8pfKsCJJiqHu+omy2WtOc1ERIQTN0uDYqIWbiGyUGmbsnbIQ+owOBoFzhCWVcje9GiR8JchjMW9p4jJjcx/5SKyenZ3RSoaZgtl34dRBCenMI//uQZP8BBN1o1PMpHPg8gBo6BAABElVRU8ykc+i1AKk0MAAA2dbO+IrCkEVjUOTDrS2jtm2Utoh9cv22Z/utO1FxNY52esY+2a9nv6Vlu1b47fa14uobdY10pVAFhBNJygdAEUJJSH1DOxAG3lFirnUZZOSYUIlXqJcwj8INd/vtvs91i/0+iFZ1ZiIRBUjttO00qnXEDgnLxgRgPALUTVKJghTLBAJkjUWEODK3YaHOu5KYAh4dBUXrEDYrbdQeghNziukbbWULqIk0mknNVraBN8G6XpmZ9iE5aaUc1V/pzZVy8d0qi5tdCWJTil7MkUxAi1AlD6KLDGLHZAEO7ugj5SFvXEKdUcXsTNx3DJ2MScPHLKpxTST1zsI8/tgnfTlAmciU0mSAlTSnKcKQwyPirH3pTakw++j/1/39C80vpNJS7Oe9a9f/oOtUENlPENWEVlUlEAALZBNIzJf1AawAkKoBAxpgstHB1B1aPSObI15u2vUAdeaGB8+sEblNjLyqTRUOYiD0HAIWSyiaI8aeluWkjMJyStqnDakaO3Dp//uQZPGABNho1XsJM9gugFo9BGEAE1WXVewkc8i8ACl0AAAEgiNQCCZ9TjlugWpHpqS8nFlZSkK0ofiOJGEnUxepfbN+vuI01XU/v/Csjf6je0tN/Oa7T6lz3jTOjZKEFu0u0J3uIGYroZEpW9FnekLoKaIJBKaakwzFlKPjS9DQDZVU1+XYuLxpmo25zPoDNSjo+JNFdHmfWhk3V385q5i/G9NtNa0UimQkDLU5eALn7MQoMjL0oCRqcCipEojQ2qOVMKQ4JDRt8hEQBOVmidPCfWojPvtAuls/62brnF4YNnqRO0sio4il2sL8bcT1HFFW7Y1ZEbGDI7qOY9ogc6ShHMqMEEYGQ5FkHtSDUGKfQ4r23nintZ2lPW9mZ17l3Hcqkoj0id9HnDUs8zERT/S5VIR1iFey7iUNV6kymSChJJBKVPAusFBRJoUsPOJs45DFYypiOrT9frv2SIzibSJupjLyxam7Q365VtDUaUO+tblmRUUiEFyNt4ydA4gqoYKWcIFrYMqAh6ohAiNAZceXUyBq0Cvu7Dt3YD5KAQgB//uQZOYABOJm1PsMM7o0ICo9CAAAEvGbV+yxD4jSgCl0AAAEgGSY0iREVkLbaytkysKDL2kKrGU6CJV2cZdlJ5mbWB9xj0MdIlDrxpsvSRx7xLWXjEn1511TjSc6eL/iN1/FO/7V3l2+ZG63v4767Y3lGdx6aZn8o4/bd2bOkbmRO1DU9OVnv8zdx5AnHJGmgSyCQoMDoeC5SUa48hSe84L8Ueijpi3Ld9NLtKMXvulE//XsdI9f/+7RMEqsZGIBcgQJ4W9aAGZYsASAJ5fsEALSjAi9DgpCMpYa27cHAgWDGuj5oEAcDRoiBQQCjojzzMmiRCkCBAJzwwQDlJNowQkZHk10tlF4MRkmQi8Jp8dcJEKhInjHmGQ0otzzYKQPsskUamSsoUtPyx8Flpv58WdD79uXmpeIYts7LmubKWyqYU9a+yzN2qfT8lGQ3U9fKIVI5dRBucRZLZCVkGwM0WSx5ZL4yi4EJkutS22L02OoUg+tw3rp7nKZb+1KTpon/YrVPIf/1pW7eIk1RAqVjTeFRKVAABBRp5iEJBXeIAg8//uQZNYABLxo1PsJNEAtYBpdBAABE6lnUcwk0WjBgCkwAAAEgMuXFrTaPsvVMz6Q1JU6MnjT1ROrTVL81Akhai+1NSIC5VFANrNqLNY9FFMrAMLIyYy5zKNdDKsjOCbGqJbJqBbWkdznPvlkGIT59VixOhdCM1zJ7tItvFKtSra1+7XX1clZGSi/3TGlPzbQyEN1vrLSyZm+cjIfEjRZHWqb51bFEJ3ziDiaW3rcxXIhmakZgSSSEodgtdIAgRUDg0A0mqMQ0RefC1Xo/5H4t307vUdKPrSqfGLvtxf9qls/fqp2lnISEAFESFDYcLifQyyjRUCF/peRMWaGLQBXn9WK5i64MXeXkSFElqqNlhx9xw+OnUIAE0cjyGJM/bIptvXLDy4qnMqjNFkC8nqFS6CKaf+eq1eTLcU7qVKo2ZwjayNnFltRKKMtiK08+xWPNSajND2+/WedyG1my/j1tbHtZ7pndPbtQ9FiBMiXe1FY27CLI9mzn7NQSeUGooLhEVCJMCrVcZBIJNiu4MAjHqyRyKlnKyHusH599S/i//Yc//ugZMsABSFo1nsJNdgzYCpfYAABFEGHT+wk0+kkGKj0MI24+DV/1dZZfu+zUgR0R27lhlD2XhhIuKGw2Jj8ibaSe1w6TUoIkXkXXInFxiqlqrpYYwICpmUnBWzAAaMQpVTM3RaaViCFdzYxk8QXegGUVjcQqSRnUtqvNSyyHQnSJU8IFmMAESsk8p1pVAAUjbEECNCkJ5RNUj2ZxXUrln89r43N05XuQur9zihfj01A1N2tIizRGrfNwUbWSky2eXSBMQIxtTFvaCY6BIsAww6hlZyDYQRg4wZuOMCY2p0tI5Gne5ViN0Yg+NdMgc0rEhmBEQ0WAoNJsC4ZBIPChY2uRWQGIapbiGlSpOhjb4tuphcUBEVXEwyPpe1X0tZ/10zEdjNp6D08m5mXlSIQJbYJUCpTeVOsyPHnEHi9AO4qMqoSZLUpoqOqCQYsW3Dtlp0hkMGxOVyZQamDaIcChEywTYSEHbWIhhiRNkMR0zK7gk9kn1tRE07JvjPEKqBz8vz9KZcow2P1pxmiLcUUQNSWo7kWtvFEJmchJipNCWzGCritlQGzmYMOboFLAERFPz2zJtgXBJmlMmodNvKcVjkb6wS0VUUkIkIczlnFZUMISdsLVaV0rzen/pqneWu7FRlJeENCcHw4krGCJiyvMSQ5aNKHZjePqa6r//4yzXNPeXiHU2IEGUAV//ugZNyABOlo1PsJHPg7YDpPPSABE1GjT+wkc+D0ESl8sIggBEBXa0BDgHPR9RRMYTEBoQYxl6UReZoK54KqLsyfWGKzgtbrBjSFoaBAPDCAWM96Jxc0giqCYgJR4RQC+qZX1PxhPSmOGjw04A1wekQQPlPHaANIY8gd1ZbDDJpBIgLHAh0jy2MQ8lVUQx5RAGQTiCeenKVdU7Pibo3CJIqLtAXrEbKNXjkiGtR3YpofWVje6nbvsYkr0mgeaIz1TRK4IJTQBgpbRb+2/3W79kDiSSuWfL2X84csjz2i9e2CalUOsmaMZHI2eMaJmFocNRijPV2d1O72+aRt8/Y/9lbLISGggUmkpMe7teObQeIdAYlpLCACSiHiCJL5I9e7aMdlxfg3HYBYbrAgDJDZUWT25658WC4pXRevaPDxWgX7E6py+sHuaEIqQwFv7M5EH0S5hJqOPibNUsVmCqYVmTWVKbq7Ug7VR1X8S6eaps3U3SXdWs0vTmpk2ityTEVXFQ92nEjaQVZXkhHmWEVVnixsVp4y1apbgmIZSASMjhSKBLGYjNCdA8CMYtA4VCVkkqfRa8zIH9ch32qwI5yRVTRpLram2hVzp9CNLv9n8t/9aoimVUIhAJUbT0FGUgq0Dkd50h6iNYscDSVjY6mulw6T+vNT07kuaBQiBclZXbRzZmULNIxqLZ0s//uQZPeABSJj0/sJNLpA5co9GCOJEyWjTewxD0Dggik8xIwE0gtoyQlCdBHUCrquUakvZzoGyFtAdvrJb53iZqeerUuSJRBuJxUMwkMKKbfR6DOtoDII6BiFgmpklRSPBZe6mZisAualpJIwEiNmx0N8LXOGtbJ/Kcdax4PP6CbpQSRIKJJUjDGgzknsaGi0wOJWSm+fFmXNcd0sTXmBTG7sOt+pvyTx3v73Iv62KWr3ql4pmYzAkCCAVE9QExIouaONWMciETQwrHQQNdyqyUb1vU8T0h6P4gI7tMkMuEA40mOiKgEweWL3gsWWD0uKBDUK4rMpDmzNp6Pv7MZTKV7TDpY1s+X2tTGLhvtmNubm6c4ITsBigzWS5dbMS9Y3+lTMZL/N97l/5m0/yqURxk/nuJ95q4y7mEd/bG6v00z+s9L7DNh12ikzwvb37Z/sktYhSRSVuAwgEwoKhSVAYvEoqS1j6FKdLwuQ6bHvPLQy/jfWWMv38UETCMZQ8NkD9NNFNtiEmaXLoLV/1auYhlUxEpBlyU+FH0EQ0ZzkdpgB//ugZNqABJxo03MJHHgyQGodCCIAE6WjTewwz+D4AGj0IAAAay8QSM5VMjAwMAtRubirVYa28QoHlnY24U6FKWSQjgLBNmUgJE6FCTqiE+TagJmlMKek5q1cZNyV+puIiIlvZtpMyaVnHJQuBMQpszkaEpxUkAIKwJA0MikVJN2nGTWMokPYGFC0NjChB1MiNLVlGZqUMo2me3qr/XI+XIURnBy8mfRo5xj+vaEN7mSqF20Z2IxAS2ik7QA+SsQ1cMjyAUQTOAEERqWWhFj0QIBB4PT9TooSMfRQmPe6Vd688npf62+bSeARIOKkqok6t2pVddZEIrIhkE5CpKZuELLEpBASVRAAERgDFhisS7DJRYkhCJAQuAVy0qqPh0AQTExIwBgYVcpKlTC0CihdHh9yEcYIxai51GLQkKie0UyqCAvFuCb0NyQJkSGTSUFmQl9nFZxnCoQsMAgaAwNUoRAEO0Ch3NxhBORjNm3uEmz0EKTtVt1RyP/1TqHc8ijErGqyrFc/11Nl6RgmclXAspEMSIyFAokqUalASGA/4CYUtAxsa9CHpaH+j31ECQUnrNCl3ex/u/ZR/+FBOrMfoRnnsLqKmVl1c0BbaduC+1V36KDFohCEWQzEGJHRjSxpKPkrKoXSUWpo28MBP7D1LDcw/j1zULlJB0rYiiWkcZXNNGnhWkkHOflK//uQZP0ABQ5o0vsJHPBCYLovPCYQE2WTSe0kb8jRgmh9hgwIiVrw8qMve1ZLx8nLPTKy1kEC2zMxEuJCLNhALgYZHXxuJa31wLdynML3oXkK/X7tytSzdY35XGRlIpWImEIarUV/G4piNgC1VHKxr5hTRGDnksQmhgSCbCcl8RBQHJKo2b0JgwHMtUWYgTguIe8bhCCBsqGxGUl3vEhdH2aC1JoQsiq4u2tpVtlaqMXdtZ1LbFI2aRHZTABIkFQxQHhB3C4QUY19yzaV6SzBd0raaqJ+lwCfhnsI7GZIx7RHFEsQRJw6khhZMUzoorboScQohRJdEazDNS1r7vHvbzfEXOeOmduaduqBAW5lzoQFQg+WyOtoHJrWzFPjLKan7ZuN5nIRzM+2ennfHmvWzm79mHvfXXPvO9I7tZW+59enud/uf1Zwg2biETIgSTZKdekMIFjQJxhIJxGERWUJ0Ys4obDyUi7h7Brhr2AyveHp6zQ22zQn91Xo6vFtXRv20uXZkdWKiFRWMRCUiTsGElSgJ4RlgcUIANx0FAFkhGUg//uQZOGABLNo0vsGHXBBYRofJCI0EjmjS+w8zKD1gih8MWRActYti/DYlfwUwa4yCSyGLR2KwUw1tI7KJPLCYV2fHFURxEo49NGRhNIlcw7BKjIkbAqcKVZrzLcIS9a+OU7sbyzZjdLKJagVMl4iLqSR1mhzWqwJF7vDb5Tba3tdV1Ptl7sZz322liz63XhRbir1u6KtRRjMx6za3Jz9snch8btXye++3rUvbtqaEZmYFIsk1hZTFmGqDiZogk+HmF0nDRRsaKNLGXRC0+qb6N6xjCbfu6n+n93/QoYR6RaprR1fmZ1whEHb9bqClpCogA8ZqfDo2svKMglgMIiCrhl6JCaLpR+QxB+V3k4rPrhwyFxGia8HIEYLrtfpyTGkBBphw5U0LUECyCMLnUtENWhZg9BbrxXVRiEgwxs2IqAQCtFGiuIjXHd0FM3n00NczoUs9SmaZzBu9J0GKjNuKYQiH49XV061sgqEE/9N8BuinszLrDKYkBKTibgzLxYGpQozJR6+9EzvZOzML8jv9zKiDMj7KWcopG2BlkkhUoVR//ugZMyABR1o0XspNTA3QKofYEMQEflDT+wkcYkFF6h8wI34ZJRMJJlcU/U7Sdi7fRp4t/1p1qu+qHcSBFOIlMoBVOWjBZJjCFzSwQBlBGO1FWERBosKxoPr+ZuuK7iz1QFS6pWwszlLFrcVidlz4brISGiI0gzg2Rg8NILakcIUMVUKFS/vbYOsp5/k5Ls3NSM/dXuS+wtZmcp9OJhzaLWpwftM+Ln7mWRGq9LntnaTGag2DGZpUJp1DKkSZ38+Lm4c4diEGPF2bMdyQ+a+CuZhoZRIwlNZLgdDt1llU09/M2Q2Mz5si6u/Mp6T+XfnfSzwrUbQodSDMQAQ8eExQHAqH5QaRj+tO5vU/iXt/o+vXmJnLyZZAFFtpJQRAflVhjSZClxwW0wBLL1gx5ERTNYqGL4MscyLwzI2JQmkt1yyRGsyAhHAUhk0TSxpBFRVNzBWRukgoTm9IINrvnWQggfK55Vz86qp38lc1MXuFXldp8NkxJ8IrzydktJ3u9I6IL2Q0XVPnqZEZP0as0hc4RdhX8Uaa/tCd20UIsO9xhn5RO0H61N6qxCBJUICiBBQXGjbpS1LALYNMtc7auzdqxKa1fCOyyF5lRclKsdLs7gyMkKUEB5QQ7pDhki9MMo1HkrJrWLu+qsc+pCRfvuEWxqbWql/XbqYZnUxAhOElQiEJxNAlcEKhRYW//ugZOmABMZo0nspHdhDBRpPMCNeEi2PS+wkc+lGFGi9gI3sUnqgicMiOiwCAZsgTq01J04CjjRAGMGBhKJmR8lDIYTIAvaTKMeSIJ9G033Ko8ZiuG4MLCa3mkphVjXoEbGqSIUQVOvv5ymnf5YIbSyZI8xOdbrKkfaG8/tDVMQ+s0/Y+23qy6aPML0xbIUVIzLrcqkbp337ttjbG+n3G2uZDdNEgiwuqUBi1RDUyIQS8W21ywDAMx7q98UtNZgf4rB6ZHZ9oaXKQr5Zq7cTK5ITDECF0qKQM/39qTwo222N/qr7rmv/t0XmW7urEAajRSrAyHoOcF5iOyKQHeB6UgiIklK3Vcgu8UpTxy2mkP+kBGL7JPCkXErI8VyrOuh6M5Wrk8mdpVowaGTPvROSNc4UFyWQUxVISxo6K0+iKQnut2PKWWKKNQL8E/aTSYbV+i8fMdnQhsKfzcabT6+1/+zxbM9vTbFgVH+1Nyl6hUxX/Tdd1pU7XR5rTML1n7+H9R5r3GFK1saoRiITcbcwzpYBYkoO0uaD87tf0TdMc5mLtbpA7CzA6SF23I7G9v7///7OjfoVu2mHZTIAW02nCHgBaq4ydCH5AwpnAYRoDC9hftkaHlVragS7G4LoexY8LlEUaeJ2FkJIylLtspG7IGmEUn5JyqTZUHoNpXOL2yhhthqONPn5N0+r//uQZP0ABNJe0nsJNGo+ZPofPCNsE5mjT+w8zWC/gik8FgwItu0S8eVkvqUsbgJle22SIupNltqbp5A58qcmZ7Icvenl5UikrFg9Sm/VYngiySLmZyH2XvztsL+kR80y/tDyhqZkIgQTKjToEAwrkDAgCsRC923eK1MxYCmYidRpd9rhCFlGFHiwe31jhS+xm+3/7L/qAOy//jk1tVUq4gADTbahK8UGfFpnntS8SBIscyJEZwu20ia5sqg9XrJS3oTcVVMB+zZYUa9fSF65pteuhnXWTwqmHNwb+O1WtsS5dGgR4ERJ0qhBumrJwjRpZHrMk2Kg1l8cpP6TsnaKRWiEbTpSLZjtms1uyFf5tLxkW1WZ2zZrN3xH3UKvpT7ubv3TOgz7bFb42CsNd612J+IRRKTJOpK5IQRLbTo6qApGbjaB0My4YJnjNl2PYTFr7KUzNV3ohV7GMiQJWmMJOhZhtMVvf9H6L5f+uUI9+rpV3ahWdiEg1LJHBMInyHrwSobBa7zRFBgEaJRxAEHHprln40/SXrV4Jh9uO4CjMPXx//uQZOiABJNo0/sJHPg5AIovCEMAEwmbTewwz2jyhOh8wKRAw6ISJEgWaoSUDQFKEx0PJOnBMliyxBARjpGjXU8oqNrFR6RFi6rS5LAljaedWMaSWk8w+D6paNs8lTZuVZsq1VjZ582bNynJLD5Ainkp/rlcnzM5O25GWSqTacJubXCbUEoQ2SVdmmegaqkyRBAwCEAyoUx1EjESKYxgqQQLNEUIbhjLX0EDouYX25INDzyQcs2OskluHrHLL1vK7ibnpJOYzUjUrb0MSEi/c/Qi915lFIQFu6jIXaqaESGIlOPBFnZIzIv6nis15XUamhgy1r8YsOvMzToR2HzRIufUY4paKmygCbBsjektqcsO10VY7zVZu1tSkVXxDiCVT3xcrK6r3bvcdlLu2TbDTKQfWbixivUq4r7zZYDUnB2ZFDgIoHfdHwrdFoT7GbsQS4kIpbCyMnmXl78WEXaxW8MlUaeQfJ+etDMBKKbUTd+PXp0WQIi2odQaRwuvnj3Z5HF1rx8jyoeUr8uTuvHT61nafiDViz+39vPPiwnsLIi1//ugZNaABMxo0nspHPBEQHoePekBEnmjScykc+EvoGk9gI28sq8XweFAmRPx4qKVa+/2fUrt3NqWQSDcttuAITMEyLDjgZwFCJVKwAAwgGWVSfAB22eN5YYdx3px3nVjkXijjQc6bTWDRtgiJ2TSZcKLMkRVGfIi4hLI2B5UogHkzjaGUfJmaBSIWpbQbcE5GADEwyQjcesfIgmAWpkyDR2QzhHiV9yTPszRsPQ3lDOITGIcH4cyKKRu7mxEP4i2CwQ8M0AYHpMQ7VgAHoOfg6TvishmEQBJUTcAghSoVIDmqVxeDs+IVDbwOQJhJ0Yh7XwD3gLfDiNfLOvdFA0eGWmQbLO+nuK0tUj7lrepyuj9dlO9nbcupARL7XKmSArOwAwv0RPMA1UlBTEJyREJNBAfMMOXVF4ZYhisZswOzMKisVMEhEyoSTk5AczJUScWWTIyNrOTQKubRbBV0JlmaSluPVg9EshhSldOdWsm7Wl8acJJWwUBkwyCwIK49bLSFD3Mj87b7Xp6iFok7nqrqxm3HOpeIbs2mLJUCERTQiyMhYtVT5kGvbuYRTFASoknB0ikClCdCgHMqgliDTthMdbFggwKPihRFVZpqfFLLHUwacIxrRRs+ZpqpW1qPHbv6bdO37kfTc3t+odzBOattQLNRTEjEhSKwKCy4UGYyl11bmhrj05yTMWq//uQZOqABOBl0vsJHTJB4SofYYYWEoWjS+wkccD+hGg895hQls0A6MXHAtEOsLq3j0WlWsKgGKT07sdm2FnR5y2KvFtcbwqsYW0rVYM4VUwSthYthXCysXBrnKAMHFPSNGRyW5VhR5IqCaCDnSFjHVQ3p73s9EVmKm3wvPuSq9Snmc6/FFZ/JtCM4cRKnQd013ZCYCtU3jdUxOTTeSifiVOkGiKIgblDgXBoUvHq2BccSCcDxdQo9gtbmkm7ppJNGd9/9xKzkqd30/LXU3lO6mB3s2IpGkIMQx8BRYKzwq5HFAIbSRwKbbKX6Zw+7OYIYO+1+fq1n+qVp6DY9GodiD6NmgVzWnK5fCH4ai2qBGXBWGINth12B3Ng5Ne2lBGGg5pgzeHYSqBlgC1wghQJwMLpuxbOAAg6+u7ZM47mGB95HLGMETSpI+5kCjjtTjGRGqb5wrXeocjuYs2PQ0kI63OZ0AhGp7tCISFK2pFc40tK9UZ/M7GQESQeIHwkN57G2KMTnJeRlvzvyq3HnIfqD1fKFJBIsEG1oKlmHV0mzYCI//ugZNAABG9o0/sMG+g8gMoOPe8SEwWjScwYeKFJE6g88I3gES9LkGqtvOcgNfpN3llvMj0ufb+h3f26dkIAJrJLTWVF51ht4UKDSrVEB2Hi0GaJFomvQl8l+uFDVsLS27v5ALYYo+8KmZddtBQBWntlyclmGoLy6CQwomgIbacScUCM+KSw/c0L02p5NbM+RQwdUqzLxRDrTLtTrSKEp6ibM4TWe95l/Ir5/8/+eqlWPjf7NKHuAItSQmE9GEsUgS2OqncgtpBJVWg1BpO227HGpRCC6uKu8vLRTAii6XJYCuThxMgRUJ0hogUTFDEETQHDT61sPAMwkrM7iC1CkbFTYJoUdHK/2DRnJ5lpU+/I2JUz0WO9Oh7trdH9Gd/d7srCAmmp4OlUEwcjEKM0A0mTCR5B8wBcvoXWBISwqitlpLNYIbRX4kALXBRCYycbF6cY4Dg8VZurCtZuMORp/aWMyqXya5b1a6VNiExdkCk1BnqkrG3vo5bOnLNvZniWZFREVZbHG2iVGt6KV0vqNPuRPfbzcO1aTQo8fNaxKztG5IMFrhDSKyigP5shKVtVkVxSTuNGlswPHs0KLAtMs4tredfFMT/GN7zXO9arNnOK5v851j11EYYzf3oUhAApyayG5e/Sw8FNJiQIUIUrCBj3Gpn7lfMs/7zu7meA7TcpdfzPy8Rf1GIZ//ugZOiABPJo0nsJHXBGIOovMeIkF22jS+0Z+SFZoah9gI54JawHNgdEUiLJOnIIbgTqqBJI5tGDHKDEBSGQaEJaMGly74vkdyrNr8yGUAAMcUrMmk0Qly2QcBWgNeBAosIkrbISI8PQh+IiRN6miO1Cn60+0LnxG4mll8wcVlhWhnc0bt9nGomWHktZ2YkIprCWDhBPo317PnN6yt2WqfR84QkqxYk1zvftjj02fu3bry/sTbzX1iXwXp7cRfrNeDSBGa5b/MJZjSQMKiiXIhIKxPSvmXV+1sMKlZnBXw4LbHYVqkaE6nrubcu6ZtrNcTZp9VrGpnNJL0xXf3nXkiV9Z9yRgIECQSTTpKBho0zzXGtK6CjCzLPWiP1fqkYTn36fqei5NYBCRoL7rZ1SkBINKEwDc8eg8lniir3xZ6DbS0TErzKGC7W01f66uzu3nYwBJxIqMH7QdAI3aNhwioQABiWOCmEQkGkynud0Wi0H1awBIgDk15JHHFqR9e0UXozCM505dZgYRUevaGtnT6Gsb5J1e3fYbQ5J0Ndw1z1lmcQqhDz9utfq2TKZi5a1KNDJN6PKaq+cvOTqyxJqD3Tc3tLZaBcSrkwpIM2II2PlRlR97WKoPoxeqsXGhY5ydstKuHyg2n9xfMzfcuqt91vtx/d7L11EgKcTacAwCA4EKucGPNZE1GWu//ugZOAABbVo0nsMfPhMozovYCNrFMGjR+wxbeFPkOg9gI3Yq0pdhdCVXrG7lrMnZ68Cz0JdYkwx5EGbEXVy7QwwHRSpjzzSojEYxTidh1JNx0c1rXxbOW319dm3vtX6NFXc3buHQBGkDS3ISADFyQ5gzg0NWHV4MjHaFhCt4UAp6QC3GhbFJXcljM7tPH4Bls1D0aiwUiGMYoooSG2T9LQJkfFstIJUfz7SLhRJJKm2Gx40155SVUutKXZsvm464eV+YDLFq4r7utI1HLUGm6WrieHeLNEpjd40uPS88o06QIaucYrA3yP3jW5rtib4rctRNXa16NuCulXm9IlN/OfXH1aPvFtWzmn/zrO/j6+5uzRRZddlQaEAo1RJF5K2KZqZGoLFjZMQhfd8WAwnN5GJCv6lJuOtzze9Ime1JjbSSYNfZ7d//umfT9N6G6ee64jaEWlkm9KGnE1NN7F3dihXf/+/c96dv7tvtyoZSByyNrQECEbjGQuyiEAlKBgc4FKgBQANihl6k+lzupKiAPxWOrJj46mCWnhKLStuNYcwXK0tuvKsrjeZLKSrVfQtP7MQWvl1S9vqTauQQrbz9/yP38rSOWs1b/UVwwMnrqE+ss3U6fe6trW7J61/n/vTstae8aX6FlaTVa20WsHrqAvvBGuiosUsxJcWom8+s+zPZDHad6bTtOrN//uwZNQABZVoz/NGfVhVJRnvYGZcFU2jP/WGAAGCEyc6soAAcu9mXmb1fo1+99z2Zcmpi1aMk0AEBUfYqacwUAIhwcGIR0HkpUflqNshv+VQWD7MFceEVIttMPSZzGX3LTNvTPDQVB0bpTpUUfawOaxocOvKiBQSBFS/VeS1pltlTq3EUPdoGJQYSF27P0qqqKqLpJhHl5ebz4yitVpE1wpHwZjmPXmNRGVCGGBjwEowCgYxaAwBccFEyQ1z0SfmaKlrGaN4ckRjVvypU1Vj6pTHSCiwWTMlh1S3QceIAgYSpUUQQwAtJO05uSYzluG8eSwC53VDg1UB4RrKczfUDpOslbLWSu9Pwy0IBBrXSqEYDJ6sM0jWo8l9Q7me0cffF66dLVrsHOStV1nSXc/Uqvvq6EgrwNNY/nXYCgIVjSuZrNs8d5jda6+tbK7WpuwC3ZwcWNuRE3xm6k8w90V0VU0DmFS/eKMv/CN8uyp2mvU2W9ymW4yiljXMonS5z8vkFmG5XSRmITFqvTSLc9KbVaYxq0tn/x13H90uWV2nuWO4YZ3u1bfP/////////8aSaz3T4avhEIfyyzrRKsFbeZaGdJSUOmRpe3yaCiAADkBBKwMrOMpOZzhplCQKwmgu+vVzPobsxuPYx4QSEgSAkxR2QpEuy+zLyqAxBLklIBgaFMkctHlhA8SXOERZdaauS6Oxllzou1NDIZZRMEtWhM1Kp6ZYbNTVV95LDDoKJKwOALGMkR5YEy6fWkyatnZ5fq0jnQ7BLvtYrw1Vyu3sdSqfz1uznVwzgBuaxIbgRsa5ZS7X6y/W61N3KrzG5rncMfn/+7Bk8YAJfHjMfmsgAP1vWY/M5BABkAEMHAAAAAAAP8OAAARUenO4TrwxSdisO/+t48////1nze9fv/5+P2JVlSRS1MXbdy/Ys3d//6///////+6/+////85//////////PV/tfr91Knc7f/6nzv4i89/////////xLVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ=="

/***/ }),

/***/ "./src/games/seabattle/sound.ts":
/*!**************************************!*\
  !*** ./src/games/seabattle/sound.ts ***!
  \**************************************/
/*! exports provided: playSeabattleSound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "playSeabattleSound", function() { return playSeabattleSound; });
/* harmony import */ var _media_hit1_mp3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media/hit1.mp3 */ "./src/games/seabattle/media/hit1.mp3");
/* harmony import */ var _media_hit1_mp3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_media_hit1_mp3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _media_hit2_mp3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./media/hit2.mp3 */ "./src/games/seabattle/media/hit2.mp3");
/* harmony import */ var _media_hit2_mp3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_media_hit2_mp3__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _media_hit3_mp3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./media/hit3.mp3 */ "./src/games/seabattle/media/hit3.mp3");
/* harmony import */ var _media_hit3_mp3__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_media_hit3_mp3__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _media_miss1_mp3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./media/miss1.mp3 */ "./src/games/seabattle/media/miss1.mp3");
/* harmony import */ var _media_miss1_mp3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_media_miss1_mp3__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _media_miss2_mp3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./media/miss2.mp3 */ "./src/games/seabattle/media/miss2.mp3");
/* harmony import */ var _media_miss2_mp3__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_media_miss2_mp3__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _media_miss3_mp3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./media/miss3.mp3 */ "./src/games/seabattle/media/miss3.mp3");
/* harmony import */ var _media_miss3_mp3__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_media_miss3_mp3__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _media_miss4_mp3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./media/miss4.mp3 */ "./src/games/seabattle/media/miss4.mp3");
/* harmony import */ var _media_miss4_mp3__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_media_miss4_mp3__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _media_miss5_mp3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./media/miss5.mp3 */ "./src/games/seabattle/media/miss5.mp3");
/* harmony import */ var _media_miss5_mp3__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_media_miss5_mp3__WEBPACK_IMPORTED_MODULE_7__);
function cov_2bmn6wsyx5() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/sound.ts";
  var hash = "9e547708771431fa17006a8f11abf71f9272f467";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/games/seabattle/sound.ts",
    statementMap: {
      "0": {
        start: {
          line: 10,
          column: 19
        },
        end: {
          line: 10,
          column: 52
        }
      },
      "1": {
        start: {
          line: 11,
          column: 20
        },
        end: {
          line: 11,
          column: 80
        }
      },
      "2": {
        start: {
          line: 13,
          column: 34
        },
        end: {
          line: 21,
          column: 1
        }
      },
      "3": {
        start: {
          line: 14,
          column: 2
        },
        end: {
          line: 20,
          column: 3
        }
      },
      "4": {
        start: {
          line: 15,
          column: 21
        },
        end: {
          line: 15,
          column: 54
        }
      },
      "5": {
        start: {
          line: 16,
          column: 4
        },
        end: {
          line: 16,
          column: 20
        }
      },
      "6": {
        start: {
          line: 17,
          column: 9
        },
        end: {
          line: 20,
          column: 3
        }
      },
      "7": {
        start: {
          line: 18,
          column: 22
        },
        end: {
          line: 18,
          column: 56
        }
      },
      "8": {
        start: {
          line: 19,
          column: 4
        },
        end: {
          line: 19,
          column: 21
        }
      },
      "9": {
        start: {
          line: 23,
          column: 24
        },
        end: {
          line: 26,
          column: 1
        }
      },
      "10": {
        start: {
          line: 24,
          column: 14
        },
        end: {
          line: 24,
          column: 55
        }
      },
      "11": {
        start: {
          line: 25,
          column: 2
        },
        end: {
          line: 25,
          column: 48
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 13,
            column: 34
          },
          end: {
            line: 13,
            column: 35
          }
        },
        loc: {
          start: {
            line: 13,
            column: 53
          },
          end: {
            line: 21,
            column: 1
          }
        },
        line: 13
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 23,
            column: 24
          },
          end: {
            line: 23,
            column: 25
          }
        },
        loc: {
          start: {
            line: 23,
            column: 50
          },
          end: {
            line: 26,
            column: 1
          }
        },
        line: 23
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 14,
            column: 2
          },
          end: {
            line: 20,
            column: 3
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 14,
            column: 2
          },
          end: {
            line: 20,
            column: 3
          }
        }, {
          start: {
            line: 14,
            column: 2
          },
          end: {
            line: 20,
            column: 3
          }
        }],
        line: 14
      },
      "1": {
        loc: {
          start: {
            line: 17,
            column: 9
          },
          end: {
            line: 20,
            column: 3
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 17,
            column: 9
          },
          end: {
            line: 20,
            column: 3
          }
        }, {
          start: {
            line: 17,
            column: 9
          },
          end: {
            line: 20,
            column: 3
          }
        }],
        line: 17
      },
      "2": {
        loc: {
          start: {
            line: 24,
            column: 14
          },
          end: {
            line: 24,
            column: 55
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 24,
            column: 31
          },
          end: {
            line: 24,
            column: 41
          }
        }, {
          start: {
            line: 24,
            column: 44
          },
          end: {
            line: 24,
            column: 55
          }
        }],
        line: 24
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0
    },
    f: {
      "0": 0,
      "1": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "9e547708771431fa17006a8f11abf71f9272f467"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2bmn6wsyx5 = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2bmn6wsyx5();








var HIT_SOUNDS = (cov_2bmn6wsyx5().s[0]++, [_media_hit1_mp3__WEBPACK_IMPORTED_MODULE_0___default.a, _media_hit2_mp3__WEBPACK_IMPORTED_MODULE_1___default.a, _media_hit3_mp3__WEBPACK_IMPORTED_MODULE_2___default.a]);
var MISS_SOUNDS = (cov_2bmn6wsyx5().s[1]++, [_media_miss1_mp3__WEBPACK_IMPORTED_MODULE_3___default.a, _media_miss2_mp3__WEBPACK_IMPORTED_MODULE_4___default.a, _media_miss3_mp3__WEBPACK_IMPORTED_MODULE_5___default.a, _media_miss4_mp3__WEBPACK_IMPORTED_MODULE_6___default.a, _media_miss5_mp3__WEBPACK_IMPORTED_MODULE_7___default.a]);
cov_2bmn6wsyx5().s[2]++;
var playSeabattleSound = function playSeabattleSound(sound) {
  cov_2bmn6wsyx5().f[0]++;
  cov_2bmn6wsyx5().s[3]++;

  if (sound === 'HIT') {
    cov_2bmn6wsyx5().b[0][0]++;
    var hitSound = (cov_2bmn6wsyx5().s[4]++, new Audio(_getRandomSound('hit')));
    cov_2bmn6wsyx5().s[5]++;
    hitSound.play();
  } else {
    cov_2bmn6wsyx5().b[0][1]++;
    cov_2bmn6wsyx5().s[6]++;

    if (sound === 'MISS') {
      cov_2bmn6wsyx5().b[1][0]++;
      var missSound = (cov_2bmn6wsyx5().s[7]++, new Audio(_getRandomSound('miss')));
      cov_2bmn6wsyx5().s[8]++;
      missSound.play();
    } else {
      cov_2bmn6wsyx5().b[1][1]++;
    }
  }
};
cov_2bmn6wsyx5().s[9]++;

var _getRandomSound = function _getRandomSound(type) {
  cov_2bmn6wsyx5().f[1]++;
  var arr = (cov_2bmn6wsyx5().s[10]++, type === 'hit' ? (cov_2bmn6wsyx5().b[2][0]++, HIT_SOUNDS) : (cov_2bmn6wsyx5().b[2][1]++, MISS_SOUNDS));
  cov_2bmn6wsyx5().s[11]++;
  return arr[Math.random() * arr.length << 0];
};

/***/ }),

/***/ "./src/hooks/useWindowDimensions.ts":
/*!******************************************!*\
  !*** ./src/hooks/useWindowDimensions.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return useWindowDimensions; });
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);


function cov_2gr5onh2wh() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/hooks/useWindowDimensions.ts";
  var hash = "4f114065dc7cb63bff1107bea751cd3943287ae8";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/hooks/useWindowDimensions.ts",
    statementMap: {
      "0": {
        start: {
          line: 6,
          column: 20
        },
        end: {
          line: 6,
          column: 49
        }
      },
      "1": {
        start: {
          line: 9,
          column: 18
        },
        end: {
          line: 9,
          column: 54
        }
      },
      "2": {
        start: {
          line: 10,
          column: 19
        },
        end: {
          line: 10,
          column: 56
        }
      },
      "3": {
        start: {
          line: 11,
          column: 4
        },
        end: {
          line: 14,
          column: 6
        }
      },
      "4": {
        start: {
          line: 17,
          column: 50
        },
        end: {
          line: 17,
          column: 81
        }
      },
      "5": {
        start: {
          line: 19,
          column: 2
        },
        end: {
          line: 27,
          column: 18
        }
      },
      "6": {
        start: {
          line: 20,
          column: 4
        },
        end: {
          line: 26,
          column: 5
        }
      },
      "7": {
        start: {
          line: 21,
          column: 27
        },
        end: {
          line: 23,
          column: 7
        }
      },
      "8": {
        start: {
          line: 22,
          column: 8
        },
        end: {
          line: 22,
          column: 51
        }
      },
      "9": {
        start: {
          line: 24,
          column: 6
        },
        end: {
          line: 24,
          column: 54
        }
      },
      "10": {
        start: {
          line: 25,
          column: 6
        },
        end: {
          line: 25,
          column: 70
        }
      },
      "11": {
        start: {
          line: 25,
          column: 19
        },
        end: {
          line: 25,
          column: 69
        }
      },
      "12": {
        start: {
          line: 29,
          column: 2
        },
        end: {
          line: 29,
          column: 26
        }
      }
    },
    fnMap: {
      "0": {
        name: "useWindowDimensions",
        decl: {
          start: {
            line: 5,
            column: 24
          },
          end: {
            line: 5,
            column: 43
          }
        },
        loc: {
          start: {
            line: 5,
            column: 46
          },
          end: {
            line: 30,
            column: 1
          }
        },
        line: 5
      },
      "1": {
        name: "getWindowDimensions",
        decl: {
          start: {
            line: 8,
            column: 11
          },
          end: {
            line: 8,
            column: 30
          }
        },
        loc: {
          start: {
            line: 8,
            column: 33
          },
          end: {
            line: 15,
            column: 3
          }
        },
        line: 8
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 19,
            column: 12
          },
          end: {
            line: 19,
            column: 13
          }
        },
        loc: {
          start: {
            line: 19,
            column: 18
          },
          end: {
            line: 27,
            column: 3
          }
        },
        line: 19
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 21,
            column: 27
          },
          end: {
            line: 21,
            column: 28
          }
        },
        loc: {
          start: {
            line: 21,
            column: 33
          },
          end: {
            line: 23,
            column: 7
          }
        },
        line: 21
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 25,
            column: 13
          },
          end: {
            line: 25,
            column: 14
          }
        },
        loc: {
          start: {
            line: 25,
            column: 19
          },
          end: {
            line: 25,
            column: 69
          }
        },
        line: 25
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 9,
            column: 18
          },
          end: {
            line: 9,
            column: 54
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 9,
            column: 30
          },
          end: {
            line: 9,
            column: 47
          }
        }, {
          start: {
            line: 9,
            column: 50
          },
          end: {
            line: 9,
            column: 54
          }
        }],
        line: 9
      },
      "1": {
        loc: {
          start: {
            line: 10,
            column: 19
          },
          end: {
            line: 10,
            column: 56
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 10,
            column: 31
          },
          end: {
            line: 10,
            column: 49
          }
        }, {
          start: {
            line: 10,
            column: 52
          },
          end: {
            line: 10,
            column: 56
          }
        }],
        line: 10
      },
      "2": {
        loc: {
          start: {
            line: 20,
            column: 4
          },
          end: {
            line: 26,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 20,
            column: 4
          },
          end: {
            line: 26,
            column: 5
          }
        }, {
          start: {
            line: 20,
            column: 4
          },
          end: {
            line: 26,
            column: 5
          }
        }],
        line: 20
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "4f114065dc7cb63bff1107bea751cd3943287ae8"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2gr5onh2wh = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2gr5onh2wh();
// https://stackoverflow.com/a/59185109

function useWindowDimensions() {
  cov_2gr5onh2wh().f[0]++;
  var hasWindow = (cov_2gr5onh2wh().s[0]++, true);

  function getWindowDimensions() {
    cov_2gr5onh2wh().f[1]++;
    var width = (cov_2gr5onh2wh().s[1]++, hasWindow ? (cov_2gr5onh2wh().b[0][0]++, window.innerWidth) : (cov_2gr5onh2wh().b[0][1]++, null));
    var height = (cov_2gr5onh2wh().s[2]++, hasWindow ? (cov_2gr5onh2wh().b[1][0]++, window.innerHeight) : (cov_2gr5onh2wh().b[1][1]++, null));
    cov_2gr5onh2wh().s[3]++;
    return {
      width: width,
      height: height
    };
  }

  var _ref = (cov_2gr5onh2wh().s[4]++, Object(react__WEBPACK_IMPORTED_MODULE_1__["useState"])(getWindowDimensions())),
      _ref2 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref, 2),
      windowDimensions = _ref2[0],
      setWindowDimensions = _ref2[1];

  cov_2gr5onh2wh().s[5]++;
  Object(react__WEBPACK_IMPORTED_MODULE_1__["useEffect"])(function () {
    cov_2gr5onh2wh().f[2]++;
    cov_2gr5onh2wh().s[6]++;

    if (hasWindow) {
      cov_2gr5onh2wh().b[2][0]++;
      cov_2gr5onh2wh().s[7]++;

      var handleResize = function handleResize() {
        cov_2gr5onh2wh().f[3]++;
        cov_2gr5onh2wh().s[8]++;
        setWindowDimensions(getWindowDimensions());
      };

      cov_2gr5onh2wh().s[9]++;
      window.addEventListener('resize', handleResize);
      cov_2gr5onh2wh().s[10]++;
      return function () {
        cov_2gr5onh2wh().f[4]++;
        cov_2gr5onh2wh().s[11]++;
        return window.removeEventListener('resize', handleResize);
      };
    } else {
      cov_2gr5onh2wh().b[2][1]++;
    }
  }, [hasWindow]);
  cov_2gr5onh2wh().s[12]++;
  return windowDimensions;
}

/***/ }),

/***/ "./src/ui/2d/grid.js":
/*!***************************!*\
  !*** ./src/ui/2d/grid.js ***!
  \***************************/
/*! exports provided: Grid, Square */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Grid", function() { return Grid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Square", function() { return Square; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);







var __jsx = react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement;

function cov_2noc4a7ksf() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/ui/2d/grid.js";
  var hash = "3918b7b6aef2b5d873a9b3ced78aa755c8be9a44";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/ui/2d/grid.js",
    statementMap: {
      "0": {
        start: {
          line: 36,
          column: 21
        },
        end: {
          line: 47,
          column: 3
        }
      },
      "1": {
        start: {
          line: 49,
          column: 24
        },
        end: {
          line: 53,
          column: 3
        }
      },
      "2": {
        start: {
          line: 55,
          column: 12
        },
        end: {
          line: 55,
          column: 29
        }
      },
      "3": {
        start: {
          line: 58,
          column: 16
        },
        end: {
          line: 58,
          column: 27
        }
      },
      "4": {
        start: {
          line: 59,
          column: 16
        },
        end: {
          line: 59,
          column: 23
        }
      },
      "5": {
        start: {
          line: 60,
          column: 4
        },
        end: {
          line: 62,
          column: 5
        }
      },
      "6": {
        start: {
          line: 61,
          column: 6
        },
        end: {
          line: 61,
          column: 39
        }
      },
      "7": {
        start: {
          line: 63,
          column: 4
        },
        end: {
          line: 63,
          column: 17
        }
      },
      "8": {
        start: {
          line: 67,
          column: 4
        },
        end: {
          line: 69,
          column: 5
        }
      },
      "9": {
        start: {
          line: 68,
          column: 6
        },
        end: {
          line: 68,
          column: 18
        }
      },
      "10": {
        start: {
          line: 71,
          column: 18
        },
        end: {
          line: 71,
          column: 20
        }
      },
      "11": {
        start: {
          line: 72,
          column: 4
        },
        end: {
          line: 87,
          column: 5
        }
      },
      "12": {
        start: {
          line: 72,
          column: 17
        },
        end: {
          line: 72,
          column: 18
        }
      },
      "13": {
        start: {
          line: 73,
          column: 6
        },
        end: {
          line: 86,
          column: 7
        }
      },
      "14": {
        start: {
          line: 73,
          column: 19
        },
        end: {
          line: 73,
          column: 20
        }
      },
      "15": {
        start: {
          line: 74,
          column: 8
        },
        end: {
          line: 85,
          column: 10
        }
      },
      "16": {
        start: {
          line: 88,
          column: 4
        },
        end: {
          line: 88,
          column: 19
        }
      },
      "17": {
        start: {
          line: 91,
          column: 12
        },
        end: {
          line: 95,
          column: 3
        }
      },
      "18": {
        start: {
          line: 92,
          column: 4
        },
        end: {
          line: 94,
          column: 5
        }
      },
      "19": {
        start: {
          line: 93,
          column: 6
        },
        end: {
          line: 93,
          column: 31
        }
      },
      "20": {
        start: {
          line: 97,
          column: 16
        },
        end: {
          line: 101,
          column: 3
        }
      },
      "21": {
        start: {
          line: 98,
          column: 4
        },
        end: {
          line: 100,
          column: 5
        }
      },
      "22": {
        start: {
          line: 99,
          column: 6
        },
        end: {
          line: 99,
          column: 35
        }
      },
      "23": {
        start: {
          line: 103,
          column: 15
        },
        end: {
          line: 107,
          column: 3
        }
      },
      "24": {
        start: {
          line: 104,
          column: 4
        },
        end: {
          line: 106,
          column: 5
        }
      },
      "25": {
        start: {
          line: 105,
          column: 6
        },
        end: {
          line: 105,
          column: 34
        }
      },
      "26": {
        start: {
          line: 110,
          column: 19
        },
        end: {
          line: 119,
          column: 6
        }
      },
      "27": {
        start: {
          line: 111,
          column: 6
        },
        end: {
          line: 118,
          column: 9
        }
      },
      "28": {
        start: {
          line: 121,
          column: 4
        },
        end: {
          line: 126,
          column: 6
        }
      },
      "29": {
        start: {
          line: 150,
          column: 21
        },
        end: {
          line: 160,
          column: 3
        }
      },
      "30": {
        start: {
          line: 162,
          column: 24
        },
        end: {
          line: 168,
          column: 3
        }
      },
      "31": {
        start: {
          line: 170,
          column: 10
        },
        end: {
          line: 170,
          column: 27
        }
      },
      "32": {
        start: {
          line: 172,
          column: 12
        },
        end: {
          line: 174,
          column: 3
        }
      },
      "33": {
        start: {
          line: 173,
          column: 4
        },
        end: {
          line: 173,
          column: 44
        }
      },
      "34": {
        start: {
          line: 176,
          column: 16
        },
        end: {
          line: 178,
          column: 3
        }
      },
      "35": {
        start: {
          line: 177,
          column: 4
        },
        end: {
          line: 177,
          column: 48
        }
      },
      "36": {
        start: {
          line: 180,
          column: 15
        },
        end: {
          line: 182,
          column: 3
        }
      },
      "37": {
        start: {
          line: 181,
          column: 4
        },
        end: {
          line: 181,
          column: 47
        }
      },
      "38": {
        start: {
          line: 185,
          column: 4
        },
        end: {
          line: 188,
          column: 6
        }
      },
      "39": {
        start: {
          line: 192,
          column: 20
        },
        end: {
          line: 192,
          column: 38
        }
      },
      "40": {
        start: {
          line: 193,
          column: 4
        },
        end: {
          line: 195,
          column: 5
        }
      },
      "41": {
        start: {
          line: 194,
          column: 6
        },
        end: {
          line: 194,
          column: 65
        }
      },
      "42": {
        start: {
          line: 199,
          column: 20
        },
        end: {
          line: 199,
          column: 38
        }
      },
      "43": {
        start: {
          line: 200,
          column: 4
        },
        end: {
          line: 202,
          column: 5
        }
      },
      "44": {
        start: {
          line: 201,
          column: 6
        },
        end: {
          line: 201,
          column: 68
        }
      },
      "45": {
        start: {
          line: 206,
          column: 15
        },
        end: {
          line: 206,
          column: 45
        }
      },
      "46": {
        start: {
          line: 207,
          column: 15
        },
        end: {
          line: 207,
          column: 45
        }
      },
      "47": {
        start: {
          line: 210,
          column: 19
        },
        end: {
          line: 210,
          column: 113
        }
      },
      "48": {
        start: {
          line: 212,
          column: 4
        },
        end: {
          line: 214,
          column: 5
        }
      },
      "49": {
        start: {
          line: 213,
          column: 6
        },
        end: {
          line: 213,
          column: 37
        }
      },
      "50": {
        start: {
          line: 216,
          column: 4
        },
        end: {
          line: 226,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 57,
            column: 2
          },
          end: {
            line: 57,
            column: 3
          }
        },
        loc: {
          start: {
            line: 57,
            column: 22
          },
          end: {
            line: 64,
            column: 3
          }
        },
        line: 57
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 66,
            column: 2
          },
          end: {
            line: 66,
            column: 3
          }
        },
        loc: {
          start: {
            line: 66,
            column: 13
          },
          end: {
            line: 89,
            column: 3
          }
        },
        line: 66
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 91,
            column: 12
          },
          end: {
            line: 91,
            column: 13
          }
        },
        loc: {
          start: {
            line: 91,
            column: 22
          },
          end: {
            line: 95,
            column: 3
          }
        },
        line: 91
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 97,
            column: 16
          },
          end: {
            line: 97,
            column: 17
          }
        },
        loc: {
          start: {
            line: 97,
            column: 26
          },
          end: {
            line: 101,
            column: 3
          }
        },
        line: 97
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 103,
            column: 15
          },
          end: {
            line: 103,
            column: 16
          }
        },
        loc: {
          start: {
            line: 103,
            column: 25
          },
          end: {
            line: 107,
            column: 3
          }
        },
        line: 103
      },
      "5": {
        name: "(anonymous_5)",
        decl: {
          start: {
            line: 109,
            column: 2
          },
          end: {
            line: 109,
            column: 3
          }
        },
        loc: {
          start: {
            line: 109,
            column: 11
          },
          end: {
            line: 127,
            column: 3
          }
        },
        line: 109
      },
      "6": {
        name: "(anonymous_6)",
        decl: {
          start: {
            line: 110,
            column: 59
          },
          end: {
            line: 110,
            column: 60
          }
        },
        loc: {
          start: {
            line: 110,
            column: 70
          },
          end: {
            line: 119,
            column: 5
          }
        },
        line: 110
      },
      "7": {
        name: "(anonymous_7)",
        decl: {
          start: {
            line: 172,
            column: 12
          },
          end: {
            line: 172,
            column: 13
          }
        },
        loc: {
          start: {
            line: 172,
            column: 19
          },
          end: {
            line: 174,
            column: 3
          }
        },
        line: 172
      },
      "8": {
        name: "(anonymous_8)",
        decl: {
          start: {
            line: 176,
            column: 16
          },
          end: {
            line: 176,
            column: 17
          }
        },
        loc: {
          start: {
            line: 176,
            column: 23
          },
          end: {
            line: 178,
            column: 3
          }
        },
        line: 176
      },
      "9": {
        name: "(anonymous_9)",
        decl: {
          start: {
            line: 180,
            column: 15
          },
          end: {
            line: 180,
            column: 16
          }
        },
        loc: {
          start: {
            line: 180,
            column: 22
          },
          end: {
            line: 182,
            column: 3
          }
        },
        line: 180
      },
      "10": {
        name: "(anonymous_10)",
        decl: {
          start: {
            line: 184,
            column: 2
          },
          end: {
            line: 184,
            column: 3
          }
        },
        loc: {
          start: {
            line: 184,
            column: 14
          },
          end: {
            line: 189,
            column: 3
          }
        },
        line: 184
      },
      "11": {
        name: "(anonymous_11)",
        decl: {
          start: {
            line: 191,
            column: 2
          },
          end: {
            line: 191,
            column: 3
          }
        },
        loc: {
          start: {
            line: 191,
            column: 22
          },
          end: {
            line: 196,
            column: 3
          }
        },
        line: 191
      },
      "12": {
        name: "(anonymous_12)",
        decl: {
          start: {
            line: 198,
            column: 2
          },
          end: {
            line: 198,
            column: 3
          }
        },
        loc: {
          start: {
            line: 198,
            column: 25
          },
          end: {
            line: 203,
            column: 3
          }
        },
        line: 198
      },
      "13": {
        name: "(anonymous_13)",
        decl: {
          start: {
            line: 205,
            column: 2
          },
          end: {
            line: 205,
            column: 3
          }
        },
        loc: {
          start: {
            line: 205,
            column: 11
          },
          end: {
            line: 227,
            column: 3
          }
        },
        line: 205
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 60,
            column: 4
          },
          end: {
            line: 62,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 60,
            column: 4
          },
          end: {
            line: 62,
            column: 5
          }
        }, {
          start: {
            line: 60,
            column: 4
          },
          end: {
            line: 62,
            column: 5
          }
        }],
        line: 60
      },
      "1": {
        loc: {
          start: {
            line: 67,
            column: 4
          },
          end: {
            line: 69,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 67,
            column: 4
          },
          end: {
            line: 69,
            column: 5
          }
        }, {
          start: {
            line: 67,
            column: 4
          },
          end: {
            line: 69,
            column: 5
          }
        }],
        line: 67
      },
      "2": {
        loc: {
          start: {
            line: 92,
            column: 4
          },
          end: {
            line: 94,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 92,
            column: 4
          },
          end: {
            line: 94,
            column: 5
          }
        }, {
          start: {
            line: 92,
            column: 4
          },
          end: {
            line: 94,
            column: 5
          }
        }],
        line: 92
      },
      "3": {
        loc: {
          start: {
            line: 98,
            column: 4
          },
          end: {
            line: 100,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 98,
            column: 4
          },
          end: {
            line: 100,
            column: 5
          }
        }, {
          start: {
            line: 98,
            column: 4
          },
          end: {
            line: 100,
            column: 5
          }
        }],
        line: 98
      },
      "4": {
        loc: {
          start: {
            line: 104,
            column: 4
          },
          end: {
            line: 106,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 104,
            column: 4
          },
          end: {
            line: 106,
            column: 5
          }
        }, {
          start: {
            line: 104,
            column: 4
          },
          end: {
            line: 106,
            column: 5
          }
        }],
        line: 104
      },
      "5": {
        loc: {
          start: {
            line: 212,
            column: 4
          },
          end: {
            line: 214,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 212,
            column: 4
          },
          end: {
            line: 214,
            column: 5
          }
        }, {
          start: {
            line: 212,
            column: 4
          },
          end: {
            line: 214,
            column: 5
          }
        }],
        line: 212
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0,
      "23": 0,
      "24": 0,
      "25": 0,
      "26": 0,
      "27": 0,
      "28": 0,
      "29": 0,
      "30": 0,
      "31": 0,
      "32": 0,
      "33": 0,
      "34": 0,
      "35": 0,
      "36": 0,
      "37": 0,
      "38": 0,
      "39": 0,
      "40": 0,
      "41": 0,
      "42": 0,
      "43": 0,
      "44": 0,
      "45": 0,
      "46": 0,
      "47": 0,
      "48": 0,
      "49": 0,
      "50": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0],
      "4": [0, 0],
      "5": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "3918b7b6aef2b5d873a9b3ced78aa755c8be9a44"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2noc4a7ksf = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2noc4a7ksf();

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */


/**
 * Grid
 *
 * Component that will show children on a cartesian regular grid.
 *
 * Props:
 *   rows       - Number of rows (height) of the grid.
 *   cols       - Number of columns (width) of the grid.
 *   style      - CSS style of the Grid HTML element.
 *   colorMap   - A map from 'x,y' => color.
 *   onClick    - (x, y) => {}
 *                Called when a square is clicked.
 *   onMouseOver    - (x, y) => {}
 *                Called when a square is mouse over.
 *   onMouseOut    - (x, y) => {}
 *                Called when a square is mouse out.
 *
 * Usage:
 *
 * <Grid rows={8} cols={8}>
 *   <Token x={1} y={2}/>
 * </Grid>
 */

var Grid = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Grid, _React$Component);

  var _super = _createSuper(Grid);

  function Grid() {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Grid);

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(_args));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_svgRef", (cov_2noc4a7ksf().s[2]++, react__WEBPACK_IMPORTED_MODULE_7___default.a.createRef()));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "onClick", (cov_2noc4a7ksf().s[17]++, function (args) {
      cov_2noc4a7ksf().f[2]++;
      cov_2noc4a7ksf().s[18]++;

      if (_this.props.onClick) {
        cov_2noc4a7ksf().b[2][0]++;
        cov_2noc4a7ksf().s[19]++;

        _this.props.onClick(args);
      } else {
        cov_2noc4a7ksf().b[2][1]++;
      }
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "onMouseOver", (cov_2noc4a7ksf().s[20]++, function (args) {
      cov_2noc4a7ksf().f[3]++;
      cov_2noc4a7ksf().s[21]++;

      if (_this.props.onMouseOver) {
        cov_2noc4a7ksf().b[3][0]++;
        cov_2noc4a7ksf().s[22]++;

        _this.props.onMouseOver(args);
      } else {
        cov_2noc4a7ksf().b[3][1]++;
      }
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "onMouseOut", (cov_2noc4a7ksf().s[23]++, function (args) {
      cov_2noc4a7ksf().f[4]++;
      cov_2noc4a7ksf().s[24]++;

      if (_this.props.onMouseOut) {
        cov_2noc4a7ksf().b[4][0]++;
        cov_2noc4a7ksf().s[25]++;

        _this.props.onMouseOut(args);
      } else {
        cov_2noc4a7ksf().b[4][1]++;
      }
    }));

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Grid, [{
    key: "_getCellColor",
    value: function _getCellColor(x, y) {
      cov_2noc4a7ksf().f[0]++;
      var key = (cov_2noc4a7ksf().s[3]++, "".concat(x, ",").concat(y));
      var color = (cov_2noc4a7ksf().s[4]++, 'white');
      cov_2noc4a7ksf().s[5]++;

      if (key in this.props.colorMap) {
        cov_2noc4a7ksf().b[0][0]++;
        cov_2noc4a7ksf().s[6]++;
        color = this.props.colorMap[key];
      } else {
        cov_2noc4a7ksf().b[0][1]++;
      }

      cov_2noc4a7ksf().s[7]++;
      return color;
    }
  }, {
    key: "_getGrid",
    value: function _getGrid() {
      cov_2noc4a7ksf().f[1]++;
      cov_2noc4a7ksf().s[8]++;

      if (!this.props.outline) {
        cov_2noc4a7ksf().b[1][0]++;
        cov_2noc4a7ksf().s[9]++;
        return null;
      } else {
        cov_2noc4a7ksf().b[1][1]++;
      }

      var squares = (cov_2noc4a7ksf().s[10]++, []);
      cov_2noc4a7ksf().s[11]++;

      for (var x = (cov_2noc4a7ksf().s[12]++, 0); x < this.props.cols; x++) {
        cov_2noc4a7ksf().s[13]++;

        for (var y = (cov_2noc4a7ksf().s[14]++, 0); y < this.props.rows; y++) {
          cov_2noc4a7ksf().s[15]++;
          squares.push(__jsx(Square, {
            key: this.props.cols * y + x,
            style: {
              fill: this._getCellColor(x, y)
            },
            x: x,
            y: y,
            size: this.props.cellSize,
            onClick: this.onClick,
            onMouseOver: this.onMouseOver,
            onMouseOut: this.onMouseOut
          }));
        }
      }

      cov_2noc4a7ksf().s[16]++;
      return squares;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      cov_2noc4a7ksf().f[5]++;
      var tokens = (cov_2noc4a7ksf().s[26]++, react__WEBPACK_IMPORTED_MODULE_7___default.a.Children.map(this.props.children, function (child) {
        cov_2noc4a7ksf().f[6]++;
        cov_2noc4a7ksf().s[27]++;
        return react__WEBPACK_IMPORTED_MODULE_7___default.a.cloneElement(child, {
          template: Square,
          // Overwrites Token's onClick, onMouseOver, onMouseOut
          onClick: _this2.onClick,
          onMouseOver: _this2.onMouseOver,
          onMouseOut: _this2.onMouseOut,
          svgRef: _this2._svgRef
        });
      }));
      cov_2noc4a7ksf().s[28]++;
      return __jsx("svg", {
        ref: this._svgRef,
        viewBox: '0 0 ' + this.props.cols + ' ' + this.props.rows,
        style: this.props.style
      }, __jsx("g", null, this._getGrid()), tokens);
    }
  }]);

  return Grid;
}((react__WEBPACK_IMPORTED_MODULE_7___default.a.Component));
/**
 * Square
 *
 * Component that renders a square inside a Grid.
 *
 * Props:
 *   x       - X coordinate on grid coordinates.
 *   y       - Y coordinate on grid coordinates.
 *   size    - Square size.
 *   style   - Custom styling.
 *   onClick - Invoked when a Square is clicked.
 *   onMouseOver - Invoked when a Square is mouse over.
 *   onMouseOut - Invoked when a Square is mouse out.
 *   eventListeners - Array of objects with name and callback
 *   for DOM events.
 *
 * Not meant to be used by the end user directly (use Token).
 * Also not exposed in the NPM.
 */

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Grid, "propTypes", (cov_2noc4a7ksf().s[0]++, {
  rows: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number.isRequired,
  cols: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number.isRequired,
  outline: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.bool,
  style: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.object,
  colorMap: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.object,
  cellSize: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number,
  onClick: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  onMouseOver: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  onMouseOut: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  children: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.element), prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.element])
}));

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Grid, "defaultProps", (cov_2noc4a7ksf().s[1]++, {
  colorMap: {},
  outline: true,
  cellSize: 1
}));

var Square = /*#__PURE__*/function (_React$Component2) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Square, _React$Component2);

  var _super2 = _createSuper(Square);

  function Square() {
    var _this3;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Square);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this3 = _super2.call.apply(_super2, [this].concat(args));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this3), "_gRef", (cov_2noc4a7ksf().s[31]++, react__WEBPACK_IMPORTED_MODULE_7___default.a.createRef()));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this3), "onClick", (cov_2noc4a7ksf().s[32]++, function (e) {
      cov_2noc4a7ksf().f[7]++;
      cov_2noc4a7ksf().s[33]++;

      _this3.props.onClick(_this3.getCoords(), e);
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this3), "onMouseOver", (cov_2noc4a7ksf().s[34]++, function (e) {
      cov_2noc4a7ksf().f[8]++;
      cov_2noc4a7ksf().s[35]++;

      _this3.props.onMouseOver(_this3.getCoords(), e);
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this3), "onMouseOut", (cov_2noc4a7ksf().s[36]++, function (e) {
      cov_2noc4a7ksf().f[9]++;
      cov_2noc4a7ksf().s[37]++;

      _this3.props.onMouseOut(_this3.getCoords(), e);
    }));

    return _this3;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Square, [{
    key: "getCoords",
    value: function getCoords() {
      cov_2noc4a7ksf().f[10]++;
      cov_2noc4a7ksf().s[38]++;
      return {
        x: this.props.x,
        y: this.props.y
      };
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      cov_2noc4a7ksf().f[11]++;
      var element = (cov_2noc4a7ksf().s[39]++, this._gRef.current);
      cov_2noc4a7ksf().s[40]++;

      var _iterator = _createForOfIteratorHelper(this.props.eventListeners),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var listener = _step.value;
          cov_2noc4a7ksf().s[41]++;
          element.addEventListener(listener.name, listener.callback);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cov_2noc4a7ksf().f[12]++;
      var element = (cov_2noc4a7ksf().s[42]++, this._gRef.current);
      cov_2noc4a7ksf().s[43]++;

      var _iterator2 = _createForOfIteratorHelper(this.props.eventListeners),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var listener = _step2.value;
          cov_2noc4a7ksf().s[44]++;
          element.removeEventListener(listener.name, listener.callback);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "render",
    value: function render() {
      cov_2noc4a7ksf().f[13]++;
      var tx = (cov_2noc4a7ksf().s[45]++, this.props.x * this.props.size);
      var ty = (cov_2noc4a7ksf().s[46]++, this.props.y * this.props.size); // If no child, render a square.

      var children = (cov_2noc4a7ksf().s[47]++, __jsx("rect", {
        style: this.props.style,
        width: this.props.size,
        height: this.props.size,
        x: 0,
        y: 0
      })); // If a child is passed, render child.

      cov_2noc4a7ksf().s[48]++;

      if (this.props.children) {
        cov_2noc4a7ksf().b[5][0]++;
        cov_2noc4a7ksf().s[49]++;
        children = this.props.children;
      } else {
        cov_2noc4a7ksf().b[5][1]++;
      }

      cov_2noc4a7ksf().s[50]++;
      return __jsx("g", {
        ref: this._gRef,
        onClick: this.onClick,
        onMouseOver: this.onMouseOver,
        onMouseOut: this.onMouseOut,
        transform: "translate(".concat(tx, ", ").concat(ty, ")")
      }, children);
    }
  }]);

  return Square;
}((react__WEBPACK_IMPORTED_MODULE_7___default.a.Component));

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Square, "propTypes", (cov_2noc4a7ksf().s[29]++, {
  x: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number.isRequired,
  y: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number.isRequired,
  size: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number,
  style: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.any,
  onClick: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  onMouseOver: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  onMouseOut: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  eventListeners: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.array,
  children: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.element
}));

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Square, "defaultProps", (cov_2noc4a7ksf().s[30]++, {
  size: 1,
  x: 0,
  y: 0,
  style: {
    fill: '#fff'
  },
  eventListeners: []
}));

/***/ }),

/***/ "./src/ui/2d/token.js":
/*!****************************!*\
  !*** ./src/ui/2d/token.js ***!
  \****************************/
/*! exports provided: Token */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./grid */ "./src/ui/2d/grid.js");







var __jsx = react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement;

function cov_1z72eol64x() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/ui/2d/token.js";
  var hash = "c6f8879a25ecbed105cf5c19a3aada49cefea075";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/ui/2d/token.js",
    statementMap: {
      "0": {
        start: {
          line: 57,
          column: 21
        },
        end: {
          line: 74,
          column: 3
        }
      },
      "1": {
        start: {
          line: 76,
          column: 24
        },
        end: {
          line: 79,
          column: 3
        }
      },
      "2": {
        start: {
          line: 82,
          column: 4
        },
        end: {
          line: 82,
          column: 17
        }
      },
      "3": {
        start: {
          line: 83,
          column: 4
        },
        end: {
          line: 87,
          column: 6
        }
      },
      "4": {
        start: {
          line: 90,
          column: 15
        },
        end: {
          line: 100,
          column: 3
        }
      },
      "5": {
        start: {
          line: 91,
          column: 4
        },
        end: {
          line: 99,
          column: 5
        }
      },
      "6": {
        start: {
          line: 92,
          column: 6
        },
        end: {
          line: 92,
          column: 25
        }
      },
      "7": {
        start: {
          line: 93,
          column: 6
        },
        end: {
          line: 93,
          column: 39
        }
      },
      "8": {
        start: {
          line: 94,
          column: 6
        },
        end: {
          line: 97,
          column: 9
        }
      },
      "9": {
        start: {
          line: 98,
          column: 6
        },
        end: {
          line: 98,
          column: 48
        }
      },
      "10": {
        start: {
          line: 102,
          column: 10
        },
        end: {
          line: 129,
          column: 3
        }
      },
      "11": {
        start: {
          line: 103,
          column: 4
        },
        end: {
          line: 128,
          column: 5
        }
      },
      "12": {
        start: {
          line: 104,
          column: 6
        },
        end: {
          line: 104,
          column: 25
        }
      },
      "13": {
        start: {
          line: 105,
          column: 6
        },
        end: {
          line: 105,
          column: 39
        }
      },
      "14": {
        start: {
          line: 106,
          column: 18
        },
        end: {
          line: 106,
          column: 68
        }
      },
      "15": {
        start: {
          line: 107,
          column: 25
        },
        end: {
          line: 107,
          column: 55
        }
      },
      "16": {
        start: {
          line: 108,
          column: 25
        },
        end: {
          line: 108,
          column: 55
        }
      },
      "17": {
        start: {
          line: 109,
          column: 24
        },
        end: {
          line: 109,
          column: 63
        }
      },
      "18": {
        start: {
          line: 110,
          column: 24
        },
        end: {
          line: 110,
          column: 63
        }
      },
      "19": {
        start: {
          line: 111,
          column: 16
        },
        end: {
          line: 111,
          column: 40
        }
      },
      "20": {
        start: {
          line: 112,
          column: 16
        },
        end: {
          line: 112,
          column: 40
        }
      },
      "21": {
        start: {
          line: 113,
          column: 6
        },
        end: {
          line: 120,
          column: 7
        }
      },
      "22": {
        start: {
          line: 114,
          column: 8
        },
        end: {
          line: 119,
          column: 11
        }
      },
      "23": {
        start: {
          line: 122,
          column: 6
        },
        end: {
          line: 127,
          column: 9
        }
      },
      "24": {
        start: {
          line: 131,
          column: 13
        },
        end: {
          line: 155,
          column: 3
        }
      },
      "25": {
        start: {
          line: 132,
          column: 4
        },
        end: {
          line: 154,
          column: 5
        }
      },
      "26": {
        start: {
          line: 133,
          column: 6
        },
        end: {
          line: 133,
          column: 25
        }
      },
      "27": {
        start: {
          line: 136,
          column: 19
        },
        end: {
          line: 136,
          column: 101
        }
      },
      "28": {
        start: {
          line: 137,
          column: 6
        },
        end: {
          line: 146,
          column: 7
        }
      },
      "29": {
        start: {
          line: 138,
          column: 8
        },
        end: {
          line: 143,
          column: 11
        }
      },
      "30": {
        start: {
          line: 145,
          column: 8
        },
        end: {
          line: 145,
          column: 65
        }
      },
      "31": {
        start: {
          line: 147,
          column: 6
        },
        end: {
          line: 152,
          column: 9
        }
      },
      "32": {
        start: {
          line: 153,
          column: 6
        },
        end: {
          line: 153,
          column: 49
        }
      },
      "33": {
        start: {
          line: 157,
          column: 13
        },
        end: {
          line: 164,
          column: 3
        }
      },
      "34": {
        start: {
          line: 161,
          column: 4
        },
        end: {
          line: 163,
          column: 5
        }
      },
      "35": {
        start: {
          line: 162,
          column: 6
        },
        end: {
          line: 162,
          column: 32
        }
      },
      "36": {
        start: {
          line: 167,
          column: 4
        },
        end: {
          line: 169,
          column: 5
        }
      },
      "37": {
        start: {
          line: 168,
          column: 6
        },
        end: {
          line: 168,
          column: 49
        }
      },
      "38": {
        start: {
          line: 179,
          column: 19
        },
        end: {
          line: 179,
          column: 35
        }
      },
      "39": {
        start: {
          line: 180,
          column: 19
        },
        end: {
          line: 180,
          column: 44
        }
      },
      "40": {
        start: {
          line: 183,
          column: 4
        },
        end: {
          line: 185,
          column: 5
        }
      },
      "41": {
        start: {
          line: 184,
          column: 6
        },
        end: {
          line: 184,
          column: 13
        }
      },
      "42": {
        start: {
          line: 187,
          column: 4
        },
        end: {
          line: 193,
          column: 7
        }
      },
      "43": {
        start: {
          line: 195,
          column: 4
        },
        end: {
          line: 195,
          column: 53
        }
      },
      "44": {
        start: {
          line: 203,
          column: 18
        },
        end: {
          line: 203,
          column: 43
        }
      },
      "45": {
        start: {
          line: 204,
          column: 4
        },
        end: {
          line: 204,
          column: 23
        }
      },
      "46": {
        start: {
          line: 204,
          column: 16
        },
        end: {
          line: 204,
          column: 23
        }
      },
      "47": {
        start: {
          line: 205,
          column: 35
        },
        end: {
          line: 205,
          column: 57
        }
      },
      "48": {
        start: {
          line: 206,
          column: 4
        },
        end: {
          line: 208,
          column: 5
        }
      },
      "49": {
        start: {
          line: 207,
          column: 6
        },
        end: {
          line: 207,
          column: 59
        }
      },
      "50": {
        start: {
          line: 209,
          column: 4
        },
        end: {
          line: 209,
          column: 74
        }
      },
      "51": {
        start: {
          line: 210,
          column: 4
        },
        end: {
          line: 210,
          column: 74
        }
      },
      "52": {
        start: {
          line: 211,
          column: 4
        },
        end: {
          line: 211,
          column: 75
        }
      },
      "53": {
        start: {
          line: 212,
          column: 4
        },
        end: {
          line: 212,
          column: 78
        }
      },
      "54": {
        start: {
          line: 213,
          column: 4
        },
        end: {
          line: 213,
          column: 79
        }
      },
      "55": {
        start: {
          line: 214,
          column: 4
        },
        end: {
          line: 214,
          column: 78
        }
      },
      "56": {
        start: {
          line: 215,
          column: 4
        },
        end: {
          line: 215,
          column: 76
        }
      },
      "57": {
        start: {
          line: 223,
          column: 4
        },
        end: {
          line: 245,
          column: 18
        }
      },
      "58": {
        start: {
          line: 224,
          column: 20
        },
        end: {
          line: 224,
          column: 47
        }
      },
      "59": {
        start: {
          line: 225,
          column: 21
        },
        end: {
          line: 225,
          column: 37
        }
      },
      "60": {
        start: {
          line: 226,
          column: 6
        },
        end: {
          line: 244,
          column: 7
        }
      },
      "61": {
        start: {
          line: 227,
          column: 27
        },
        end: {
          line: 227,
          column: 92
        }
      },
      "62": {
        start: {
          line: 229,
          column: 8
        },
        end: {
          line: 234,
          column: 11
        }
      },
      "63": {
        start: {
          line: 236,
          column: 8
        },
        end: {
          line: 236,
          column: 57
        }
      },
      "64": {
        start: {
          line: 238,
          column: 8
        },
        end: {
          line: 243,
          column: 11
        }
      },
      "65": {
        start: {
          line: 254,
          column: 4
        },
        end: {
          line: 254,
          column: 50
        }
      },
      "66": {
        start: {
          line: 265,
          column: 4
        },
        end: {
          line: 265,
          column: 15
        }
      },
      "67": {
        start: {
          line: 266,
          column: 4
        },
        end: {
          line: 266,
          column: 46
        }
      },
      "68": {
        start: {
          line: 266,
          column: 15
        },
        end: {
          line: 266,
          column: 46
        }
      },
      "69": {
        start: {
          line: 267,
          column: 4
        },
        end: {
          line: 267,
          column: 11
        }
      },
      "70": {
        start: {
          line: 268,
          column: 4
        },
        end: {
          line: 268,
          column: 41
        }
      },
      "71": {
        start: {
          line: 275,
          column: 4
        },
        end: {
          line: 278,
          column: 6
        }
      },
      "72": {
        start: {
          line: 282,
          column: 22
        },
        end: {
          line: 282,
          column: 41
        }
      },
      "73": {
        start: {
          line: 284,
          column: 4
        },
        end: {
          line: 297,
          column: 6
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 81,
            column: 2
          },
          end: {
            line: 81,
            column: 3
          }
        },
        loc: {
          start: {
            line: 81,
            column: 21
          },
          end: {
            line: 88,
            column: 3
          }
        },
        line: 81
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 90,
            column: 15
          },
          end: {
            line: 90,
            column: 16
          }
        },
        loc: {
          start: {
            line: 90,
            column: 22
          },
          end: {
            line: 100,
            column: 3
          }
        },
        line: 90
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 102,
            column: 10
          },
          end: {
            line: 102,
            column: 11
          }
        },
        loc: {
          start: {
            line: 102,
            column: 17
          },
          end: {
            line: 129,
            column: 3
          }
        },
        line: 102
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 131,
            column: 13
          },
          end: {
            line: 131,
            column: 14
          }
        },
        loc: {
          start: {
            line: 131,
            column: 20
          },
          end: {
            line: 155,
            column: 3
          }
        },
        line: 131
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 157,
            column: 13
          },
          end: {
            line: 157,
            column: 14
          }
        },
        loc: {
          start: {
            line: 157,
            column: 24
          },
          end: {
            line: 164,
            column: 3
          }
        },
        line: 157
      },
      "5": {
        name: "(anonymous_5)",
        decl: {
          start: {
            line: 166,
            column: 2
          },
          end: {
            line: 166,
            column: 3
          }
        },
        loc: {
          start: {
            line: 166,
            column: 25
          },
          end: {
            line: 170,
            column: 3
          }
        },
        line: 166
      },
      "6": {
        name: "(anonymous_6)",
        decl: {
          start: {
            line: 178,
            column: 2
          },
          end: {
            line: 178,
            column: 3
          }
        },
        loc: {
          start: {
            line: 178,
            column: 46
          },
          end: {
            line: 196,
            column: 3
          }
        },
        line: 178
      },
      "7": {
        name: "(anonymous_7)",
        decl: {
          start: {
            line: 202,
            column: 2
          },
          end: {
            line: 202,
            column: 3
          }
        },
        loc: {
          start: {
            line: 202,
            column: 44
          },
          end: {
            line: 216,
            column: 3
          }
        },
        line: 202
      },
      "8": {
        name: "(anonymous_8)",
        decl: {
          start: {
            line: 222,
            column: 2
          },
          end: {
            line: 222,
            column: 3
          }
        },
        loc: {
          start: {
            line: 222,
            column: 16
          },
          end: {
            line: 246,
            column: 3
          }
        },
        line: 222
      },
      "9": {
        name: "(anonymous_9)",
        decl: {
          start: {
            line: 223,
            column: 12
          },
          end: {
            line: 223,
            column: 13
          }
        },
        loc: {
          start: {
            line: 223,
            column: 18
          },
          end: {
            line: 245,
            column: 5
          }
        },
        line: 223
      },
      "10": {
        name: "(anonymous_10)",
        decl: {
          start: {
            line: 253,
            column: 2
          },
          end: {
            line: 253,
            column: 3
          }
        },
        loc: {
          start: {
            line: 253,
            column: 32
          },
          end: {
            line: 255,
            column: 3
          }
        },
        line: 253
      },
      "11": {
        name: "(anonymous_11)",
        decl: {
          start: {
            line: 264,
            column: 2
          },
          end: {
            line: 264,
            column: 3
          }
        },
        loc: {
          start: {
            line: 264,
            column: 30
          },
          end: {
            line: 269,
            column: 3
          }
        },
        line: 264
      },
      "12": {
        name: "(anonymous_12)",
        decl: {
          start: {
            line: 274,
            column: 2
          },
          end: {
            line: 274,
            column: 3
          }
        },
        loc: {
          start: {
            line: 274,
            column: 20
          },
          end: {
            line: 279,
            column: 3
          }
        },
        line: 274
      },
      "13": {
        name: "(anonymous_13)",
        decl: {
          start: {
            line: 281,
            column: 2
          },
          end: {
            line: 281,
            column: 3
          }
        },
        loc: {
          start: {
            line: 281,
            column: 11
          },
          end: {
            line: 298,
            column: 3
          }
        },
        line: 281
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 91,
            column: 4
          },
          end: {
            line: 99,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 91,
            column: 4
          },
          end: {
            line: 99,
            column: 5
          }
        }, {
          start: {
            line: 91,
            column: 4
          },
          end: {
            line: 99,
            column: 5
          }
        }],
        line: 91
      },
      "1": {
        loc: {
          start: {
            line: 91,
            column: 8
          },
          end: {
            line: 91,
            column: 71
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 91,
            column: 8
          },
          end: {
            line: 91,
            column: 28
          }
        }, {
          start: {
            line: 91,
            column: 32
          },
          end: {
            line: 91,
            column: 71
          }
        }],
        line: 91
      },
      "2": {
        loc: {
          start: {
            line: 93,
            column: 10
          },
          end: {
            line: 93,
            column: 38
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 93,
            column: 22
          },
          end: {
            line: 93,
            column: 34
          }
        }, {
          start: {
            line: 93,
            column: 37
          },
          end: {
            line: 93,
            column: 38
          }
        }],
        line: 93
      },
      "3": {
        loc: {
          start: {
            line: 103,
            column: 4
          },
          end: {
            line: 128,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 103,
            column: 4
          },
          end: {
            line: 128,
            column: 5
          }
        }, {
          start: {
            line: 103,
            column: 4
          },
          end: {
            line: 128,
            column: 5
          }
        }],
        line: 103
      },
      "4": {
        loc: {
          start: {
            line: 105,
            column: 10
          },
          end: {
            line: 105,
            column: 38
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 105,
            column: 22
          },
          end: {
            line: 105,
            column: 34
          }
        }, {
          start: {
            line: 105,
            column: 37
          },
          end: {
            line: 105,
            column: 38
          }
        }],
        line: 105
      },
      "5": {
        loc: {
          start: {
            line: 113,
            column: 6
          },
          end: {
            line: 120,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 113,
            column: 6
          },
          end: {
            line: 120,
            column: 7
          }
        }, {
          start: {
            line: 113,
            column: 6
          },
          end: {
            line: 120,
            column: 7
          }
        }],
        line: 113
      },
      "6": {
        loc: {
          start: {
            line: 132,
            column: 4
          },
          end: {
            line: 154,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 132,
            column: 4
          },
          end: {
            line: 154,
            column: 5
          }
        }, {
          start: {
            line: 132,
            column: 4
          },
          end: {
            line: 154,
            column: 5
          }
        }],
        line: 132
      },
      "7": {
        loc: {
          start: {
            line: 137,
            column: 6
          },
          end: {
            line: 146,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 137,
            column: 6
          },
          end: {
            line: 146,
            column: 7
          }
        }, {
          start: {
            line: 137,
            column: 6
          },
          end: {
            line: 146,
            column: 7
          }
        }],
        line: 137
      },
      "8": {
        loc: {
          start: {
            line: 161,
            column: 4
          },
          end: {
            line: 163,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 161,
            column: 4
          },
          end: {
            line: 163,
            column: 5
          }
        }, {
          start: {
            line: 161,
            column: 4
          },
          end: {
            line: 163,
            column: 5
          }
        }],
        line: 161
      },
      "9": {
        loc: {
          start: {
            line: 161,
            column: 10
          },
          end: {
            line: 161,
            column: 73
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 161,
            column: 10
          },
          end: {
            line: 161,
            column: 30
          }
        }, {
          start: {
            line: 161,
            column: 34
          },
          end: {
            line: 161,
            column: 73
          }
        }],
        line: 161
      },
      "10": {
        loc: {
          start: {
            line: 167,
            column: 4
          },
          end: {
            line: 169,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 167,
            column: 4
          },
          end: {
            line: 169,
            column: 5
          }
        }, {
          start: {
            line: 167,
            column: 4
          },
          end: {
            line: 169,
            column: 5
          }
        }],
        line: 167
      },
      "11": {
        loc: {
          start: {
            line: 183,
            column: 4
          },
          end: {
            line: 185,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 183,
            column: 4
          },
          end: {
            line: 185,
            column: 5
          }
        }, {
          start: {
            line: 183,
            column: 4
          },
          end: {
            line: 185,
            column: 5
          }
        }],
        line: 183
      },
      "12": {
        loc: {
          start: {
            line: 183,
            column: 8
          },
          end: {
            line: 183,
            column: 60
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 183,
            column: 8
          },
          end: {
            line: 183,
            column: 32
          }
        }, {
          start: {
            line: 183,
            column: 36
          },
          end: {
            line: 183,
            column: 60
          }
        }],
        line: 183
      },
      "13": {
        loc: {
          start: {
            line: 204,
            column: 4
          },
          end: {
            line: 204,
            column: 23
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 204,
            column: 4
          },
          end: {
            line: 204,
            column: 23
          }
        }, {
          start: {
            line: 204,
            column: 4
          },
          end: {
            line: 204,
            column: 23
          }
        }],
        line: 204
      },
      "14": {
        loc: {
          start: {
            line: 206,
            column: 4
          },
          end: {
            line: 208,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 206,
            column: 4
          },
          end: {
            line: 208,
            column: 5
          }
        }, {
          start: {
            line: 206,
            column: 4
          },
          end: {
            line: 208,
            column: 5
          }
        }],
        line: 206
      },
      "15": {
        loc: {
          start: {
            line: 226,
            column: 6
          },
          end: {
            line: 244,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 226,
            column: 6
          },
          end: {
            line: 244,
            column: 7
          }
        }, {
          start: {
            line: 226,
            column: 6
          },
          end: {
            line: 244,
            column: 7
          }
        }],
        line: 226
      },
      "16": {
        loc: {
          start: {
            line: 226,
            column: 10
          },
          end: {
            line: 226,
            column: 70
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 226,
            column: 10
          },
          end: {
            line: 226,
            column: 48
          }
        }, {
          start: {
            line: 226,
            column: 52
          },
          end: {
            line: 226,
            column: 70
          }
        }],
        line: 226
      },
      "17": {
        loc: {
          start: {
            line: 253,
            column: 12
          },
          end: {
            line: 253,
            column: 30
          }
        },
        type: "default-arg",
        locations: [{
          start: {
            line: 253,
            column: 20
          },
          end: {
            line: 253,
            column: 30
          }
        }],
        line: 253
      },
      "18": {
        loc: {
          start: {
            line: 266,
            column: 4
          },
          end: {
            line: 266,
            column: 46
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 266,
            column: 4
          },
          end: {
            line: 266,
            column: 46
          }
        }, {
          start: {
            line: 266,
            column: 4
          },
          end: {
            line: 266,
            column: 46
          }
        }],
        line: 266
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0,
      "23": 0,
      "24": 0,
      "25": 0,
      "26": 0,
      "27": 0,
      "28": 0,
      "29": 0,
      "30": 0,
      "31": 0,
      "32": 0,
      "33": 0,
      "34": 0,
      "35": 0,
      "36": 0,
      "37": 0,
      "38": 0,
      "39": 0,
      "40": 0,
      "41": 0,
      "42": 0,
      "43": 0,
      "44": 0,
      "45": 0,
      "46": 0,
      "47": 0,
      "48": 0,
      "49": 0,
      "50": 0,
      "51": 0,
      "52": 0,
      "53": 0,
      "54": 0,
      "55": 0,
      "56": 0,
      "57": 0,
      "58": 0,
      "59": 0,
      "60": 0,
      "61": 0,
      "62": 0,
      "63": 0,
      "64": 0,
      "65": 0,
      "66": 0,
      "67": 0,
      "68": 0,
      "69": 0,
      "70": 0,
      "71": 0,
      "72": 0,
      "73": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0],
      "4": [0, 0],
      "5": [0, 0],
      "6": [0, 0],
      "7": [0, 0],
      "8": [0, 0],
      "9": [0, 0],
      "10": [0, 0],
      "11": [0, 0],
      "12": [0, 0],
      "13": [0, 0],
      "14": [0, 0],
      "15": [0, 0],
      "16": [0, 0],
      "17": [0],
      "18": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "c6f8879a25ecbed105cf5c19a3aada49cefea075"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_1z72eol64x = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_1z72eol64x();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-syle
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */



/**
 * Token
 *
 * Component that represents a board game piece (or token).
 * Can be used by itself or with one of the grid systems
 * provided (Grid or HexGrid).
 *
 * A token renders as a square inside a Grid and a
 * hexagon inside a HexGrid. Additionally, you can pass
 * it a child if you want any other custom rendering.
 *
 * Props:
 *   x       - X coordinate on grid / hex grid.
 *   y       - Y coordinate on grid / hex grid.
 *   z       - Z coordinate on hex grid.
 *   animate - Changes in position are animated if true.
 *   animationDuration - Length of animation.
 *   onClick - Called when the token is clicked.
 *   onMouseOver - Called when the token is mouse over.
 *   onMouseOut - Called when the token is mouse out.
 *   draggable - Whether a Token is draggable or not.
 *   shouldDrag - Whether a draggable token should start drag.
 *   onDrag - Called when a token was dragged (moved).
 *            Parameter contain { x, y, originalX, originalY }.
 *   onDrop - Called when the token was dropped after dragging.
 *            Parameter contain { x, y, originalX, originalY }.
 *
 * Usage:
 *
 * <Grid rows={8} cols={8}>
 *   <Token x={1} y={2}/>
 * </Grid>
 *
 * <HexGrid>
 *   <Token x={1} y={2} z={-3}/>
 * </HexGrid>
 *
 * <Grid rows={8} cols={8}>
 *   <Token x={1} y={2}>
 *     <Knight color="white"/>
 *   </Token>
 * </Grid>
 */

var Token = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(Token, _React$Component);

  var _super = _createSuper(Token);

  function Token(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Token);

    cov_1z72eol64x().f[0]++;
    cov_1z72eol64x().s[2]++;
    _this = _super.call(this, props);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_startDrag", (cov_1z72eol64x().s[4]++, function (e) {
      cov_1z72eol64x().f[1]++;
      cov_1z72eol64x().s[5]++;

      if ((cov_1z72eol64x().b[1][0]++, _this.props.draggable) && (cov_1z72eol64x().b[1][1]++, _this.props.shouldDrag(_this.getCoords()))) {
        cov_1z72eol64x().b[0][0]++;
        cov_1z72eol64x().s[6]++;
        e.preventDefault(); // Required for Safari/iOs.

        cov_1z72eol64x().s[7]++;
        e = e.touches ? (cov_1z72eol64x().b[2][0]++, e.touches[0]) : (cov_1z72eol64x().b[2][1]++, e);
        cov_1z72eol64x().s[8]++;

        _this.setState(_objectSpread({}, _this.state, {
          dragged: {
            x: e.pageX,
            y: e.pageY
          }
        }));

        cov_1z72eol64x().s[9]++;

        _this._addOrRemoveDragEventListeners(true);
      } else {
        cov_1z72eol64x().b[0][1]++;
      }
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_drag", (cov_1z72eol64x().s[10]++, function (e) {
      cov_1z72eol64x().f[2]++;
      cov_1z72eol64x().s[11]++;

      if (_this.state.dragged) {
        cov_1z72eol64x().b[3][0]++;
        cov_1z72eol64x().s[12]++;
        e.preventDefault(); // Required for Safari/iOs.

        cov_1z72eol64x().s[13]++;
        e = e.touches ? (cov_1z72eol64x().b[4][0]++, e.touches[0]) : (cov_1z72eol64x().b[4][1]++, e);
        var ctm = (cov_1z72eol64x().s[14]++, _this.props.svgRef.current.getScreenCTM().inverse());
        var deltaPageX = (cov_1z72eol64x().s[15]++, e.pageX - _this.state.dragged.x);
        var deltaPageY = (cov_1z72eol64x().s[16]++, e.pageY - _this.state.dragged.y);
        var deltaSvgX = (cov_1z72eol64x().s[17]++, ctm.a * deltaPageX + ctm.b * deltaPageY);
        var deltaSvgY = (cov_1z72eol64x().s[18]++, ctm.c * deltaPageX + ctm.d * deltaPageY);
        var x = (cov_1z72eol64x().s[19]++, _this.state.x + deltaSvgX);
        var y = (cov_1z72eol64x().s[20]++, _this.state.y + deltaSvgY);
        cov_1z72eol64x().s[21]++;

        if (_this.props.onDrag) {
          cov_1z72eol64x().b[5][0]++;
          cov_1z72eol64x().s[22]++;

          _this.props.onDrag({
            x: x,
            y: y,
            originalX: _this.props.x,
            originalY: _this.props.y
          });
        } else {
          cov_1z72eol64x().b[5][1]++;
        }

        cov_1z72eol64x().s[23]++;

        _this.setState(_objectSpread({}, _this.state, {
          x: x,
          y: y,
          dragged: {
            x: e.pageX,
            y: e.pageY
          }
        }));
      } else {
        cov_1z72eol64x().b[3][1]++;
      }
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_endDrag", (cov_1z72eol64x().s[24]++, function (e) {
      cov_1z72eol64x().f[3]++;
      cov_1z72eol64x().s[25]++;

      if (_this.state.dragged) {
        cov_1z72eol64x().b[6][0]++;
        cov_1z72eol64x().s[26]++;
        e.preventDefault(); // Whether this is a drop or a click depends if the mouse moved after drag.
        // Android will issue very small drag events, so we need a distance.

        var dist = (cov_1z72eol64x().s[27]++, Math.sqrt(Math.pow(_this.state.x - _this.props.x, 2) + Math.pow(_this.state.y - _this.props.y, 2)));
        cov_1z72eol64x().s[28]++;

        if (dist > 0.2) {
          cov_1z72eol64x().b[7][0]++;
          cov_1z72eol64x().s[29]++;

          _this.props.onDrop({
            x: _this.state.x,
            y: _this.state.y,
            originalX: _this.props.x,
            originalY: _this.props.y
          });
        } else {
          cov_1z72eol64x().b[7][1]++;
          cov_1z72eol64x().s[30]++;

          _this.props.onClick({
            x: _this.state.x,
            y: _this.state.y
          });
        }

        cov_1z72eol64x().s[31]++;

        _this.setState(_objectSpread({}, _this.state, {
          x: _this.props.x,
          y: _this.props.y,
          dragged: null
        }));

        cov_1z72eol64x().s[32]++;

        _this._addOrRemoveDragEventListeners(false);
      } else {
        cov_1z72eol64x().b[6][1]++;
      }
    }));

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_onClick", (cov_1z72eol64x().s[33]++, function (param) {
      cov_1z72eol64x().f[4]++;
      cov_1z72eol64x().s[34]++;

      // Ignore onClick if the element is draggable, because desktops will
      // send both onClick and touch events, leading to duplication.
      // Whether this will be a click or a drop will be defined in _endDrag.
      if (!((cov_1z72eol64x().b[9][0]++, _this.props.draggable) && (cov_1z72eol64x().b[9][1]++, _this.props.shouldDrag(_this.getCoords())))) {
        cov_1z72eol64x().b[8][0]++;
        cov_1z72eol64x().s[35]++;

        _this.props.onClick(param);
      } else {
        cov_1z72eol64x().b[8][1]++;
      }
    }));

    cov_1z72eol64x().s[3]++;
    _this.state = _objectSpread({}, _this.getCoords(), {
      dragged: null,
      usingTouch: false
    });
    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Token, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cov_1z72eol64x().f[5]++;
      cov_1z72eol64x().s[36]++;

      if (this.state.dragged) {
        cov_1z72eol64x().b[10][0]++;
        cov_1z72eol64x().s[37]++;

        this._addOrRemoveDragEventListeners(false);
      } else {
        cov_1z72eol64x().b[10][1]++;
      }
    }
    /**
     * If there is a change in props, saves old x/y,
     * and current time. Starts animation.
     * @param {Object} nextProps Next props.
     */
    // eslint-disable-next-line react/no-deprecated

  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      cov_1z72eol64x().f[6]++;
      var oldCoord = (cov_1z72eol64x().s[38]++, this.getCoords());
      var newCoord = (cov_1z72eol64x().s[39]++, this.getCoords(nextProps)); // Debounce.

      cov_1z72eol64x().s[40]++;

      if ((cov_1z72eol64x().b[12][0]++, oldCoord.x == newCoord.x) && (cov_1z72eol64x().b[12][1]++, oldCoord.y == newCoord.y)) {
        cov_1z72eol64x().b[11][0]++;
        cov_1z72eol64x().s[41]++;
        return;
      } else {
        cov_1z72eol64x().b[11][1]++;
      }

      cov_1z72eol64x().s[42]++;
      this.setState(_objectSpread({}, this.state, {
        originTime: Date.now(),
        originX: this.state.x,
        originY: this.state.y,
        originZ: this.state.z
      }));
      cov_1z72eol64x().s[43]++;
      requestAnimationFrame(this._animate(Date.now()));
    }
    /**
     * Add or remove event listeners.
     * @param {boolean} shouldAdd If it should add (or remove) listeners.
     */

  }, {
    key: "_addOrRemoveDragEventListeners",
    value: function _addOrRemoveDragEventListeners(shouldAdd) {
      cov_1z72eol64x().f[7]++;
      var svgEl = (cov_1z72eol64x().s[44]++, this.props.svgRef.current);
      cov_1z72eol64x().s[45]++;

      if (!svgEl) {
        cov_1z72eol64x().b[13][0]++;
        cov_1z72eol64x().s[46]++;
        return;
      } else {
        cov_1z72eol64x().b[13][1]++;
      }

      var addOrRemoveEventListener = (cov_1z72eol64x().s[47]++, svgEl.addEventListener);
      cov_1z72eol64x().s[48]++;

      if (!shouldAdd) {
        cov_1z72eol64x().b[14][0]++;
        cov_1z72eol64x().s[49]++;
        addOrRemoveEventListener = svgEl.removeEventListener;
      } else {
        cov_1z72eol64x().b[14][1]++;
      }

      cov_1z72eol64x().s[50]++;
      addOrRemoveEventListener('touchmove', this._drag, {
        passive: false
      });
      cov_1z72eol64x().s[51]++;
      addOrRemoveEventListener('mousemove', this._drag, {
        passive: false
      });
      cov_1z72eol64x().s[52]++;
      addOrRemoveEventListener('mouseup', this._endDrag, {
        passive: false
      });
      cov_1z72eol64x().s[53]++;
      addOrRemoveEventListener('mouseleave', this._endDrag, {
        passive: false
      });
      cov_1z72eol64x().s[54]++;
      addOrRemoveEventListener('touchcancel', this._endDrag, {
        passive: false
      });
      cov_1z72eol64x().s[55]++;
      addOrRemoveEventListener('touchleave', this._endDrag, {
        passive: false
      });
      cov_1z72eol64x().s[56]++;
      addOrRemoveEventListener('touchend', this._endDrag, {
        passive: false
      });
    }
    /**
     * Recursively animates x and y.
     * @param {number} now Unix timestamp when this was called.
     */

  }, {
    key: "_animate",
    value: function _animate(now) {
      var _this2 = this;

      cov_1z72eol64x().f[8]++;
      cov_1z72eol64x().s[57]++;
      return function () {
        cov_1z72eol64x().f[9]++;
        var elapsed = (cov_1z72eol64x().s[58]++, now - _this2.state.originTime);
        var svgCoord = (cov_1z72eol64x().s[59]++, _this2.getCoords());
        cov_1z72eol64x().s[60]++;

        if ((cov_1z72eol64x().b[16][0]++, elapsed < _this2.props.animationDuration) && (cov_1z72eol64x().b[16][1]++, _this2.props.animate)) {
          cov_1z72eol64x().b[15][0]++;
          var percentage = (cov_1z72eol64x().s[61]++, _this2._easeInOutCubic(elapsed, 0, 1, _this2.props.animationDuration));
          cov_1z72eol64x().s[62]++;

          _this2.setState(_objectSpread({}, _this2.state, {
            x: (svgCoord.x - _this2.state.originX) * percentage + _this2.state.originX,
            y: (svgCoord.y - _this2.state.originY) * percentage + _this2.state.originY,
            z: (svgCoord.z - _this2.state.originZ) * percentage + _this2.state.originZ
          }));

          cov_1z72eol64x().s[63]++;
          requestAnimationFrame(_this2._animate(Date.now()));
        } else {
          cov_1z72eol64x().b[15][1]++;
          cov_1z72eol64x().s[64]++;

          _this2.setState(_objectSpread({}, _this2.state, {
            x: svgCoord.x,
            y: svgCoord.y,
            z: svgCoord.z
          }));
        }
      }.bind(this);
    }
    /**
     * Gets SVG x/y/z coordinates.
     * @param {Object} props Props object to get coordinates from.
     * @return {Object} Object with x, y and z parameters.
     */

  }, {
    key: "getCoords",
    value: function getCoords() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (cov_1z72eol64x().b[17][0]++, this.props);
      cov_1z72eol64x().f[10]++;
      cov_1z72eol64x().s[65]++;
      return {
        x: props.x,
        y: props.y,
        z: props.z
      };
    }
    /**
     * Returns animation easing value. See http://easings.net/#easeInOutCubic.
     * @param {number} t Current time.
     * @param {number} b Beginning value.
     * @param {number} c Final value.
     * @param {number} d Duration.
     */

  }, {
    key: "_easeInOutCubic",
    value: function _easeInOutCubic(t, b, c, d) {
      cov_1z72eol64x().f[11]++;
      cov_1z72eol64x().s[66]++;
      t /= d / 2;
      cov_1z72eol64x().s[67]++;

      if (t < 1) {
        cov_1z72eol64x().b[18][0]++;
        cov_1z72eol64x().s[68]++;
        return c / 2 * t * t * t + b;
      } else {
        cov_1z72eol64x().b[18][1]++;
      }

      cov_1z72eol64x().s[69]++;
      t -= 2;
      cov_1z72eol64x().s[70]++;
      return c / 2 * (t * t * t + 2) + b;
    }
    /**
     * Gets event listeners needed for drag and drop.
     */

  }, {
    key: "_eventListeners",
    value: function _eventListeners() {
      cov_1z72eol64x().f[12]++;
      cov_1z72eol64x().s[71]++;
      return [{
        name: 'mousedown',
        callback: this._startDrag
      }, {
        name: 'touchstart',
        callback: this._startDrag
      }];
    }
  }, {
    key: "render",
    value: function render() {
      cov_1z72eol64x().f[13]++;
      var Component = (cov_1z72eol64x().s[72]++, this.props.template);
      cov_1z72eol64x().s[73]++;
      return __jsx(Component, {
        x: this.state.x,
        y: this.state.y,
        z: this.state.z,
        style: this.props.style,
        onClick: this._onClick,
        onMouseOver: this.props.onMouseOver,
        onMouseOut: this.props.onMouseOut,
        eventListeners: this._eventListeners()
      }, this.props.children);
    }
  }]);

  return Token;
}((react__WEBPACK_IMPORTED_MODULE_7___default.a.Component));

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Token, "propTypes", (cov_1z72eol64x().s[0]++, {
  x: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number,
  y: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number,
  z: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number,
  template: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.any,
  style: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.any,
  animate: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.bool,
  onClick: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  onMouseOver: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  onMouseOut: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  children: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.element,
  animationDuration: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number,
  draggable: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.bool,
  shouldDrag: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  onDrag: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  onDrop: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  svgRef: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.object
}));

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Token, "defaultProps", (cov_1z72eol64x().s[1]++, {
  animationDuration: 750,
  template: _grid__WEBPACK_IMPORTED_MODULE_9__["Square"]
}));

/***/ }),

/***/ "./src/ui/3d/grid.js":
/*!***************************!*\
  !*** ./src/ui/3d/grid.js ***!
  \***************************/
/*! exports provided: Grid, Square */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Grid", function() { return Grid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Square", function() { return Square; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _ui_context__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../ui-context */ "./src/ui/ui-context.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");







var __jsx = react__WEBPACK_IMPORTED_MODULE_7___default.a.createElement;

function cov_2geif4paxx() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/ui/3d/grid.js";
  var hash = "60be24e60e690085488ca621dcf8c5e69c1f2bb4";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/ui/3d/grid.js",
    statementMap: {
      "0": {
        start: {
          line: 39,
          column: 20
        },
        end: {
          line: 41,
          column: 1
        }
      },
      "1": {
        start: {
          line: 40,
          column: 2
        },
        end: {
          line: 40,
          column: 99
        }
      },
      "2": {
        start: {
          line: 40,
          column: 36
        },
        end: {
          line: 40,
          column: 77
        }
      },
      "3": {
        start: {
          line: 44,
          column: 21
        },
        end: {
          line: 56,
          column: 3
        }
      },
      "4": {
        start: {
          line: 57,
          column: 24
        },
        end: {
          line: 62,
          column: 3
        }
      },
      "5": {
        start: {
          line: 65,
          column: 4
        },
        end: {
          line: 65,
          column: 17
        }
      },
      "6": {
        start: {
          line: 66,
          column: 4
        },
        end: {
          line: 66,
          column: 40
        }
      },
      "7": {
        start: {
          line: 67,
          column: 4
        },
        end: {
          line: 67,
          column: 40
        }
      },
      "8": {
        start: {
          line: 68,
          column: 4
        },
        end: {
          line: 68,
          column: 41
        }
      },
      "9": {
        start: {
          line: 70,
          column: 4
        },
        end: {
          line: 70,
          column: 106
        }
      },
      "10": {
        start: {
          line: 71,
          column: 4
        },
        end: {
          line: 71,
          column: 106
        }
      },
      "11": {
        start: {
          line: 75,
          column: 16
        },
        end: {
          line: 75,
          column: 27
        }
      },
      "12": {
        start: {
          line: 76,
          column: 16
        },
        end: {
          line: 76,
          column: 25
        }
      },
      "13": {
        start: {
          line: 77,
          column: 4
        },
        end: {
          line: 79,
          column: 5
        }
      },
      "14": {
        start: {
          line: 78,
          column: 6
        },
        end: {
          line: 78,
          column: 39
        }
      },
      "15": {
        start: {
          line: 80,
          column: 4
        },
        end: {
          line: 80,
          column: 17
        }
      },
      "16": {
        start: {
          line: 84,
          column: 4
        },
        end: {
          line: 84,
          column: 41
        }
      },
      "17": {
        start: {
          line: 88,
          column: 4
        },
        end: {
          line: 88,
          column: 38
        }
      },
      "18": {
        start: {
          line: 89,
          column: 4
        },
        end: {
          line: 89,
          column: 38
        }
      },
      "19": {
        start: {
          line: 92,
          column: 4
        },
        end: {
          line: 92,
          column: 45
        }
      },
      "20": {
        start: {
          line: 93,
          column: 4
        },
        end: {
          line: 93,
          column: 41
        }
      },
      "21": {
        start: {
          line: 94,
          column: 4
        },
        end: {
          line: 94,
          column: 42
        }
      },
      "22": {
        start: {
          line: 97,
          column: 4
        },
        end: {
          line: 123,
          column: 5
        }
      },
      "23": {
        start: {
          line: 97,
          column: 17
        },
        end: {
          line: 97,
          column: 18
        }
      },
      "24": {
        start: {
          line: 98,
          column: 6
        },
        end: {
          line: 122,
          column: 7
        }
      },
      "25": {
        start: {
          line: 98,
          column: 19
        },
        end: {
          line: 98,
          column: 20
        }
      },
      "26": {
        start: {
          line: 99,
          column: 28
        },
        end: {
          line: 106,
          column: 9
        }
      },
      "27": {
        start: {
          line: 108,
          column: 23
        },
        end: {
          line: 108,
          column: 46
        }
      },
      "28": {
        start: {
          line: 109,
          column: 8
        },
        end: {
          line: 109,
          column: 37
        }
      },
      "29": {
        start: {
          line: 111,
          column: 24
        },
        end: {
          line: 119,
          column: 9
        }
      },
      "30": {
        start: {
          line: 112,
          column: 10
        },
        end: {
          line: 118,
          column: 11
        }
      },
      "31": {
        start: {
          line: 113,
          column: 12
        },
        end: {
          line: 113,
          column: 71
        }
      },
      "32": {
        start: {
          line: 113,
          column: 36
        },
        end: {
          line: 113,
          column: 71
        }
      },
      "33": {
        start: {
          line: 114,
          column: 17
        },
        end: {
          line: 118,
          column: 11
        }
      },
      "34": {
        start: {
          line: 115,
          column: 12
        },
        end: {
          line: 115,
          column: 79
        }
      },
      "35": {
        start: {
          line: 115,
          column: 40
        },
        end: {
          line: 115,
          column: 79
        }
      },
      "36": {
        start: {
          line: 116,
          column: 17
        },
        end: {
          line: 118,
          column: 11
        }
      },
      "37": {
        start: {
          line: 117,
          column: 12
        },
        end: {
          line: 117,
          column: 77
        }
      },
      "38": {
        start: {
          line: 117,
          column: 39
        },
        end: {
          line: 117,
          column: 77
        }
      },
      "39": {
        start: {
          line: 121,
          column: 8
        },
        end: {
          line: 121,
          column: 46
        }
      },
      "40": {
        start: {
          line: 126,
          column: 19
        },
        end: {
          line: 134,
          column: 6
        }
      },
      "41": {
        start: {
          line: 127,
          column: 6
        },
        end: {
          line: 133,
          column: 9
        }
      },
      "42": {
        start: {
          line: 136,
          column: 4
        },
        end: {
          line: 138,
          column: 5
        }
      },
      "43": {
        start: {
          line: 137,
          column: 6
        },
        end: {
          line: 137,
          column: 20
        }
      },
      "44": {
        start: {
          line: 140,
          column: 4
        },
        end: {
          line: 140,
          column: 16
        }
      },
      "45": {
        start: {
          line: 162,
          column: 4
        },
        end: {
          line: 162,
          column: 12
        }
      },
      "46": {
        start: {
          line: 163,
          column: 4
        },
        end: {
          line: 167,
          column: 6
        }
      },
      "47": {
        start: {
          line: 168,
          column: 4
        },
        end: {
          line: 168,
          column: 26
        }
      },
      "48": {
        start: {
          line: 169,
          column: 4
        },
        end: {
          line: 169,
          column: 89
        }
      },
      "49": {
        start: {
          line: 170,
          column: 4
        },
        end: {
          line: 170,
          column: 74
        }
      },
      "50": {
        start: {
          line: 172,
          column: 4
        },
        end: {
          line: 172,
          column: 30
        }
      },
      "51": {
        start: {
          line: 173,
          column: 4
        },
        end: {
          line: 173,
          column: 68
        }
      },
      "52": {
        start: {
          line: 174,
          column: 4
        },
        end: {
          line: 174,
          column: 68
        }
      },
      "53": {
        start: {
          line: 175,
          column: 4
        },
        end: {
          line: 175,
          column: 49
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 39,
            column: 20
          },
          end: {
            line: 39,
            column: 21
          }
        },
        loc: {
          start: {
            line: 40,
            column: 2
          },
          end: {
            line: 40,
            column: 99
          }
        },
        line: 40
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 40,
            column: 23
          },
          end: {
            line: 40,
            column: 24
          }
        },
        loc: {
          start: {
            line: 40,
            column: 36
          },
          end: {
            line: 40,
            column: 77
          }
        },
        line: 40
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 64,
            column: 2
          },
          end: {
            line: 64,
            column: 3
          }
        },
        loc: {
          start: {
            line: 64,
            column: 21
          },
          end: {
            line: 72,
            column: 3
          }
        },
        line: 64
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 74,
            column: 2
          },
          end: {
            line: 74,
            column: 3
          }
        },
        loc: {
          start: {
            line: 74,
            column: 22
          },
          end: {
            line: 81,
            column: 3
          }
        },
        line: 74
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 83,
            column: 2
          },
          end: {
            line: 83,
            column: 3
          }
        },
        loc: {
          start: {
            line: 83,
            column: 25
          },
          end: {
            line: 85,
            column: 3
          }
        },
        line: 83
      },
      "5": {
        name: "(anonymous_5)",
        decl: {
          start: {
            line: 87,
            column: 2
          },
          end: {
            line: 87,
            column: 3
          }
        },
        loc: {
          start: {
            line: 87,
            column: 11
          },
          end: {
            line: 141,
            column: 3
          }
        },
        line: 87
      },
      "6": {
        name: "(anonymous_6)",
        decl: {
          start: {
            line: 111,
            column: 24
          },
          end: {
            line: 111,
            column: 25
          }
        },
        loc: {
          start: {
            line: 111,
            column: 31
          },
          end: {
            line: 119,
            column: 9
          }
        },
        line: 111
      },
      "7": {
        name: "(anonymous_7)",
        decl: {
          start: {
            line: 126,
            column: 59
          },
          end: {
            line: 126,
            column: 60
          }
        },
        loc: {
          start: {
            line: 126,
            column: 70
          },
          end: {
            line: 134,
            column: 5
          }
        },
        line: 126
      },
      "8": {
        name: "(anonymous_8)",
        decl: {
          start: {
            line: 161,
            column: 2
          },
          end: {
            line: 161,
            column: 3
          }
        },
        loc: {
          start: {
            line: 161,
            column: 21
          },
          end: {
            line: 176,
            column: 3
          }
        },
        line: 161
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 77,
            column: 4
          },
          end: {
            line: 79,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 77,
            column: 4
          },
          end: {
            line: 79,
            column: 5
          }
        }, {
          start: {
            line: 77,
            column: 4
          },
          end: {
            line: 79,
            column: 5
          }
        }],
        line: 77
      },
      "1": {
        loc: {
          start: {
            line: 112,
            column: 10
          },
          end: {
            line: 118,
            column: 11
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 112,
            column: 10
          },
          end: {
            line: 118,
            column: 11
          }
        }, {
          start: {
            line: 112,
            column: 10
          },
          end: {
            line: 118,
            column: 11
          }
        }],
        line: 112
      },
      "2": {
        loc: {
          start: {
            line: 113,
            column: 12
          },
          end: {
            line: 113,
            column: 71
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 113,
            column: 12
          },
          end: {
            line: 113,
            column: 71
          }
        }, {
          start: {
            line: 113,
            column: 12
          },
          end: {
            line: 113,
            column: 71
          }
        }],
        line: 113
      },
      "3": {
        loc: {
          start: {
            line: 114,
            column: 17
          },
          end: {
            line: 118,
            column: 11
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 114,
            column: 17
          },
          end: {
            line: 118,
            column: 11
          }
        }, {
          start: {
            line: 114,
            column: 17
          },
          end: {
            line: 118,
            column: 11
          }
        }],
        line: 114
      },
      "4": {
        loc: {
          start: {
            line: 115,
            column: 12
          },
          end: {
            line: 115,
            column: 79
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 115,
            column: 12
          },
          end: {
            line: 115,
            column: 79
          }
        }, {
          start: {
            line: 115,
            column: 12
          },
          end: {
            line: 115,
            column: 79
          }
        }],
        line: 115
      },
      "5": {
        loc: {
          start: {
            line: 116,
            column: 17
          },
          end: {
            line: 118,
            column: 11
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 116,
            column: 17
          },
          end: {
            line: 118,
            column: 11
          }
        }, {
          start: {
            line: 116,
            column: 17
          },
          end: {
            line: 118,
            column: 11
          }
        }],
        line: 116
      },
      "6": {
        loc: {
          start: {
            line: 117,
            column: 12
          },
          end: {
            line: 117,
            column: 77
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 117,
            column: 12
          },
          end: {
            line: 117,
            column: 77
          }
        }, {
          start: {
            line: 117,
            column: 12
          },
          end: {
            line: 117,
            column: 77
          }
        }],
        line: 117
      },
      "7": {
        loc: {
          start: {
            line: 136,
            column: 4
          },
          end: {
            line: 138,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 136,
            column: 4
          },
          end: {
            line: 138,
            column: 5
          }
        }, {
          start: {
            line: 136,
            column: 4
          },
          end: {
            line: 138,
            column: 5
          }
        }],
        line: 136
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0,
      "23": 0,
      "24": 0,
      "25": 0,
      "26": 0,
      "27": 0,
      "28": 0,
      "29": 0,
      "30": 0,
      "31": 0,
      "32": 0,
      "33": 0,
      "34": 0,
      "35": 0,
      "36": 0,
      "37": 0,
      "38": 0,
      "39": 0,
      "40": 0,
      "41": 0,
      "42": 0,
      "43": 0,
      "44": 0,
      "45": 0,
      "46": 0,
      "47": 0,
      "48": 0,
      "49": 0,
      "50": 0,
      "51": 0,
      "52": 0,
      "53": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0],
      "4": [0, 0],
      "5": [0, 0],
      "6": [0, 0],
      "7": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "60be24e60e690085488ca621dcf8c5e69c1f2bb4"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2geif4paxx = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2geif4paxx();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */




/**
 * Grid
 *
 * Component that will show children on a cartesian regular grid.
 *
 * Props:
 *   rows       - Number of rows (height) of the grid.
 *   cols       - Number of columns (width) of the grid.
 *   cellSize   - Size of a square.
 *   thichness  - Thichness of a square.
 *   padding    - Padding between squares.
 *   colorMap   - A map from 'x,y' => color.
 *   onClick    - (x, y) => {}
 *                Called when a square is clicked.
 *   onMouseOver    - (x, y) => {}
 *                Called when a square is mouse over.
 *   onMouseOut    - (x, y) => {}
 *                Called when a square is mouse out.
 *
 * Usage:
 *
 * <Grid rows={8} cols={8}>
 *   <Token x={1} y={2}/>
 * </Grid>
 */

cov_2geif4paxx().s[0]++;
var Grid = function Grid(props) {
  cov_2geif4paxx().f[0]++;
  cov_2geif4paxx().s[1]++;
  return __jsx(_ui_context__WEBPACK_IMPORTED_MODULE_9__["default"].Consumer, null, function (context) {
    cov_2geif4paxx().f[1]++;
    cov_2geif4paxx().s[2]++;
    return __jsx(GridImpl, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({}, props, {
      context: context
    }));
  });
};

var GridImpl = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(GridImpl, _React$Component);

  var _super = _createSuper(GridImpl);

  function GridImpl(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, GridImpl);

    cov_2geif4paxx().f[2]++;
    cov_2geif4paxx().s[5]++;
    _this = _super.call(this, props);
    cov_2geif4paxx().s[6]++;
    _this.boardGroup = new three__WEBPACK_IMPORTED_MODULE_10__["Group"]();
    cov_2geif4paxx().s[7]++;
    _this.tokenGroup = new three__WEBPACK_IMPORTED_MODULE_10__["Group"]();
    cov_2geif4paxx().s[8]++;

    _this.boardGroup.add(_this.tokenGroup); // translate the board to center on (0,0,0)


    cov_2geif4paxx().s[9]++;

    _this.boardGroup.translateX(-(_this.props.padding + _this.props.cellSize) * (_this.props.cols - 1) / 2);

    cov_2geif4paxx().s[10]++;

    _this.boardGroup.translateZ(-(_this.props.padding + _this.props.cellSize) * (_this.props.rows - 1) / 2);

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(GridImpl, [{
    key: "_getCellColor",
    value: function _getCellColor(x, y) {
      cov_2geif4paxx().f[3]++;
      var key = (cov_2geif4paxx().s[11]++, "".concat(x, ",").concat(y));
      var color = (cov_2geif4paxx().s[12]++, '#777777');
      cov_2geif4paxx().s[13]++;

      if (key in this.props.colorMap) {
        cov_2geif4paxx().b[0][0]++;
        cov_2geif4paxx().s[14]++;
        color = this.props.colorMap[key];
      } else {
        cov_2geif4paxx().b[0][1]++;
      }

      cov_2geif4paxx().s[15]++;
      return color;
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cov_2geif4paxx().f[4]++;
      cov_2geif4paxx().s[16]++;
      this.context.remove(this.boardGroup);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      cov_2geif4paxx().f[5]++;
      cov_2geif4paxx().s[17]++;
      this.context = this.props.context;
      cov_2geif4paxx().s[18]++;
      this.context.add(this.boardGroup); // when rerendering, render a new squareGroup

      cov_2geif4paxx().s[19]++;
      this.boardGroup.remove(this.squareGroup);
      cov_2geif4paxx().s[20]++;
      this.squareGroup = new three__WEBPACK_IMPORTED_MODULE_10__["Group"]();
      cov_2geif4paxx().s[21]++;
      this.boardGroup.add(this.squareGroup); // add square base

      cov_2geif4paxx().s[22]++;

      var _loop = function _loop(x) {
        cov_2geif4paxx().s[24]++;

        var _loop2 = function _loop2(y) {
          var squareProps = (cov_2geif4paxx().s[26]++, {
            x: x,
            y: y,
            size: _this2.props.cellSize,
            color: _this2._getCellColor(x, y),
            padding: _this2.props.padding,
            thickness: _this2.props.thickness
          });
          var square = (cov_2geif4paxx().s[27]++, new Square(squareProps));
          cov_2geif4paxx().s[28]++;

          _this2.squareGroup.add(square);

          cov_2geif4paxx().s[29]++;

          var onEvent = function onEvent(e) {
            cov_2geif4paxx().f[6]++;
            cov_2geif4paxx().s[30]++;

            if (e.type == 'click') {
              cov_2geif4paxx().b[1][0]++;
              cov_2geif4paxx().s[31]++;

              if (_this2.props.onClick) {
                cov_2geif4paxx().b[2][0]++;
                cov_2geif4paxx().s[32]++;

                _this2.props.onClick({
                  x: x,
                  y: y
                });
              } else {
                cov_2geif4paxx().b[2][1]++;
              }
            } else {
              cov_2geif4paxx().b[1][1]++;
              cov_2geif4paxx().s[33]++;

              if (e.type == 'mouseOver') {
                cov_2geif4paxx().b[3][0]++;
                cov_2geif4paxx().s[34]++;

                if (_this2.props.onMouseOver) {
                  cov_2geif4paxx().b[4][0]++;
                  cov_2geif4paxx().s[35]++;

                  _this2.props.onMouseOver({
                    x: x,
                    y: y
                  });
                } else {
                  cov_2geif4paxx().b[4][1]++;
                }
              } else {
                cov_2geif4paxx().b[3][1]++;
                cov_2geif4paxx().s[36]++;

                if (e.type == 'mouseOut') {
                  cov_2geif4paxx().b[5][0]++;
                  cov_2geif4paxx().s[37]++;

                  if (_this2.props.onMouseOut) {
                    cov_2geif4paxx().b[6][0]++;
                    cov_2geif4paxx().s[38]++;

                    _this2.props.onMouseOut({
                      x: x,
                      y: y
                    });
                  } else {
                    cov_2geif4paxx().b[6][1]++;
                  }
                } else {
                  cov_2geif4paxx().b[5][1]++;
                }
              }
            }
          };

          cov_2geif4paxx().s[39]++;

          _this2.context.regCall(square, onEvent);
        };

        for (var y = (cov_2geif4paxx().s[25]++, 0); y < _this2.props.rows; y++) {
          _loop2(y);
        }
      };

      for (var x = (cov_2geif4paxx().s[23]++, 0); x < this.props.cols; x++) {
        _loop(x);
      } // set tokens


      var tokens = (cov_2geif4paxx().s[40]++, react__WEBPACK_IMPORTED_MODULE_7___default.a.Children.map(this.props.children, function (child) {
        cov_2geif4paxx().f[7]++;
        cov_2geif4paxx().s[41]++;
        return react__WEBPACK_IMPORTED_MODULE_7___default.a.cloneElement(child, {
          three: true,
          boardSize: _this2.props.cellSize,
          parent: _this2.tokenGroup,
          padding: _this2.props.padding,
          lift: _this2.props.thickness
        });
      }));
      cov_2geif4paxx().s[42]++;

      if (tokens) {
        cov_2geif4paxx().b[7][0]++;
        cov_2geif4paxx().s[43]++;
        return tokens;
      } else {
        cov_2geif4paxx().b[7][1]++;
      }

      cov_2geif4paxx().s[44]++;
      return null;
    }
  }]);

  return GridImpl;
}((react__WEBPACK_IMPORTED_MODULE_7___default.a.Component));
/**
 * Square
 *
 * Component that renders a square inside a Grid.
 *
 * Props
 *   x          - X coordinate on grid coordinates.
 *   y          - Y coordinate on grid coordinates.
 *   size       - Square size.
 *   color      - Color of the square
 *   thichness  - Thichness of a square.
 *   padding    - Padding between squares.
 *
 * Not meant to be used by the end user directly (use Token).
 * Also not exposed in the NPM.
 */


Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])(GridImpl, "propTypes", (cov_2geif4paxx().s[3]++, {
  rows: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number.isRequired,
  cols: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number.isRequired,
  cellSize: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number,
  thickness: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number,
  padding: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.number,
  colorMap: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.object,
  onClick: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  onMouseOver: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  onMouseOut: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.func,
  context: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.any,
  children: prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.element), prop_types__WEBPACK_IMPORTED_MODULE_8___default.a.element])
}));

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_5__["default"])(GridImpl, "defaultProps", (cov_2geif4paxx().s[4]++, {
  colorMap: {},
  cellSize: 1,
  padding: 0.1,
  thickness: 0.1
}));

var Square = /*#__PURE__*/function (_THREE$Mesh) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Square, _THREE$Mesh);

  var _super2 = _createSuper(Square);

  function Square(props) {
    var _this3;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Square);

    cov_2geif4paxx().f[8]++;
    cov_2geif4paxx().s[45]++;
    _this3 = _super2.call(this);
    cov_2geif4paxx().s[46]++;
    _this3.userData = _objectSpread({
      responsive: true,
      draggable: false
    }, props);
    cov_2geif4paxx().s[47]++;
    props = _this3.userData;
    cov_2geif4paxx().s[48]++;
    _this3.geometry = new three__WEBPACK_IMPORTED_MODULE_10__["BoxBufferGeometry"](props.size, props.thickness, props.size);
    cov_2geif4paxx().s[49]++;
    _this3.material = new three__WEBPACK_IMPORTED_MODULE_10__["MeshLambertMaterial"]({
      color: props.color
    });
    cov_2geif4paxx().s[50]++;
    _this3.receiveShadow = true;
    cov_2geif4paxx().s[51]++;

    _this3.translateX(_this3.userData.x * (props.size + props.padding));

    cov_2geif4paxx().s[52]++;

    _this3.translateZ(_this3.userData.y * (props.size + props.padding));

    cov_2geif4paxx().s[53]++;

    _this3.translateY(_this3.userData.thickness / 2);

    return _this3;
  }

  return Square;
}((three__WEBPACK_IMPORTED_MODULE_10__["Mesh"]));

/***/ }),

/***/ "./src/ui/3d/token.js":
/*!****************************!*\
  !*** ./src/ui/3d/token.js ***!
  \****************************/
/*! exports provided: Token */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _ui_context__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../ui-context */ "./src/ui/ui-context.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");








var __jsx = react__WEBPACK_IMPORTED_MODULE_8___default.a.createElement;

function cov_13qjaz260k() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/ui/3d/token.js";
  var hash = "bfac113050986871f7679bc60b3215a11e25497f";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/ui/3d/token.js",
    statementMap: {
      "0": {
        start: {
          line: 51,
          column: 21
        },
        end: {
          line: 53,
          column: 1
        }
      },
      "1": {
        start: {
          line: 52,
          column: 2
        },
        end: {
          line: 52,
          column: 100
        }
      },
      "2": {
        start: {
          line: 52,
          column: 36
        },
        end: {
          line: 52,
          column: 78
        }
      },
      "3": {
        start: {
          line: 56,
          column: 21
        },
        end: {
          line: 73,
          column: 3
        }
      },
      "4": {
        start: {
          line: 75,
          column: 24
        },
        end: {
          line: 80,
          column: 3
        }
      },
      "5": {
        start: {
          line: 83,
          column: 4
        },
        end: {
          line: 83,
          column: 12
        }
      },
      "6": {
        start: {
          line: 85,
          column: 4
        },
        end: {
          line: 89,
          column: 5
        }
      },
      "7": {
        start: {
          line: 86,
          column: 6
        },
        end: {
          line: 86,
          column: 34
        }
      },
      "8": {
        start: {
          line: 88,
          column: 6
        },
        end: {
          line: 88,
          column: 29
        }
      },
      "9": {
        start: {
          line: 91,
          column: 4
        },
        end: {
          line: 95,
          column: 5
        }
      },
      "10": {
        start: {
          line: 92,
          column: 6
        },
        end: {
          line: 92,
          column: 33
        }
      },
      "11": {
        start: {
          line: 94,
          column: 6
        },
        end: {
          line: 94,
          column: 34
        }
      },
      "12": {
        start: {
          line: 98,
          column: 16
        },
        end: {
          line: 131,
          column: 3
        }
      },
      "13": {
        start: {
          line: 99,
          column: 17
        },
        end: {
          line: 99,
          column: 26
        }
      },
      "14": {
        start: {
          line: 100,
          column: 19
        },
        end: {
          line: 100,
          column: 38
        }
      },
      "15": {
        start: {
          line: 101,
          column: 21
        },
        end: {
          line: 101,
          column: 40
        }
      },
      "16": {
        start: {
          line: 102,
          column: 17
        },
        end: {
          line: 102,
          column: 53
        }
      },
      "17": {
        start: {
          line: 103,
          column: 4
        },
        end: {
          line: 103,
          column: 27
        }
      },
      "18": {
        start: {
          line: 104,
          column: 4
        },
        end: {
          line: 104,
          column: 31
        }
      },
      "19": {
        start: {
          line: 106,
          column: 16
        },
        end: {
          line: 106,
          column: 65
        }
      },
      "20": {
        start: {
          line: 107,
          column: 4
        },
        end: {
          line: 107,
          column: 25
        }
      },
      "21": {
        start: {
          line: 108,
          column: 4
        },
        end: {
          line: 108,
          column: 40
        }
      },
      "22": {
        start: {
          line: 110,
          column: 4
        },
        end: {
          line: 118,
          column: 5
        }
      },
      "23": {
        start: {
          line: 111,
          column: 6
        },
        end: {
          line: 111,
          column: 83
        }
      },
      "24": {
        start: {
          line: 112,
          column: 6
        },
        end: {
          line: 112,
          column: 83
        }
      },
      "25": {
        start: {
          line: 113,
          column: 6
        },
        end: {
          line: 113,
          column: 54
        }
      },
      "26": {
        start: {
          line: 115,
          column: 6
        },
        end: {
          line: 115,
          column: 37
        }
      },
      "27": {
        start: {
          line: 116,
          column: 6
        },
        end: {
          line: 116,
          column: 37
        }
      },
      "28": {
        start: {
          line: 117,
          column: 6
        },
        end: {
          line: 117,
          column: 36
        }
      },
      "29": {
        start: {
          line: 119,
          column: 4
        },
        end: {
          line: 119,
          column: 26
        }
      },
      "30": {
        start: {
          line: 121,
          column: 20
        },
        end: {
          line: 129,
          column: 5
        }
      },
      "31": {
        start: {
          line: 122,
          column: 6
        },
        end: {
          line: 128,
          column: 7
        }
      },
      "32": {
        start: {
          line: 123,
          column: 8
        },
        end: {
          line: 123,
          column: 65
        }
      },
      "33": {
        start: {
          line: 124,
          column: 13
        },
        end: {
          line: 128,
          column: 7
        }
      },
      "34": {
        start: {
          line: 125,
          column: 8
        },
        end: {
          line: 125,
          column: 69
        }
      },
      "35": {
        start: {
          line: 126,
          column: 13
        },
        end: {
          line: 128,
          column: 7
        }
      },
      "36": {
        start: {
          line: 127,
          column: 8
        },
        end: {
          line: 127,
          column: 68
        }
      },
      "37": {
        start: {
          line: 130,
          column: 4
        },
        end: {
          line: 130,
          column: 46
        }
      },
      "38": {
        start: {
          line: 134,
          column: 4
        },
        end: {
          line: 134,
          column: 38
        }
      },
      "39": {
        start: {
          line: 138,
          column: 15
        },
        end: {
          line: 138,
          column: 30
        }
      },
      "40": {
        start: {
          line: 140,
          column: 4
        },
        end: {
          line: 140,
          column: 61
        }
      },
      "41": {
        start: {
          line: 140,
          column: 49
        },
        end: {
          line: 140,
          column: 61
        }
      },
      "42": {
        start: {
          line: 142,
          column: 4
        },
        end: {
          line: 152,
          column: 5
        }
      },
      "43": {
        start: {
          line: 143,
          column: 6
        },
        end: {
          line: 146,
          column: 8
        }
      },
      "44": {
        start: {
          line: 147,
          column: 6
        },
        end: {
          line: 147,
          column: 29
        }
      },
      "45": {
        start: {
          line: 148,
          column: 11
        },
        end: {
          line: 152,
          column: 5
        }
      },
      "46": {
        start: {
          line: 149,
          column: 6
        },
        end: {
          line: 149,
          column: 29
        }
      },
      "47": {
        start: {
          line: 151,
          column: 6
        },
        end: {
          line: 151,
          column: 76
        }
      },
      "48": {
        start: {
          line: 153,
          column: 4
        },
        end: {
          line: 153,
          column: 38
        }
      },
      "49": {
        start: {
          line: 154,
          column: 4
        },
        end: {
          line: 154,
          column: 25
        }
      },
      "50": {
        start: {
          line: 156,
          column: 4
        },
        end: {
          line: 156,
          column: 16
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 51,
            column: 21
          },
          end: {
            line: 51,
            column: 22
          }
        },
        loc: {
          start: {
            line: 52,
            column: 2
          },
          end: {
            line: 52,
            column: 100
          }
        },
        line: 52
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 52,
            column: 23
          },
          end: {
            line: 52,
            column: 24
          }
        },
        loc: {
          start: {
            line: 52,
            column: 36
          },
          end: {
            line: 52,
            column: 78
          }
        },
        line: 52
      },
      "2": {
        name: "(anonymous_2)",
        decl: {
          start: {
            line: 82,
            column: 2
          },
          end: {
            line: 82,
            column: 3
          }
        },
        loc: {
          start: {
            line: 82,
            column: 21
          },
          end: {
            line: 96,
            column: 3
          }
        },
        line: 82
      },
      "3": {
        name: "(anonymous_3)",
        decl: {
          start: {
            line: 98,
            column: 16
          },
          end: {
            line: 98,
            column: 17
          }
        },
        loc: {
          start: {
            line: 98,
            column: 26
          },
          end: {
            line: 131,
            column: 3
          }
        },
        line: 98
      },
      "4": {
        name: "(anonymous_4)",
        decl: {
          start: {
            line: 121,
            column: 20
          },
          end: {
            line: 121,
            column: 21
          }
        },
        loc: {
          start: {
            line: 121,
            column: 27
          },
          end: {
            line: 129,
            column: 5
          }
        },
        line: 121
      },
      "5": {
        name: "(anonymous_5)",
        decl: {
          start: {
            line: 133,
            column: 2
          },
          end: {
            line: 133,
            column: 3
          }
        },
        loc: {
          start: {
            line: 133,
            column: 25
          },
          end: {
            line: 135,
            column: 3
          }
        },
        line: 133
      },
      "6": {
        name: "(anonymous_6)",
        decl: {
          start: {
            line: 137,
            column: 2
          },
          end: {
            line: 137,
            column: 3
          }
        },
        loc: {
          start: {
            line: 137,
            column: 11
          },
          end: {
            line: 157,
            column: 3
          }
        },
        line: 137
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 85,
            column: 4
          },
          end: {
            line: 89,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 85,
            column: 4
          },
          end: {
            line: 89,
            column: 5
          }
        }, {
          start: {
            line: 85,
            column: 4
          },
          end: {
            line: 89,
            column: 5
          }
        }],
        line: 85
      },
      "1": {
        loc: {
          start: {
            line: 91,
            column: 4
          },
          end: {
            line: 95,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 91,
            column: 4
          },
          end: {
            line: 95,
            column: 5
          }
        }, {
          start: {
            line: 91,
            column: 4
          },
          end: {
            line: 95,
            column: 5
          }
        }],
        line: 91
      },
      "2": {
        loc: {
          start: {
            line: 106,
            column: 16
          },
          end: {
            line: 106,
            column: 65
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 106,
            column: 42
          },
          end: {
            line: 106,
            column: 52
          }
        }, {
          start: {
            line: 106,
            column: 55
          },
          end: {
            line: 106,
            column: 65
          }
        }],
        line: 106
      },
      "3": {
        loc: {
          start: {
            line: 110,
            column: 4
          },
          end: {
            line: 118,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 110,
            column: 4
          },
          end: {
            line: 118,
            column: 5
          }
        }, {
          start: {
            line: 110,
            column: 4
          },
          end: {
            line: 118,
            column: 5
          }
        }],
        line: 110
      },
      "4": {
        loc: {
          start: {
            line: 110,
            column: 8
          },
          end: {
            line: 110,
            column: 69
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 110,
            column: 8
          },
          end: {
            line: 110,
            column: 28
          }
        }, {
          start: {
            line: 110,
            column: 32
          },
          end: {
            line: 110,
            column: 47
          }
        }, {
          start: {
            line: 110,
            column: 51
          },
          end: {
            line: 110,
            column: 69
          }
        }],
        line: 110
      },
      "5": {
        loc: {
          start: {
            line: 122,
            column: 6
          },
          end: {
            line: 128,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 122,
            column: 6
          },
          end: {
            line: 128,
            column: 7
          }
        }, {
          start: {
            line: 122,
            column: 6
          },
          end: {
            line: 128,
            column: 7
          }
        }],
        line: 122
      },
      "6": {
        loc: {
          start: {
            line: 124,
            column: 13
          },
          end: {
            line: 128,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 124,
            column: 13
          },
          end: {
            line: 128,
            column: 7
          }
        }, {
          start: {
            line: 124,
            column: 13
          },
          end: {
            line: 128,
            column: 7
          }
        }],
        line: 124
      },
      "7": {
        loc: {
          start: {
            line: 126,
            column: 13
          },
          end: {
            line: 128,
            column: 7
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 126,
            column: 13
          },
          end: {
            line: 128,
            column: 7
          }
        }, {
          start: {
            line: 126,
            column: 13
          },
          end: {
            line: 128,
            column: 7
          }
        }],
        line: 126
      },
      "8": {
        loc: {
          start: {
            line: 140,
            column: 4
          },
          end: {
            line: 140,
            column: 61
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 140,
            column: 4
          },
          end: {
            line: 140,
            column: 61
          }
        }, {
          start: {
            line: 140,
            column: 4
          },
          end: {
            line: 140,
            column: 61
          }
        }],
        line: 140
      },
      "9": {
        loc: {
          start: {
            line: 140,
            column: 8
          },
          end: {
            line: 140,
            column: 47
          }
        },
        type: "binary-expr",
        locations: [{
          start: {
            line: 140,
            column: 8
          },
          end: {
            line: 140,
            column: 21
          }
        }, {
          start: {
            line: 140,
            column: 25
          },
          end: {
            line: 140,
            column: 47
          }
        }],
        line: 140
      },
      "10": {
        loc: {
          start: {
            line: 142,
            column: 4
          },
          end: {
            line: 152,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 142,
            column: 4
          },
          end: {
            line: 152,
            column: 5
          }
        }, {
          start: {
            line: 142,
            column: 4
          },
          end: {
            line: 152,
            column: 5
          }
        }],
        line: 142
      },
      "11": {
        loc: {
          start: {
            line: 148,
            column: 11
          },
          end: {
            line: 152,
            column: 5
          }
        },
        type: "if",
        locations: [{
          start: {
            line: 148,
            column: 11
          },
          end: {
            line: 152,
            column: 5
          }
        }, {
          start: {
            line: 148,
            column: 11
          },
          end: {
            line: 152,
            column: 5
          }
        }],
        line: 148
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0,
      "7": 0,
      "8": 0,
      "9": 0,
      "10": 0,
      "11": 0,
      "12": 0,
      "13": 0,
      "14": 0,
      "15": 0,
      "16": 0,
      "17": 0,
      "18": 0,
      "19": 0,
      "20": 0,
      "21": 0,
      "22": 0,
      "23": 0,
      "24": 0,
      "25": 0,
      "26": 0,
      "27": 0,
      "28": 0,
      "29": 0,
      "30": 0,
      "31": 0,
      "32": 0,
      "33": 0,
      "34": 0,
      "35": 0,
      "36": 0,
      "37": 0,
      "38": 0,
      "39": 0,
      "40": 0,
      "41": 0,
      "42": 0,
      "43": 0,
      "44": 0,
      "45": 0,
      "46": 0,
      "47": 0,
      "48": 0,
      "49": 0,
      "50": 0
    },
    f: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0,
      "6": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0],
      "2": [0, 0],
      "3": [0, 0],
      "4": [0, 0, 0],
      "5": [0, 0],
      "6": [0, 0],
      "7": [0, 0],
      "8": [0, 0],
      "9": [0, 0],
      "10": [0, 0],
      "11": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "bfac113050986871f7679bc60b3215a11e25497f"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_13qjaz260k = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_13qjaz260k();

function _createSuper(Derived) { return function () { var Super = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-syle
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */




/**
 * Token
 *
 * Component that represents a board game piece (or token).
 * Can be used by itself or with one of the grid systems
 * provided (Grid or HexGrid).
 *
 * A token renders as a 3D Mesh. IF no mesh prop is passed.
 * It will render a white box on the grid.
 *
 * Props:
 *   x       - X coordinate on grid / hex grid.
 *   y       - Y coordinate on grid / hex grid.
 *   z       - Z coordinate on hex grid.
 *   onClick - Called when the token is clicked.
 *   onMouseOver - Called when the token is mouse over.
 *   onMouseOut - Called when the token is mouse out.
 *
 * Usage:
 *
 * <Grid rows={8} cols={8}>
 *   <Token x={1} y={2}/>
 * </Grid>
 *
 * <Grid rows={8} cols={8}>
 *   <Token x={1} y={2} size={0.5}/>
 * </Grid>
 *
 * <HexGrid>
 *   <Token x={1} y={2} z={-3}/>
 * </HexGrid>
 *
 * <Grid rows={8} cols={8}>
 *   <Token x={1} y={2} mesh={THREE.js 3D-Object}/>
 * </Grid>
 *
 */

cov_13qjaz260k().s[0]++;
var Token = function Token(props) {
  cov_13qjaz260k().f[0]++;
  cov_13qjaz260k().s[1]++;
  return __jsx(_ui_context__WEBPACK_IMPORTED_MODULE_10__["default"].Consumer, null, function (context) {
    cov_13qjaz260k().f[1]++;
    cov_13qjaz260k().s[2]++;
    return __jsx(TokenImpl, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, props, {
      context: context
    }));
  });
};

var TokenImpl = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(TokenImpl, _React$Component);

  var _super = _createSuper(TokenImpl);

  function TokenImpl(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, TokenImpl);

    cov_13qjaz260k().f[2]++;
    cov_13qjaz260k().s[5]++;
    _this = _super.call(this);

    Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "_attachMesh", (cov_13qjaz260k().s[12]++, function (mesh) {
      cov_13qjaz260k().f[3]++;
      var size = (cov_13qjaz260k().s[13]++, _this.size);
      var meshSize = (cov_13qjaz260k().s[14]++, new three__WEBPACK_IMPORTED_MODULE_11__["Vector3"]());
      var meshCenter = (cov_13qjaz260k().s[15]++, new three__WEBPACK_IMPORTED_MODULE_11__["Vector3"]());
      var bbox = (cov_13qjaz260k().s[16]++, new three__WEBPACK_IMPORTED_MODULE_11__["Box3"]().setFromObject(mesh));
      cov_13qjaz260k().s[17]++;
      bbox.getSize(meshSize);
      cov_13qjaz260k().s[18]++;
      bbox.getCenter(meshCenter); // determine the scale factor

      var scale = (cov_13qjaz260k().s[19]++, meshSize.z < meshSize.x ? (cov_13qjaz260k().b[2][0]++, meshSize.x) : (cov_13qjaz260k().b[2][1]++, meshSize.z));
      cov_13qjaz260k().s[20]++;
      scale = size / scale;
      cov_13qjaz260k().s[21]++;
      mesh.scale.set(scale, scale, scale); // set the mesh to the ground

      cov_13qjaz260k().s[22]++;

      if ((cov_13qjaz260k().b[4][0]++, _this.props.boardSize) && (cov_13qjaz260k().b[4][1]++, _this.props.lift) && (cov_13qjaz260k().b[4][2]++, _this.props.padding)) {
        cov_13qjaz260k().b[3][0]++;
        cov_13qjaz260k().s[23]++;
        mesh.position.x = _this.props.x * (_this.props.boardSize + _this.props.padding);
        cov_13qjaz260k().s[24]++;
        mesh.position.z = _this.props.y * (_this.props.boardSize + _this.props.padding);
        cov_13qjaz260k().s[25]++;
        mesh.position.y = -bbox.min.y + _this.props.lift;
      } else {
        cov_13qjaz260k().b[3][1]++;
        cov_13qjaz260k().s[26]++;
        mesh.position.x = _this.props.x;
        cov_13qjaz260k().s[27]++;
        mesh.position.z = _this.props.y;
        cov_13qjaz260k().s[28]++;
        mesh.position.y = -bbox.min.y;
      }

      cov_13qjaz260k().s[29]++;

      _this.parent.add(mesh); // register the event


      cov_13qjaz260k().s[30]++;

      var onEvent = function onEvent(e) {
        cov_13qjaz260k().f[4]++;
        cov_13qjaz260k().s[31]++;

        if (e.type == 'click') {
          cov_13qjaz260k().b[5][0]++;
          cov_13qjaz260k().s[32]++;

          _this.props.onClick({
            x: _this.props.x,
            y: _this.props.y
          });
        } else {
          cov_13qjaz260k().b[5][1]++;
          cov_13qjaz260k().s[33]++;

          if (e.type == 'mouseOver') {
            cov_13qjaz260k().b[6][0]++;
            cov_13qjaz260k().s[34]++;

            _this.props.onMouseOver({
              x: _this.props.x,
              y: _this.props.y
            });
          } else {
            cov_13qjaz260k().b[6][1]++;
            cov_13qjaz260k().s[35]++;

            if (e.type == 'mouseOut') {
              cov_13qjaz260k().b[7][0]++;
              cov_13qjaz260k().s[36]++;

              _this.props.onMouseOut({
                x: _this.props.x,
                y: _this.props.y
              });
            } else {
              cov_13qjaz260k().b[7][1]++;
            }
          }
        }
      };

      cov_13qjaz260k().s[37]++;

      _this.props.context.regCall(mesh, onEvent);
    }));

    cov_13qjaz260k().s[6]++;

    if (!props.size) {
      cov_13qjaz260k().b[0][0]++;
      cov_13qjaz260k().s[7]++;
      _this.size = props.boardSize;
    } else {
      cov_13qjaz260k().b[0][1]++;
      cov_13qjaz260k().s[8]++;
      _this.size = props.size;
    }

    cov_13qjaz260k().s[9]++;

    if (props.parent) {
      cov_13qjaz260k().b[1][0]++;
      cov_13qjaz260k().s[10]++;
      _this.parent = props.parent;
    } else {
      cov_13qjaz260k().b[1][1]++;
      cov_13qjaz260k().s[11]++;
      _this.parent = props.context;
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(TokenImpl, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cov_13qjaz260k().f[5]++;
      cov_13qjaz260k().s[38]++;
      this.parent.remove(this.prevMesh);
    }
  }, {
    key: "render",
    value: function render() {
      cov_13qjaz260k().f[6]++;
      var mesh = (cov_13qjaz260k().s[39]++, this.props.mesh);
      cov_13qjaz260k().s[40]++;

      if ((cov_13qjaz260k().b[9][0]++, this.prevMesh) && (cov_13qjaz260k().b[9][1]++, this.prevMesh === mesh)) {
        cov_13qjaz260k().b[8][0]++;
        cov_13qjaz260k().s[41]++;
        return null;
      } else {
        cov_13qjaz260k().b[8][1]++;
      }

      cov_13qjaz260k().s[42]++;

      if (!mesh) {
        cov_13qjaz260k().b[10][0]++;
        cov_13qjaz260k().s[43]++;
        mesh = new three__WEBPACK_IMPORTED_MODULE_11__["Mesh"](new three__WEBPACK_IMPORTED_MODULE_11__["BoxBufferGeometry"](1, 1 * 0.3, 1), new three__WEBPACK_IMPORTED_MODULE_11__["MeshLambertMaterial"]({
          color: '#eeeeee'
        }));
        cov_13qjaz260k().s[44]++;

        this._attachMesh(mesh);
      } else {
        cov_13qjaz260k().b[10][1]++;
        cov_13qjaz260k().s[45]++;

        if (mesh.isObject3D) {
          cov_13qjaz260k().b[11][0]++;
          cov_13qjaz260k().s[46]++;

          this._attachMesh(mesh);
        } else {
          cov_13qjaz260k().b[11][1]++;
          cov_13qjaz260k().s[47]++;
          console.error('Your input to tokens should be an three js 3d object');
        }
      }

      cov_13qjaz260k().s[48]++;
      this.parent.remove(this.prevMesh);
      cov_13qjaz260k().s[49]++;
      this.prevMesh = mesh;
      cov_13qjaz260k().s[50]++;
      return null;
    }
  }]);

  return TokenImpl;
}((react__WEBPACK_IMPORTED_MODULE_8___default.a.Component));

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(TokenImpl, "propTypes", (cov_13qjaz260k().s[3]++, {
  x: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.number,
  y: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.number,
  z: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.number,
  mesh: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.any,
  padding: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.number,
  size: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.number,
  lift: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.number,
  boardSize: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.number,
  parent: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.instanceOf(three__WEBPACK_IMPORTED_MODULE_11__["Object3D"]),
  context: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.object,
  animate: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.bool,
  onClick: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.func,
  onMouseOver: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.func,
  onMouseOut: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.func,
  children: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.element,
  animationDuration: prop_types__WEBPACK_IMPORTED_MODULE_9___default.a.number
}));

Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(TokenImpl, "defaultProps", (cov_13qjaz260k().s[4]++, {
  animationDuration: 750,
  size: 1,
  padding: 0.1,
  lift: 0.1
}));

/***/ }),

/***/ "./src/ui/grid.js":
/*!************************!*\
  !*** ./src/ui/grid.js ***!
  \************************/
/*! exports provided: Grid, Square */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Grid", function() { return Grid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Square", function() { return Square; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _2d_grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./2d/grid */ "./src/ui/2d/grid.js");
/* harmony import */ var _3d_grid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./3d/grid */ "./src/ui/3d/grid.js");
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_az6vzkqpz() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/ui/grid.js";
  var hash = "4af15771e371a1953ba612db33a884c5fe076d62";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/ui/grid.js",
    statementMap: {
      "0": {
        start: {
          line: 14,
          column: 20
        },
        end: {
          line: 16,
          column: 1
        }
      },
      "1": {
        start: {
          line: 15,
          column: 2
        },
        end: {
          line: 15,
          column: 115
        }
      },
      "2": {
        start: {
          line: 18,
          column: 0
        },
        end: {
          line: 21,
          column: 2
        }
      },
      "3": {
        start: {
          line: 23,
          column: 22
        },
        end: {
          line: 29,
          column: 1
        }
      },
      "4": {
        start: {
          line: 24,
          column: 2
        },
        end: {
          line: 28,
          column: 4
        }
      },
      "5": {
        start: {
          line: 31,
          column: 0
        },
        end: {
          line: 34,
          column: 2
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 14,
            column: 20
          },
          end: {
            line: 14,
            column: 21
          }
        },
        loc: {
          start: {
            line: 14,
            column: 31
          },
          end: {
            line: 16,
            column: 1
          }
        },
        line: 14
      },
      "1": {
        name: "(anonymous_1)",
        decl: {
          start: {
            line: 23,
            column: 22
          },
          end: {
            line: 23,
            column: 23
          }
        },
        loc: {
          start: {
            line: 23,
            column: 33
          },
          end: {
            line: 29,
            column: 1
          }
        },
        line: 23
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 15,
            column: 9
          },
          end: {
            line: 15,
            column: 114
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 15,
            column: 23
          },
          end: {
            line: 15,
            column: 67
          }
        }, {
          start: {
            line: 15,
            column: 70
          },
          end: {
            line: 15,
            column: 114
          }
        }],
        line: 15
      },
      "1": {
        loc: {
          start: {
            line: 24,
            column: 9
          },
          end: {
            line: 28,
            column: 3
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 25,
            column: 4
          },
          end: {
            line: 25,
            column: 52
          }
        }, {
          start: {
            line: 27,
            column: 4
          },
          end: {
            line: 27,
            column: 52
          }
        }],
        line: 24
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0,
      "3": 0,
      "4": 0,
      "5": 0
    },
    f: {
      "0": 0,
      "1": 0
    },
    b: {
      "0": [0, 0],
      "1": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "4af15771e371a1953ba612db33a884c5fe076d62"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_az6vzkqpz = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_az6vzkqpz();

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */




cov_az6vzkqpz().s[0]++;
var Grid = function Grid(props) {
  cov_az6vzkqpz().f[0]++;
  cov_az6vzkqpz().s[1]++;
  return props.three ? (cov_az6vzkqpz().b[0][0]++, __jsx(_3d_grid__WEBPACK_IMPORTED_MODULE_3__["Grid"], props, props.children)) : (cov_az6vzkqpz().b[0][1]++, __jsx(_2d_grid__WEBPACK_IMPORTED_MODULE_2__["Grid"], props, props.children));
};
cov_az6vzkqpz().s[2]++;
Grid.propTypes = {
  three: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any
};
cov_az6vzkqpz().s[3]++;
var Square = function Square(props) {
  cov_az6vzkqpz().f[1]++;
  cov_az6vzkqpz().s[4]++;
  return props.three ? (cov_az6vzkqpz().b[1][0]++, __jsx(_3d_grid__WEBPACK_IMPORTED_MODULE_3__["Square"], props, props.children)) : (cov_az6vzkqpz().b[1][1]++, __jsx(_2d_grid__WEBPACK_IMPORTED_MODULE_2__["Square"], props, props.children));
};
cov_az6vzkqpz().s[5]++;
Square.propTypes = {
  three: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any
};

/***/ }),

/***/ "./src/ui/index.ts":
/*!*************************!*\
  !*** ./src/ui/index.ts ***!
  \*************************/
/*! exports provided: Grid, Token */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _grid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./grid.js */ "./src/ui/grid.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Grid", function() { return _grid_js__WEBPACK_IMPORTED_MODULE_0__["Grid"]; });

/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./token.js */ "./src/ui/token.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return _token_js__WEBPACK_IMPORTED_MODULE_1__["Token"]; });

function cov_2kyvi3a6sy() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/ui/index.ts";
  var hash = "85bd29de22ba005177b3d62bae6d1f52495cf187";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/ui/index.ts",
    statementMap: {},
    fnMap: {},
    branchMap: {},
    s: {},
    f: {},
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "85bd29de22ba005177b3d62bae6d1f52495cf187"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_2kyvi3a6sy = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_2kyvi3a6sy();



/***/ }),

/***/ "./src/ui/token.js":
/*!*************************!*\
  !*** ./src/ui/token.js ***!
  \*************************/
/*! exports provided: Token */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _2d_token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./2d/token */ "./src/ui/2d/token.js");
/* harmony import */ var _3d_token__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./3d/token */ "./src/ui/3d/token.js");
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function cov_c5ece7zp0() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/ui/token.js";
  var hash = "09173f77d71bcd5f0c9a4db26c9a86fe6dedc243";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/ui/token.js",
    statementMap: {
      "0": {
        start: {
          line: 14,
          column: 21
        },
        end: {
          line: 16,
          column: 1
        }
      },
      "1": {
        start: {
          line: 15,
          column: 2
        },
        end: {
          line: 15,
          column: 119
        }
      },
      "2": {
        start: {
          line: 18,
          column: 0
        },
        end: {
          line: 21,
          column: 2
        }
      }
    },
    fnMap: {
      "0": {
        name: "(anonymous_0)",
        decl: {
          start: {
            line: 14,
            column: 21
          },
          end: {
            line: 14,
            column: 22
          }
        },
        loc: {
          start: {
            line: 14,
            column: 32
          },
          end: {
            line: 16,
            column: 1
          }
        },
        line: 14
      }
    },
    branchMap: {
      "0": {
        loc: {
          start: {
            line: 15,
            column: 9
          },
          end: {
            line: 15,
            column: 118
          }
        },
        type: "cond-expr",
        locations: [{
          start: {
            line: 15,
            column: 23
          },
          end: {
            line: 15,
            column: 69
          }
        }, {
          start: {
            line: 15,
            column: 72
          },
          end: {
            line: 15,
            column: 118
          }
        }],
        line: 15
      }
    },
    s: {
      "0": 0,
      "1": 0,
      "2": 0
    },
    f: {
      "0": 0
    },
    b: {
      "0": [0, 0]
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "09173f77d71bcd5f0c9a4db26c9a86fe6dedc243"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_c5ece7zp0 = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_c5ece7zp0();

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */




cov_c5ece7zp0().s[0]++;
var Token = function Token(props) {
  cov_c5ece7zp0().f[0]++;
  cov_c5ece7zp0().s[1]++;
  return props.three ? (cov_c5ece7zp0().b[0][0]++, __jsx(_3d_token__WEBPACK_IMPORTED_MODULE_3__["Token"], props, props.children)) : (cov_c5ece7zp0().b[0][1]++, __jsx(_2d_token__WEBPACK_IMPORTED_MODULE_2__["Token"], props, props.children));
};
cov_c5ece7zp0().s[2]++;
Token.propTypes = {
  three: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any
};

/***/ }),

/***/ "./src/ui/ui-context.js":
/*!******************************!*\
  !*** ./src/ui/ui-context.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function cov_1ok2722der() {
  var path = "/home/j/Documents/FreeBoardGames.org/src/ui/ui-context.js";
  var hash = "162831f400627482496871cc3b9cdd29d67e9ad9";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/j/Documents/FreeBoardGames.org/src/ui/ui-context.js",
    statementMap: {
      "0": {
        start: {
          line: 11,
          column: 18
        },
        end: {
          line: 11,
          column: 39
        }
      }
    },
    fnMap: {},
    branchMap: {},
    s: {
      "0": 0
    },
    f: {},
    b: {},
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "162831f400627482496871cc3b9cdd29d67e9ad9"
  };
  var coverage = global[gcv] || (global[gcv] = {});

  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }

  var actualCoverage = coverage[path];

  cov_1ok2722der = function () {
    return actualCoverage;
  };

  return actualCoverage;
}

cov_1ok2722der();

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

var UIContext = (cov_1ok2722der().s[0]++, react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext());
/* harmony default export */ __webpack_exports__["default"] = (UIContext);

/***/ })

}]);
//# sourceMappingURL=1.js.map